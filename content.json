[{"title":"iTerm2插件git的缩写大全","date":"2018-05-13T15:45:42.000Z","path":"2018/05/13/iTerm2插件git的缩写大全/","text":"iTerm2终端集成git缩写意思oh-my-zsh git The git plugin provides many aliases and a few useful functions. Enable it by adding git to the plugins array before sourcing OMZ (see [[Plugins]]). Aliases Alias Command g git ga git add gaa git add –all gapa git add –patch gau git add –update gb git branch gba git branch -a gbda git branch –merged \\ command grep -vE “^(*\\ \\smaster\\s$)” \\ command xargs -n 1 git branch -d gbl git blame -b -w gbnm git branch –no-merged gbr git branch –remote gbs git bisect gbsb git bisect bad gbsg git bisect good gbsr git bisect reset gbss git bisect start gc git commit -v gc! git commit -v –amend gca git commit -v -a gcam git commit -a -m gca! git commit -v -a –amend gcan! git commit -v -a -s –no-edit –amend gcb git checkout -b gcf git config –list gcl git clone –recursive gclean git clean -df gcm git checkout master gcd git checkout develop gcmsg git commit -m gco git checkout gcount git shortlog -sn gcp git cherry-pick gcpa git cherry-pick –abort gcpc git cherry-pick –continue gcs git commit -S gd git diff gdca git diff –cached gdt git diff-tree –no-commit-id –name-only -r gdw git diff –word-diff gf git fetch gfa git fetch –all –prune gfo git fetch origin gg git gui citool gga git gui citool –amend ggf git push –force origin $(current_branch) ghh git help ggpull ggl ggpur ggu ggpush ggp ggsup git branch –set-upstream-to = origin/$(current_branch) gpsup git push –set-upstream origin $(current_branch) gignore git update-index –assume-unchanged gignored git ls-files -v \\ grep “^[[:lower:]]” git-svn-dcommit-push git svn dcommit &amp;&amp; git push github master:svntrunk gk \\gitk –all –branches gke \\gitk –all $(git log -g –pretty = format:%h) gl git pull glg git log –stat –color glgg git log –graph –color glgga git log –graph –decorate –all glgm git log –graph –max-count = 10 glgp git log –stat –color -p glo git log –oneline –decorate –color glog git log –oneline –decorate –color –graph glol git log –graph –pretty = format:’%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset’ –abbrev-commit glola git log –graph –pretty = format:’%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset’ –abbrev-commit –all glp _git_log_prettily gm git merge gmom git merge origin/master gmt git mergetool –no-prompt gmtvim git mergetool –no-prompt –tool = vimdiff gmum git merge upstream/master gp git push gpd git push –dry-run gpoat git push origin –all &amp;&amp; git push origin –tags gpristine git reset –hard &amp;&amp; git clean -dfx gpu git push upstream gpv git push -v gr git remote gra git remote add grb git rebase grba git rebase –abort grbc git rebase –continue grbi git rebase -i grbm git rebase master grbs git rebase –skip grh git reset HEAD grhh git reset HEAD –hard grmv git remote rename grrm git remote remove grset git remote set-url grt cd $(git rev-parse –show-toplevel \\ \\ echo “.”) gru git reset – grup git remote update grv git remote -v gsb git status -sb gsd git svn dcommit gsi git submodule init gsps git show –pretty = short –show-signature gsr git svn rebase gss git status -s gst git status gsta git stash save gstaa git stash apply gstd git stash drop gstl git stash list gstp git stash pop gstc git stash clear gsts git stash show –text gsu git submodule update gts git tag -s gunignore git update-index –no-assume-unchanged gunwip git log -n 1 \\ grep -q -c “--wip--“ &amp;&amp; git reset HEAD~1 gup git pull –rebase gupv git pull –rebase -v glum git pull upstream master gvt git verify-tag gwch git whatchanged -p –abbrev-commit –pretty = medium gwip git add -A; git rm $(git ls-files –deleted) 2&gt; /dev/null; git commit -m “–wip–” Deprecated AliasesThese are aliases that have been removed, renamed, or otherwise modified in a way that may, or may not, receive further support. Alias Command Modification gap git add –patch new alias gapa gcl git config –list new alias gcf gdc git diff –cached new alias gdca gdt git difftool no replacement ggpull git pull origin $(current_branch) new alias ggl (ggpull still exists for now though) ggpur git pull –rebase origin $(current_branch) new alias ggu (ggpur still exists for now though) ggpush git push origin $(current_branch) new alias ggp (ggpush still exists for now though) gk gitk –all –branches now aliased to \\gitk --all --branches glg git log –stat –max-count = 10 now aliased to git log --stat --color glgg git log –graph –max-count = 10 now aliased to git log --graph --color gwc git whatchanged -p –abbrev-commit –pretty = medium new alias gwch gwip git add -A; git ls-files –deleted -z \\ xargs -r0 git rm; git commit -m “–wip–” now aliased to git add -A; git rm $(git ls-files --deleted) 2&gt; /dev/null; git commit -m &quot;--wip--&quot; FunctionsCurrent Command Description current_branch Return the name of the current branch current_repository Return the names of the current remotes git_current_user_name Returns the user.name config value git_current_user_email Returns the user.email config value WiPThese features allow to pause a branch development and switch to another one (“Work in Progress”, or wip). When you want to go back to work, just unwip it. Command Description work_in_progress Echoes a warning if the current branch is a wip gwip Commit wip branch gunwip Uncommit wip branch","tags":[{"name":"iTerm2","slug":"iTerm2","permalink":"http://kingle.online/tags/iTerm2/"},{"name":"git","slug":"git","permalink":"http://kingle.online/tags/git/"}]},{"title":"Spacemacs_Rocks第二季","date":"2018-05-11T11:09:32.000Z","path":"2018/05/11/Spacemacs-Rocks第二季/","text":"Table of Contents转载自子龙山人 GitHub Spacemacs Rocks 第二季 第一天：准备开始 基础操作 内置功能 学习基础 Elisp 开始 Hacking！ 插件管理 Org-mode 第二天：高级自定义 Emacs 也很美 JavaScript IDE Org-mode 进阶 第三天：配置文件模块化（上） 多文件存储配置文件(上) Major 与 Minor Mode 详解 第四天：配置文件模块化（下）以及使用优化 配置文件模块化（下） 更好的默认设置 代码缩进 缩写补全 Hippie 补全 Dired Mode Org-mode 管理 Emacs 配置 第五天：打造前端开发神器 web-mode js2-refactor 优化 occur 与 imenu expand-region iedit Org 导出 第六天：代码片段与语法检查器 Org-mode 进阶使用 批量修改文件名 搜索与替换 语法检查器（Linter） 代码块 auto-yasnippet 第七天：Evil 模式 Evil 的安装 Evil 模式插件 Leader Key Window-numbering Evil-Surround Evil-nerd-commenter Which-key Org Mode 中的搜索 第八天：Cask 介绍与实践 Cask 的安装 为何使用 Cask 故障排除 Emacs24.5 时不能安装 let-alist 在 Emacs24.5 中没有定义 define-advice 第九天：Macro 与 Use-package Macro 什么是 Macro backquote 为什么使用宏 Use-package 简介 一些简单的用法 为什么使用 Use-package 第十天: Company-mode 与 auto-completion 升级 Package 之后有 BUG 怎么办 Use-package 的更多用法 Company-mode 的工作原理 为什么有时 Python 的补全 不工作 Group Backend 怎样写一个简单的补全后端 第十一天: Spacemacs 简介及安装 安装 Spacemacs 添加内置的 layer 一些简单的配置 启动时全屏显示 ivy layer 查看 layer 下的 文档信息 删除安装的 package 安装 package 配置 customize-group 修改主题 第十二天: 创建你的第一个 Spacemacs Layer 如何更新 Spacemacs variables 变量 定制 modeline 创建自己的 layer 文档 第十三天: 定制你的 Layer 修复上一期视频中的配置问题 修复 ivy0.8 的问题 post-init 和 pre-init location 自带 package 从 github 安装 layers.el 第十四天: 文件和 Buffer 操作 不同点 文件相关操作 buffer 相关操作 Dired 第十五天: layout, windows 和 project 相关 Layout 相关操作 Window 相关操作 project 相关操作 更多内容 第十六天: 使用 ctags 和 company-etags 为什么使用 ctags 如何配置 ctags 如何高效的使用 ctags 自动重新生成 TAGS 文件 配置规则来生成更多的 TAGS 使用 etags-select 来浏览项目 最后的思考 https://travis-ci.org/emacs-china/Spacemacs-rocks.svg?branch=master Spacemacs Rocks 第二季 GitHub Spacemacs Rocks 作者 zilongshanren 编者 li-xinyang, lsytj0413 在这一季中我们计划用 21 天学习 Emacs 以及 Spacemacs 的使用。从基础安装开始到可以运用到工作生产环节中。为了确保学习质量，请务必完成和理解计划中的每一项学习任务。 第一天：准备开始视频地址如下 优酷视频 百度网盘 YouTube 说在最前面 如果你第一次听说 Emacs 你可以在性感的 Emacs（Emacs is Sexy）一文中找到使用它的理由！我相信你一定会被它的强大所吸引。 如果你还没有安装 Emacs 可以在 Mac OS X 安装链接以及 Window 安装链接找到它。本文我们使用的为 Emacs 25.0.x Pretest 版本，一些配置在 Emacs 24 中可能并不适用。 在开始本教程之前请务必先完成 Emacs 提供的官方教程（完成时间大约 30 分钟），它可以通过使用 C-h t （同时按住 Ctrl 与 h 键，接着按 t 键 t 在这里代表 tutorial）在 Emacs 中直接将其打开。 Emacs Lisp 是 Emacs 所用的编程语言，你可以在阅读这篇教程（Learn X in Y Minutes）后很快地了解它的基础用法。 基础操作因为 Control 键在 Emacs 中极为常用，所以为了更方便地使用 Emacs 的键位修改，需要对其做出修改。建议将大写锁定键（Caps Lock）替换为 Control 键。这里是一个可以参考的把大写锁定键替换为 Control 键的教程：移动 Control 键 (Moving The Ctrl Key)。如果这个的教程不适用于你的操作系统，请自行搜索其它的修改方式。 常见符号所代表的意义如下 M(eta)，在 Mac 下为 Option 键 s(uper)，在 Mac 环境下为左 Command 键 S(Shift) C(trl) 光标的移动是编辑器中最常用的操作所以必须熟知。 C-f 为前移一个字符， f 代表 forward。 C-b 为后移一个字符， b 代表 backward。 C-p 为上移至前一行， p 代表 previous。 C-n 为上移至下一行， n 代表 next。 C-a 为移至行首， a 代表 ahead。 C-e 为移至行尾， e 代表 end。 常用的文件操作快捷键组合也必须熟记。 C-x C-f 为打开目标文件， f 代表 find/file C-x C-s 为保存当前缓冲区（Buffer）， s 代表 save C-x 是 Emacs 的快捷键中常用的前缀命令。这些前缀命令常常代表了一系列有关联的指令，十分重要，请特别牢记。其它常见的还有 C-c, C-h 。打断组合键为 C-g ，它用于终端取消之前的指令。快捷键就是用预先绑定好的方式告诉 Emacs 去执行指定的命令。（之后会介绍到更多有关绑定的内容） 内置功能Emacs 功能强大，但是部分功能默认情况下并未开启。下面就有几个例子， 编辑器内显示行号可使用 M-x linum-mode 来开启。 获取帮助 Emacs 是一个富文档编辑器（Self document, extensible editor）而下面的三种方法在学习 Emacs 的过程中也非常重要。他们分别是， C-h k 寻找快捷键的帮助信息 C-h v 寻找变量的帮助信息 C-h f 寻找函数的帮助信息 学习基础 Elisp请务必完成这篇教程（Learn X in Y Minutes）来了解 Elisp 的使用（阅读时间大约 15分钟），你也可以在这里找到它的中文版。Emacs Lisp 为一个函数式的语言，所以它全部功能都是由函数来实现的。 下面为一些简单的例子 ;; 2 + 2 (+ 2 2) ;; 2 + 3 * 4 (+ 2 (* 3 4)) ;; 定义变量 (setq name &quot;username&quot;) (message name) ; -&gt; &quot;username&quot; ;; 定义函数 (defun func () (message &quot;Hello, %s&quot; name)) ;; 执行函数 (func) ; -&gt; Hello, username ;; 设置快捷键 (global-set-key (kbd &quot;&lt;f1&gt;&quot;) &apos;func) ;; 使函数可直接被调用可添加 (interactive) (defun func () (interactive) (message &quot;Hello, %s&quot; name)) 开始 Hacking！Emacs 的配置文件默认保存在 ~/.emacs.d/init.el 文件中。（如果其不存在可自行创建，配置文件也可保存在 ~/.emacs 文件中，他们之间的区别我们会在后面做讨论） 注意： 如果希望把配置放在 ~/.emacs.d/init.el 文件中，那么需要手工删除~/.emacs 文件。 在开始配置之前让我们先来区别 Emacs 中 Major Mode 与 Minor Mode 的区别。MajorMode 通常是定义对于一种文件类型编辑的核心规则，例如语法高亮、缩进、快捷键绑定等。而 Minor Mode 是除去 Major Mode 所提供的核心功能以外的额外编辑功能（辅助功能）。例如在下面的配置文件中 tool-bar-mode 与 linum-mode 等均为 Minor Mode*。 简单来说就是，一种文件类型同时只能存在一种 Major Mode 但是它可以同时激活一种或多种 Minor Mode。如果你希望知道当前的模式信息，可以使用 C-h m 来显示当前所有开启的全部 Minor Mode 的信息。 简单的编辑器自定义 下面是一些简单的编辑器配置信息，你需要做的就是将其写入你的配置文件中（ ~/.emacs.d/init.el ）即可。 ;; 关闭工具栏，tool-bar-mode 即为一个 Minor Mode (tool-bar-mode -1) ;; 关闭文件滑动控件 (scroll-bar-mode -1) ;; 显示行号 (global-linum-mode 1) ;; 更改光标的样式（不能生效，解决方案见第二集） (setq cursor-type &apos;bar) ;; 关闭启动帮助画面 (setq inhibit-splash-screen 1) ;; 关闭缩进 (第二天中被去除) ;; (electric-indent-mode -1) ;; 更改显示字体大小 16pt ;; http://stackoverflow.com/questions/294664/how-to-set-the-font-size-in-emacs (set-face-attribute &apos;default nil :height 160) ;; 快速打开配置文件 (defun open-init-file() (interactive) (find-file &quot;~/.emacs.d/init.el&quot;)) ;; 这一行代码，将函数 open-init-file 绑定到 &lt;f2&gt; 键上 (global-set-key (kbd &quot;&lt;f2&gt;&quot;) &apos;open-init-file) 在每次编辑配置文件后，刚刚做的修改并不会立刻生效。这时你需要重启编辑器或者重新加载配置文件。重新加载配置文件你需要在当前配置文件中使用 M-x load-file 双击两次回车确认默认文件名，或者使用 M-x eval-buffer 去执行当前缓冲区的所有 Lisp 命令。你也可以使用 C-x C-e 来执行某一行的 Lisp 代码。这些可使刚刚修改的配置文件生效。当然你也可以将这些函数绑定为快捷键。 插件管理使用默认的插件管理系统（可在菜单栏 Options &gt; Manage Emacs Packages 中找到）安装 Company 插件，他是一个用于代码补全的插件。它的名字代表补全一切的意思（ Complete Any thing）。因为默认的插件管理系统提供的插件十分有限，所以我们会在之后的几天中继续将其强化。 使用的下面的配置将 Company-mode 在全局模式下激活 ; 开启全局 Company 补全 (global-company-mode 1) Org-mode简单的 Org-mode 使用，它可以列出提纲，并方便地使用 tab 键来对其进行展开与关闭。C-c C-t 可以将一个条目转换成一条待办事件。 * 为一级标题 ** 为二级标题 *** 为三级标题并以此类推 第二天：高级自定义视频地址如下 优酷视频 百度网盘 YouTube 说在最前面 如果你想深入学习 Emacs Lisp 可以阅读 GNU 提供的 An Introduction to Programmingin Emacs Lisp 。（也可以 M-x info 然后选择 Emacs Lisp Intro） 我们先解决前一天中遇到的一些问题。首先是在对象是一个缓冲区局部变量（Buffer-localvariable）的时候，比如这里的 cursor-type ，我们需要区分 setq 与setq-default ： setq 设置当前缓冲区（Buffer）中的变量值， setq-default 设置的为全局的变量的值（具体内容可以在 StackOverflow 找到）。下面是一个例子，用于设置光标样式的方法。 (setq-default cursor-type &apos;bar) 今天我们需要将第一天关闭的自动缩进 (electric-indent-mode) 从配置文件中去除，它是 Emacs 24.4 中加入的新特性，你可以在这篇文章中找到更多关于它的内容。我们之前关闭它是因为，它存在不理想的缩进效果（在 Emacs Lisp 中用分号做注释时fancy-comment 会造成很远的缩进，其实解决方法是使用 Emacs Lisp 推荐的两个分号而不是一个 ;; ，这样就可以避免这个问题。于是我们也就将其从配置文件中删除） 因为通常我们的配置文件以及项目文件均使用版本控制系统，所以自动生成的备份文件就显得有些多余。我们还可以禁止 Emacs 自动生成备份文件，例如 init.el~ 。（ ~ 为后缀的文件为自动生成的备份文件）我们可以使用下面的方法将其关闭。 (setq make-backup-files nil) 关于分屏的使用，如果你已经读过 Emacs 自带的教程，现在你应该已经掌握了基本的分屏操作方法了。关于分屏的更多内容你可以在这里找到。 C-x 1 仅保留当前窗口 C-x 2 将当前窗口分到上边 C-x 3 将当前窗口分到右边 使用下面的配置来加入最近打开过文件的选项让我们更快捷的在图形界面的菜单中打开最近编辑过的文件。 (require &apos;recentf) (recentf-mode 1) (setq recentf-max-menu-item 10) ;; 这个快捷键绑定可以用之后的插件 counsel 代替 ;; (global-set-key (kbd &quot;C-x C-r&quot;) &apos;recentf-open-files) require 的意思为从文件中加载特性，你可以在杀哥的网站读到关于 Emacs Lisp 库系统的更多内容，文章在这里。 使用下面的配置文件将删除功能配置成与其他图形界面的编辑器相同，即当你选中一段文字之后输入一个字符会替换掉你选中部分的文字。 (delete-selection-mode 1) 下面的这些函数可以让你找到不同函数，变量以及快捷键所定义的文件位置。因为非常常用所以我们建议将其设置为与查找文档类似的快捷键（如下所示）， find-function （ C-h C-f ） find-variable （ C-h C-v ） find-function-on-key （ C-h C-k ） 在我们进入下一个部分之间让我们来看看使用 ~/.emacs.d/init.el 与 ~/.emacs 的区别（更多关于他们区别的讨论可在这里找到）。简单来说请使用前者，因为它有下面的两个优点， 它可以更好将所有 Emacs 相关的文件整合在一个目录内（干净的 HOME ，网盘备份等优点） 更好的版本控制 Emacs 也很美配置插件源 在进行美化之前我们需要配置插件的源（默认的源非常有限），最常使用的是 MELPA（Milkypostman’s Emacs Lisp Package Archive）。它有非常多的插件（3000 多个插件）。一个插件下载的次数多并不能说明它非常有用，也许这个插件是其他的插件的依赖。在这里你可以找到其安装使用方法。添加源后，我们就可以使用 M-x package-list-packages来查看所有 MELPA 上的插件了。在表单中可以使用 I 来标记安装 D 来标记删除，U 来更新，并用 X 来确认。 你可以直接将下面的代码复制到你的配置文件顶端，从而直接使用 Melpa 作为插件的源。你可以将你需要的插件名字写在 my/packages 中，Emacs 在启动时会自动下载未被安装的插件。 (when (&gt;= emacs-major-version 24) (require &apos;package) (package-initialize) (setq package-archives &apos;((&quot;gnu&quot; . &quot;http://elpa.emacs-china.org/gnu/&quot;) (&quot;melpa&quot; . &quot;http://elpa.emacs-china.org/melpa/&quot;)))) ;; 注意 elpa.emacs-china.org 是 Emacs China 中文社区在国内搭建的一个 ELPA 镜像 ;; cl - Common Lisp Extension (require &apos;cl) ;; Add Packages (defvar my/packages &apos;( ;; --- Auto-completion --- company ;; --- Better Editor --- hungry-delete swiper counsel smartparens ;; --- Major Mode --- js2-mode ;; --- Minor Mode --- nodejs-repl exec-path-from-shell ;; --- Themes --- monokai-theme ;; solarized-theme ) &quot;Default packages&quot;) (setq package-selected-packages my/packages) (defun my/packages-installed-p () (loop for pkg in my/packages when (not (package-installed-p pkg)) do (return nil) finally (return t))) (unless (my/packages-installed-p) (message &quot;%s&quot; &quot;Refreshing package database...&quot;) (package-refresh-contents) (dolist (pkg my/packages) (when (not (package-installed-p pkg)) (package-install pkg)))) ;; Find Executable Path on OS X (when (memq window-system &apos;(mac ns)) (exec-path-from-shell-initialize)) 关于上面这段配置代码有几个知识点，首先就是这段配置文件中用到了 loop for ... in，它来自 cl 即 Common Lisp 扩展。 for , in, collect 均为 cl-loop 中的保留关键字。下面是一些简单的 cl-loop 的使用示例： ;; 遍历每一个缓冲区（Buffer） (cl-loop for buf in (buffer-list) collect (buffer-file-name buf)) ;; 寻找 729 的平方根（设置最大为 100 为了防止无限循环） (cl-loop for x from 1 to 100 for y = (* x x) until (&gt;= y 729) finally return (list x (= y 729))) 你可以在这里找到更多关于循环的使用说明。 其次就是它使用到了 quote, 它其实就是我们之前常常见到的 &#39; （单引号）的完全体。因为它在 Lisp 中十分常用，所以就提供了简写的方法。 ;; 下面两行的效果完全相同的 (quote foo) &apos;foo quote 的意思是不要执行后面的内容，返回它原本的内容（具体请参考下面的例子） (print &apos;(+ 1 1)) ;; -&gt; (+ 1 1) (print (+ 1 1)) ;; -&gt; 2 更多关于 quote 的内容可以在这里找到，或者在这里找到 StackOverflow 上对于它的讨论。 这样我们就可以区分下面三行代码的区别， ;; 第一种 (setq package-selected-packages my/packages) ;; 第二种 (setq package-selected-packages &apos;my/packages) ;; 第三种 (setq package-selected-packages (quote my/packages)) 第一种设置是在缓冲区中设置一个名为 package-selected-packages 的变量，将其的值设定为 my/packages 变量的值。第二种和第三种其实是完全相同的，将一个名为package-selected-packages 的变量设置为 my/packages 。 我们可以用下面代码将 Emacs 设置为开启默认全屏， (setq initial-frame-alist (quote ((fullscreen . maximized)))) 我们也可以启用自动括号匹配（Highlight Matching Parenthesis），随后会介绍插件来增强这个匹配的功能。你可以在这里读到关于钩子的更多信息。 (add-hook &apos;emacs-lisp-mode-hook &apos;show-paren-mode) 高亮当前行，当文本内容很多时可以很容易找到光标的位置。 (global-hl-line-mode 1) 安装主题 (add-to-list &apos;my/packages &apos;monokai-theme) 然后使用下面的配置使其每次打开编辑器时加载主题， (load-theme &apos;monokai 1) 推荐插件 company hungry-delete Smex (如果你使用 Counsel 来增强你的 M-x ，那么就不需要再安装 Smex 了) Swiper &amp; Counsel smartparens 使用 M-x customize-group 后选择对应的插件名称，可以进入可视化选项区对指定的插件做自定义设置。当选择 Save for future session 后，刚刚做的设计就会被保存在你的配置文件（ init.el ）中。关于各个插件的安装与使用方法通常都可以在其官方页面找到（GitHub Pages 或者是项目仓库中的 README 文件）。我们强烈建议大家在安装这些插件后阅读使用方法来更好的将它们使用到你的日常工作当中使效率最大化。 JavaScript IDEEmacs 提供的默认 JavaScript Major Mode 并不是非常好用。所以我们可以将默认的模式替换成 js2-mode 一个比默认模式好用的 Major Mode。我们可以通过 MELPA 来下载它，然后用下面的代码将其启用。 (setq auto-mode-alist (append &apos;((&quot;\\\\.js\\\\&apos;&quot; . js2-mode)) auto-mode-alist)) 你可以在这里（How Emacs Chooses a Major Mode）找到 Emacs 是如何选择何时该选用何种 Major Mode 的方法。 在这里我们需要知道 auto-mode-alist 的作用，这个变量是一个 AssociationList，它使用正则表达式（REGEXP）的规则来匹配不同类型文件应使用的 Major Mode。 下面是几个正则表达式匹配的例子， ((&quot;\\\\`/tmp/fol/&quot; . text-mode) (&quot;\\\\.texinfo\\\\&apos;&quot; . texinfo-mode) (&quot;\\\\.texi\\\\&apos;&quot; . texinfo-mode) (&quot;\\\\.el\\\\&apos;&quot; . emacs-lisp-mode) (&quot;\\\\.c\\\\&apos;&quot; . c-mode) (&quot;\\\\.h\\\\&apos;&quot; . c-mode) …) 下面是如何添加新的模式与对应文件类型的例子（与我们配置 js2-mode 时相似的例子）， (setq auto-mode-alist (append ;; File name (within directory) starts with a dot. &apos;((&quot;/\\\\.[^/]*\\\\&apos;&quot; . fundamental-mode) ;; File name has no dot. (&quot;/[^\\\\./]*\\\\&apos;&quot; . fundamental-mode) ;; File name ends in ‘.C’. (&quot;\\\\.C\\\\&apos;&quot; . c++-mode)) auto-mode-alist)) 在 js2-mode 模式中会提供 语法高亮 语法检查器（Linter） 执行缓冲区的代码可以使用 nodejs-repl 插件，它需要你的机器上已经安装了 NodeJS。然而在 Mac OS X 上可能会出现找不到 NodeJS 可执行文件的问题，要解决这个问题你需要安装另外一个 exec-path-from-shell 的插件并将其启用。 (when (memq window-system &apos;(mac ns)) (exec-path-from-shell-initialize)) 有了 nodejs-repl 我们就可以方便的测试和开发我们的 JavaScript 代码了（你可以在这里找到更多关于它的使用方法）。 Org-mode 进阶在 Org-mode 中你可以直接开启新的缓冲区（Buffer）直接用相应的 Major Mode 来编辑代码块内的内容。在代码块中使用 C-c &#39; 会直接打开对应模式的缓冲区（不仅限于 Lisp）。这样就使在 Org-mode 中编辑代码变的十分方便快捷。 使用 &lt;s 然后 Tab 可以直接插入代码块的代码片段（Snippet），更多类似的代码片段（Org-mode Easy Templates）可以在这里找到。 #+BEGIN_SRC emacs-lisp ;; Your code goes here ;; 你的代码写在这里 #+END_SRC 添加 Org-mode 文本内语法高亮 (require &apos;org) (setq org-src-fontify-natively t) 在 Org-mode 中重置有序列表序号可以直接使用 M- 。 Agenda 的使用 ;; 设置默认 Org Agenda 文件目录 (setq org-agenda-files &apos;(&quot;~/org&quot;)) ;; 设置 org-agenda 打开快捷键 (global-set-key (kbd &quot;C-c a&quot;) &apos;org-agenda) 你只需将你的 *.org 文件放入上面所指定的文件夹中就可以开始使用 Agenda模式了。 C-c C-s 选择想要开始的时间 C-c C-d 选择想要结束的时间 C-c a 可以打开 Agenda 模式菜单并选择不同的可视方式（ r ） 第三天：配置文件模块化（上）视频地址如下 优酷视频 百度网盘 YouTube 多文件存储配置文件(上)将不同的配置代码放置到不同的文件中，使其模块化，这让我们的后续维护变得更加简单。下面是我们现在的 ~/.emacs.d/ 目录中的样子， ├── auto-save-list # 自动生成的保存数据 ├── elpa # 下载的插件目录 ├── init.el # 我们的配置文件 └── recentf # 最近访问的文件列表 通常我们只保存配置文件和对其进行版本控制，其他的插件均为在第一次使用编辑器时再通过网络重新下载，当然你也可以选择将全部配置文件进行版本控制来保证自己时刻拥有最稳定的生产环境。 Elisp 中并没有命名空间（Namespace），换句话说就是所有的变量均为全局变量，所以其命名方法就变的非常重要。下面是一个简单的命名规则， #自定义变量可以使用自己的名字作为命名方式（可以是变量名或者函数名） my/XXXX #模式命名规则 ModeName-mode #模式内的变量则可以使用 ModeName-VariableName 遵守上面的命名规则可以最大程度的减少命名冲突发生的可能性。 现在我们想将原本混合在一起的配置文件分为下面的几个模块（每一个模块为一个独立的配置文件并将其保存在指定的子目录中），它们分别是 init-packages.el # 插件管理 init-ui.el # 视觉层配置 init-better-defaults.el # 增强内置功能 init-keybindings.el # 快捷键绑定 init-org.el # Org 模式相关的全部设定 custome.el # 存放使用编辑器接口产生的配置信息 下面为将配置文件进行模块化后的目录结构， ├── init.el └── lisp ├── custom.el ├── init-better-defaults.el ├── init-helper.el ├── init-keybindings.el ├── init-packages.el ├── init-ui.el └── init-org.el 使用模块化配置就可以让我们在之后的配置中迅速的定位与更改配置内容，让整个过程变得更有条理也更加高效。 和之前一样 init.el 是配置文件的入口，现在它便成为了所有模块配置文件的入口，所以要使用这些模块时，我们需要在其中引用需要加载的模块。下面以 init-packages.el（此配置为添加插件的模块） 为例，详细说明如何模块化以及应用的方法。 下面是在模块化配置之前，我们所使用的配置文件 ~/.emacs.d/init.el 的样子，我们将所有的配置代码都放置在了同一个文件中（如下所示） 下面为 ~/.emacs.d/init.el 文件的内容 ;; __ __ __ ___ ;; |__) /\\ / ` |__/ /\\ / _` |__ ;; | /~~\\ \\__, | \\ /~~\\ \\__&gt; |___ ;; __ ___ ___ ___ ;; |\\/| /\\ |\\ | /\\ / _` |__ |\\/| |__ |\\ | | ;; | | /~~\\ | \\| /~~\\ \\__&gt; |___ | | |___ | \\| | (when (&gt;= emacs-major-version 24) (require &apos;package) (package-initialize) (setq package-archives &apos;((&quot;gnu&quot; . &quot;http://elpa.emacs-china.org/gnu/&quot;) (&quot;melpa&quot; . &quot;http://elpa.emacs-china.org/melpa/&quot;)))) ;; cl - Common Lisp Extension (require &apos;cl) ;; Add Packages (defvar my/packages &apos;( ;; --- Auto-completion --- company ;; --- Better Editor --- smooth-scrolling hungry-delete swiper counsel smartparens ;; --- Major Mode --- js2-mode markdown-mode ;; --- Minor Mode --- ;; Quick Note Taking deft ;; JavaScript REPL nodejs-repl ;; Find OS X Executable Helper Package ;; ... 之前为了更好的区分不同的区域我使用的方法是使用 ASCII Art 然后再以关键字来做搜索跳转，但是这样再编辑工程中依旧十分缓慢和麻烦。于是我们现在要将配置文件全部模块化，把不同部分的配置代码放置在不同的配置文件中，并在入口文件（ ~/.emacs.d/init.el）中依次引用不用的模块。 下面为 ~/.emacs.d/lisp/init-packages.el 模块中的代码 ;; __ __ __ ___ ;; |__) /\\ / ` |__/ /\\ / _` |__ ;; | /~~\\ \\__, | \\ /~~\\ \\__&gt; |___ ;; __ ___ ___ ___ ;; |\\/| /\\ |\\ | /\\ / _` |__ |\\/| |__ |\\ | | ;; | | /~~\\ | \\| /~~\\ \\__&gt; |___ | | |___ | \\| | (when (&gt;= emacs-major-version 24) (require &apos;package) (package-initialize) (setq package-archives &apos;((&quot;gnu&quot; . &quot;http://elpa.emacs-china.org/gnu/&quot;) (&quot;melpa&quot; . &quot;http://elpa.emacs-china.org/melpa/&quot;)))) ;; cl - Common Lisp Extension (require &apos;cl) ;; Add Packages (defvar my/packages &apos;( ;; --- Auto-completion --- company ;; --- Better Editor --- smooth-scrolling hungry-delete swiper counsel smartparens popwin ;; --- Major Mode --- js2-mode markdown-mode ;; ... ;; 文件末尾 (provide &apos;init-packages) 下面为 ~/.emacs.d/init.el 入口文件中的代码 (package-initialize) (add-to-list &apos;load-path &quot;~/.emacs.d/lisp/&quot;) ;; Package Management ;; ----------------------------------------------------------------- (require &apos;init-packages) 模块化要做的其实非常简单，我们要做的其实就是把某一个更改编辑器某定部分（例如，插件管理，显示层，快捷键绑定等）的配置代码写入一个独立的文件中并在末尾为其添加(provide &#39;modul-name) (这里我们的模块名为 init-packages )使其可以在入口文件中被调用，然后再在入口文件中将其引用既可。 这里需要注意的是，我们需要在入口文件中添加 (add-to-list &#39;load-path &quot;~/.emacs.d/lisp/&quot;) 这可以让 Emacs 找到需要加载的模块所处的位置。 更多模块化的配置文件可以在这里找到。 Major 与 Minor Mode 详解在这一节我们将详细介绍 Major Mode 与 Minor Mode 去区别。每一个文件类型都对应一个Major Mode，它提供语法高亮以及缩进等基本的编辑支持功能，然后而 Minor Mode 则提供其余的增强性的功能（例如 linum-mode ）。 在 Emacs 中，Major Mode 又分为三种， text-mode ，用于编辑文本文件 special-mode ，特殊模式（很少见） prog-mode ，所有的编程语言的父模式 在每一个模式（mode）中它的名称与各个变量还有函数都是有特定的命名规则，比如所有的模式都被命名为 ModeName-mode ，里面所设置的快捷键则为 ModeName-mode-key-map，而所有的钩子则会被命名为 ModeName-mode-hook 。 注明：为了保持阅读的完整性，部分第三天的关于默认编辑器优化的内容被移至第四天。 第四天：配置文件模块化（下）以及使用优化视频地址如下 优酷视频 百度网盘 YouTube 配置文件模块化（下）在这一部分我们首先需要知道的是什么是 features 。在 Emacs 中每一个 feature 都是一个 Elisp 符号，用于代表一个 Lisp 插件（Package）。 当一个插件调用 (provide &#39;symbol_name) 函数时，Emacs 就会将这个符号加入到features 的列表中去。你可以在这里读到更多关于 feature 的内容。 接着我们需要弄明白的是 load-file , load , require , autoload 之间的区别。（他们之间区别的链接已经再前面贴过了，你也可以在这里找到之前同样的链接） 简单来说， load-file 用于打开某一个指定的文件，用于当你不想让 Emacs 来去决定加载某个配置文件时（ .el 或者 .elc 文件）。 load 搜索 load-path 中的路径并打开第一个所找到的匹配文件名的文件。此方法用于你预先不知道文件路径的时候。 require 加载还未被加载的插件。首先它会查看变量 features 中是否存在所要加载的符号如果不存在则使用上面提到的 load 将其载入。（有点类似于其他编程语言中的import ） autoload 用于仅在函数调用时加载文件，使用此方法可以大大节省编辑器的启动时间。 更好的默认设置在这一节我们会配置我们的编辑器使其有更好的使用体验。整个过程就如同搭积木一般，将更好的体验建立在已有的功能基础之上。这样的优化使整个过程变得更高效，也更有趣。 下面的代码可以是 Emacs 自动加载外部修改过的文件。 (global-auto-revert-mode 1) 使用下面的代码可以关闭自己生产的保存文件（之前我们已经关闭过了 Emacs 自动生产的备份文件了，现在是关闭自动保存文件）。 (setq auto-save-default nil) 如果你发现你在使用中发现了那些编辑行为与你预期的不相符时，你可以通过搜索引擎去寻找解决方案然后将其加入你的配置中并打造一个真正属于你的神器！ popwin 插件可以自动将光标移动到，新创建的窗口中。使用下面的代码将其启用， (require &apos;popwin) (popwin-mode 1) 也许你并不喜欢听到错误时的“哔哔”的警告提示音，使用下面的代码你可以关闭 Emacs 中的警告音， (setq ring-bell-function &apos;ignore) 每一次当 Emacs 需要与你确认某个命令时需要输入 (yes or no) 比较麻烦，所有我们可以使用下面的代码，设置一个别名将其简化为只输入 (y or n) 。 (fset &apos;yes-or-no-p &apos;y-or-n-p) 代码缩进indent-region 可以帮我们重新缩进所选区域的代码，但是每一次都选中十分麻烦。使用下面的代码可以一次重新缩进全部缓冲区的代码。（之后也会介绍更好用的，代码格式美化的插件） (defun indent-buffer() (interactive) (indent-region (point-min) (point-max))) (defun indent-region-or-buffer() (interactive) (save-excursion (if (region-active-p) (progn (indent-region (region-beginning) (region-end)) (message &quot;Indent selected region.&quot;)) (progn (indent-buffer) (message &quot;Indent buffer.&quot;))))) 然后再将其用下面的代码将其绑定为快捷键，第一个 \\ 用于将紧跟的 \\ 进行逃脱（escape）。 (global-set-key (kbd &quot;C-M-\\\\&quot;) &apos;indent-region-or-buffer) 缩写补全使用下面的代码我们可以开启 abbrev 模式并定义一个缩写表，每当我们输入下面的缩写并以空格结束时，Emacs 就会将其自动展开成为我们所需要的字符串。 (setq-default abbrev-mode t) (define-abbrev-table &apos;global-abbrev-table &apos;( ;; Shifu (&quot;8zl&quot; &quot;zilongshanren&quot;) ;; Tudi (&quot;8lxy&quot; &quot;lixinyang&quot;) )) 上面的缩写前使用的 8 也类似于命名空间的作用，使其不会与我们所常用的字符串冲突。 Hippie 补全Company 有时候补全功能并不是非常理想，这时就可以使用 Hippie Expand 来完成补全。Company Mode 补全效果不理想的原因是在不同的区域中会使用不同的后端函数来完成补全，但是当后端补全函数不能被激活时，则补全就不会被激活。 我们可以将下面的代码加入到我们的配置文件中，来增强 Hippie Expand 的功能， (setq hippie-expand-try-function-list &apos;(try-expand-debbrev try-expand-debbrev-all-buffers try-expand-debbrev-from-kill try-complete-file-name-partially try-complete-file-name try-expand-all-abbrevs try-expand-list try-expand-line try-complete-lisp-symbol-partially try-complete-lisp-symbol)) 然后将其绑定为快捷键，使我们可以更方便的使用它。 (global-set-key (kbd &quot;s-/&quot;) &apos;hippie-expand) Dired ModeDired Mode 是一个强大的模式它能让我们完成和文件管理相关的所有操作。 使用 C-x d 就可以进入 Dired Mode，这个模式类似于图形界面系统中的资源管理器。你可以在其中查看文件和目录的详细信息，对他们进行各种操作，甚至复制粘贴缓冲区中的内容。下面是一些常用的操作（下面的所有键均需在 Dired Mode 下使用）， + 创建目录 g 刷新目录 C 拷贝 D 删除 R 重命名 d 标记删除 u 取消标记 x 执行所有的标记 这里有几点可以优化的地方。第一是删除目录的时候 Emacs 会询问是否递归删除或拷贝，这也有些麻烦我们可以用下面的配置将其设定为默认递归删除目录（出于安全原因的考虑，也许你需要保持此行为。所有文中的配置请务必按需配置）。 (setq dired-recursive-deletes &apos;always) (setq dired-recursive-copies &apos;always) 第二是，每一次你进入一个回车进入一个新的目录中是，一个新的缓冲区就会被建立。这使得我们的缓冲区列表中充满了大量没有实际意义的记录。我们可以使用下面的代码，让Emacs 重用唯一的一个缓冲区作为 Dired Mode 显示专用缓冲区。 (put &apos;dired-find-alternate-file &apos;disabled nil) ;; 主动加载 Dired Mode ;; (require &apos;dired) ;; (defined-key dired-mode-map (kbd &quot;RET&quot;) &apos;dired-find-alternate-file) ;; 延迟加载 (with-eval-after-load &apos;dired (define-key dired-mode-map (kbd &quot;RET&quot;) &apos;dired-find-alternate-file)) 使用延迟加载可以使编辑器加载速度有所提升。 启用 dired-x 可以让每一次进入 Dired 模式时，使用新的快捷键 C-x C-j 就可以进入当前文件夹的所在的路径。 (require &apos;dired-x) 使用 (setq dired-dwin-target 1) 则可以使当一个窗口（frame）中存在两个分屏（window）时，将另一个分屏自动设置成拷贝地址的目标。 最后如果你是 Mac OS X 的用户，可以安装 reveal-in-osx-finder 这个插件（你可以在这里找到它），它可以将任意文件直接在 Finder 中打开。你想安装这个插件，将其添加至第二天的插件列表中即可，下次启动 Emacs 时，它就会自动帮你完成下载。 Org-mode 管理 Emacs 配置Org-mode 下的文学编程将颠覆你对于 Emacs 的看法。因为我们也可以使用 Org 来管理Emacs 的配置文件（笔者和他的师傅其实更倾向于模块管理配置文件）。 你需要将下面的代码放入配置入口文件（ init.el ）中， (package-initialize) (require &apos;org-install) (require &apos;ob-tangle) (org-babel-load-file (expand-file-name &quot;org-file-name.org&quot; user-emacs-directory)) 之后我们需要做的仅仅只是将所有的配置文件放入 Org 模式中的代码块即可，并使用目录结构来表述你的配置文件再把它保存在与入口文件相同的目录中即可（文件名为org-file-name.org ）。Emacs 会提取其中的配置并使其生效。这样做的好处是可以使自己和他人更直观的，理解你的配置文件或者代码。 第五天：打造前端开发神器视频地址如下 百度网盘 优酷 YouTube 照例我们先修复一些现在存在的小问题。首先是自动配对的小问题，在 Emacs Lisp 中我们有时候只需要一个 &#39; 但是 Emacs 很好心的帮我们做了补全，但这并不是我们需要的。我们可以通过下面的代码来让使 Emacs Lisp 在 Emacs 中的编辑变得更方便（可以将其添加至 init-default.el 配置文件中）。 (sp-local-pair &apos;emacs-lisp-mode &quot;&apos;&quot; nil :actions nil) (sp-local-pair &apos;lisp-interaction-mode &quot;&apos;&quot; nil :actions nil) ;; 也可以把上面两句合起来 (sp-local-pair &apos;(emacs-lisp-mode lisp-interaction-mode) &quot;&apos;&quot; nil :actions nil) 在添加配置代码后重启 Emacs 使其生效。当然这个方法你也可以运用在其他的各个 MajorMode 中，如果你不想 Emacs 对某些符号进行类似的自动匹配补全。 show-paren-mode 可以使鼠标在括号上是高亮其所匹配的另一半括号，然而我们想要光标在括号内时就高亮包含内容的两个括号，使用下面的代码就可以做到这一点。 (define-advice show-paren-function (:around (fn) fix-show-paren-function) &quot;Highlight enclosing parens.&quot; (cond ((looking-at-p &quot;\\\\s(&quot;) (funcall fn)) (t (save-excursion (ignore-errors (backward-up-list)) (funcall fn))))) Lisp 的宏（Macro）类似于 C++ 中的模板，并可以生产新的代码（你可以在这里找到更多关于宏的讨论）。使用它，我们可以增强某个函数的功能而不去更改这个函数的代码。 还有一个小问题就是解决在不同系统中的换行符，例如在 DOS 系统下的 \\r(^M) 换行符，这让我们有时候在 Unix 系统中很是头疼，因为它的存在会使版本控制误以为整行的代码都被修改过而造成不必要的麻烦。（你可以在这里找到更多关于 \\r(^M) 的信息） 我们用两种方式来处理这个问题，隐藏这个换行符或者将其删除。首先下面是隐藏的方法， (defun hidden-dos-eol () &quot;Do not show ^M in files containing mixed UNIX and DOS line endings.&quot; (interactive) (unless buffer-display-table (setq buffer-display-table (make-display-table))) (aset buffer-display-table ?\\^M [])) 使用下面的代码则可以定义函数将此换行符删除， (defun remove-dos-eol () &quot;Replace DOS eolns CR LF with Unix eolns CR&quot; (interactive) (goto-char (point-min)) (while (search-forward &quot;\\r&quot; nil t) (replace-match &quot;&quot;))) web-modeEmacs 自带的 HTML Mode 使用起来并不是那么的方便，而 web-mode 则是一个非常常用也很强大的用于编辑前端代码的 Major Mode（你可以在这里找到更多关于它的信息）。 首先我们需要安装它，照例我们需要将其添加至我们的插件列表中去。 (defvar xinyang/packages &apos;( ;; 你其他的插件在这里 web-mode ) &quot;Default packages&quot;) 在安装完成后我们就可以开始配置它了，首先我们需要做的是将所有的 *.html 文件都使用 web-mode 来打开。 (setq auto-mode-alist (append &apos;((&quot;\\\\.js\\\\&apos;&quot; . js2-mode)) &apos;((&quot;\\\\.html\\\\&apos;&quot; . web-mode)) auto-mode-alist)) 这样所有的 HTML 代码在 Emacs 中就会之间启用 web-mode 而非默认的 HTML Mode 了。你可以阅读它的文档来学习更多 web-mode 详细的使用方法。 例如使用 M-; 就可以注释当前行代码或选中行的代码。 接下来我们来做更多细节的配置，首先是缩减的大小的设置。因为 web-mode 支持在 HTML文件中存在多语言，所以我们可以对不同的语言的缩减做出设置。下面的代码用于设置初始的代码缩进， (defun my-web-mode-indent-setup () (setq web-mode-markup-indent-offset 2) ; web-mode, html tag in html file (setq web-mode-css-indent-offset 2) ; web-mode, css in html file (setq web-mode-code-indent-offset 2) ; web-mode, js code in html file ) (add-hook &apos;web-mode-hook &apos;my-web-mode-indent-setup) 下面的函数可以用于在两个空格和四个空格之间进行切换， (defun my-toggle-web-indent () (interactive) ;; web development (if (or (eq major-mode &apos;js-mode) (eq major-mode &apos;js2-mode)) (progn (setq js-indent-level (if (= js-indent-level 2) 4 2)) (setq js2-basic-offset (if (= js2-basic-offset 2) 4 2)))) (if (eq major-mode &apos;web-mode) (progn (setq web-mode-markup-indent-offset (if (= web-mode-markup-indent-offset 2) 4 2)) (setq web-mode-css-indent-offset (if (= web-mode-css-indent-offset 2) 4 2)) (setq web-mode-code-indent-offset (if (= web-mode-code-indent-offset 2) 4 2)))) (if (eq major-mode &apos;css-mode) (setq css-indent-offset (if (= css-indent-offset 2) 4 2))) (setq indent-tabs-mode nil)) (global-set-key (kbd &quot;C-c t i&quot;) &apos;my-toggle-web-indent) js2-refactorjs2-refactor 是一个用于重构 JavaScript 的插件，它是一个 Minor Mode，你可以在GitHub 找到更多关于这个插件的信息。 我们使用刚刚所提到的方法来安装 js2-refactor 插件。 在安装完成后，添加一个钩子（Hook）： (add-hook &apos;js2-mode-hook #&apos;js2-refactor-mode) (js2r-add-keybindings-with-prefix &quot;C-c C-m&quot;) 我们可以使用 C-c C-m 然后输入功能前缀，例如 em 是 extract-method 的前缀。更多的功能和使用方法也可以在上面给出的链接中找到，所有的前缀也可以在这里找到。 优化 occur 与 imenu下面的代码用于配置 Occur Mode 使其默认搜索当前被选中的或者在光标下的字符串： (defun occur-dwim () &quot;Call `occur&apos; with a sane default.&quot; (interactive) (push (if (region-active-p) (buffer-substring-no-properties (region-beginning) (region-end)) (let ((sym (thing-at-point &apos;symbol))) (when (stringp sym) (regexp-quote sym)))) regexp-history) (call-interactively &apos;occur)) (global-set-key (kbd &quot;M-s o&quot;) &apos;occur-dwim) dwim 是按我说的做的缩写（Do what I mean）。 Occur 可以用于显示变量或函数的定义，我们可以通过 popwin 的 customize-group 将定义显示设置为右边而不是默认的底部（ customize-group &gt; popwin &gt; Popup Window Position 设置为 right），也可以在这里对其宽度进行调节。 Occur 与普通的搜索模式不同的是，它可以使用 Occur-Edit Mode (在弹出的窗口中按 e进入编辑模式) 对搜索到的结果进行之间的编辑。 imenu 可以显示当前所有缓冲区的列表，下面的配置可以让其拥有更精确的跳转， (defun js2-imenu-make-index () (interactive) (save-excursion ;; (setq imenu-generic-expression &apos;((nil &quot;describe\\\\(\\&quot;\\\\(.+\\\\)\\&quot;&quot; 1))) (imenu--generic-function &apos;((&quot;describe&quot; &quot;\\\\s-*describe\\\\s-*(\\\\s-*[\\&quot;&apos;]\\\\(.+\\\\)[\\&quot;&apos;]\\\\s-*,.*&quot; 1) (&quot;it&quot; &quot;\\\\s-*it\\\\s-*(\\\\s-*[\\&quot;&apos;]\\\\(.+\\\\)[\\&quot;&apos;]\\\\s-*,.*&quot; 1) (&quot;test&quot; &quot;\\\\s-*test\\\\s-*(\\\\s-*[\\&quot;&apos;]\\\\(.+\\\\)[\\&quot;&apos;]\\\\s-*,.*&quot; 1) (&quot;before&quot; &quot;\\\\s-*before\\\\s-*(\\\\s-*[\\&quot;&apos;]\\\\(.+\\\\)[\\&quot;&apos;]\\\\s-*,.*&quot; 1) (&quot;after&quot; &quot;\\\\s-*after\\\\s-*(\\\\s-*[\\&quot;&apos;]\\\\(.+\\\\)[\\&quot;&apos;]\\\\s-*,.*&quot; 1) (&quot;Function&quot; &quot;function[ \\t]+\\\\([a-zA-Z0-9_$.]+\\\\)[ \\t]*(&quot; 1) (&quot;Function&quot; &quot;^[ \\t]*\\\\([a-zA-Z0-9_$.]+\\\\)[ \\t]*=[ \\t]*function[ \\t]*(&quot; 1) (&quot;Function&quot; &quot;^var[ \\t]*\\\\([a-zA-Z0-9_$.]+\\\\)[ \\t]*=[ \\t]*function[ \\t]*(&quot; 1) (&quot;Function&quot; &quot;^[ \\t]*\\\\([a-zA-Z0-9_$.]+\\\\)[ \\t]*()[ \\t]*{&quot; 1) (&quot;Function&quot; &quot;^[ \\t]*\\\\([a-zA-Z0-9_$.]+\\\\)[ \\t]*:[ \\t]*function[ \\t]*(&quot; 1) (&quot;Task&quot; &quot;[. \\t]task([ \\t]*[&apos;\\&quot;]\\\\([^&apos;\\&quot;]+\\\\)&quot; 1))))) (add-hook &apos;js2-mode-hook (lambda () (setq imenu-create-index-function &apos;js2-imenu-make-index))) (global-set-key (kbd &quot;M-s i&quot;) &apos;counsel-imenu) expand-region使用同样的方法将 expand-region 添加至我们的插件列表中，重启 Emacs 安装插件。 再为其绑定一个快捷键， (global-set-key (kbd &quot;C-=&quot;) &apos;er/expand-region) 使用这个插件可以使我们更方便的选中一个区域。（更多使用方法和文档可以在这里找到） ieditiedit 是一个可以同时编辑多个区域的插件，它类似 Sublime Text 中的多光标编辑。它的 GitHub 仓库在这里。 我们将其绑定快捷键以便更快捷的使用这个模式（ C-; 为默认快捷键）， (global-set-key (kbd &quot;M-s e&quot;) &apos;iedit-mode) 我们可以使用 Customized-group 来更改其高亮的背景色，将 highlight 改为 region 。 Org 导出使用 C-c C-e 可以将 Org-mode 文档导出为你需要的格式，例如 HTML 或者 PDF 文件。你现在看到的这本教程就是由 Org-mode 所导出生成的。 第六天：代码片段与语法检查器视频地址如下 百度网盘 优酷 YouTube 在开始前我们需要注意的是之前模块化的配置文件 init-keybindings.el 应该放在所有调用模块的最后面，因为也许在设置快捷键时某些函数还未被加载。 我们可以使用下面的配置来在 Company-mode 中使用 C-n 与 C-p 来选择补全项， (with-eval-after-load &apos;company (define-key company-active-map (kbd &quot;M-n&quot;) nil) (define-key company-active-map (kbd &quot;M-p&quot;) nil) (define-key company-active-map (kbd &quot;C-n&quot;) #&apos;company-select-next) (define-key company-active-map (kbd &quot;C-p&quot;) #&apos;company-select-previous)) Org-mode 进阶使用在学习代码片段和语法检查器（Linter）之前，我们先来学习一下如何使用 Org-mode 来做学习笔记和安排工作时间。我们用下面的配置代码来设置一个模板（其中设置了待办事项的优先级还有触发键）， (setq org-capture-templates &apos;((&quot;t&quot; &quot;Todo&quot; entry (file+headline &quot;~/.emacs.d/gtd.org&quot; &quot;工作安排&quot;) &quot;* TODO [#B] %?\\n %i\\n&quot; :empty-lines 1))) 我们也可以为其绑定一个快捷键， (global-set-key (kbd &quot;C-c r&quot;) &apos;org-capture) 这个功能除了可以记录待办事项还有其他许许多多的功能例如获取将当前浏览器中的URL（下面的例子只在 Mac OS X 平台有效）。 (defun YOUR_NAME/retrieve-chrome-current-tab-url() &quot;Get the URL of the active tab of the first window&quot; (interactive) (let ((result (do-applescript (concat &quot;set frontmostApplication to path to frontmost application\\n&quot; &quot;tell application \\&quot;Google Chrome\\&quot;\\n&quot; &quot; set theUrl to get URL of active tab of first window\\n&quot; &quot; set theResult to (get theUrl) \\n&quot; &quot;end tell\\n&quot; &quot;activate application (frontmostApplication as text)\\n&quot; &quot;set links to {}\\n&quot; &quot;copy theResult to the end of links\\n&quot; &quot;return links as string\\n&quot;)))) (format &quot;%s&quot; (s-chop-suffix &quot;\\&quot;&quot; (s-chop-prefix &quot;\\&quot;&quot; result))))) 更多有关 Org-capture 的内容可以在这里找到。 Org-pomodoro 是一个番茄时间工作法的插件（更多关于这个工作法的信息可以在这里找到）。它的 GitHub 地址在这里。在 (require &#39;org-pomodoro) 后可以通过 Customize-group来对其进行设置，包括不同休息种类的时长。 因为每次保存中文的时候都需要选择解码，我们可以使用下面的配置将文本解码设置默认为 UTF-8， (set-language-environment &quot;UTF-8&quot;) 当 org-mode 不能生效时，我们需要将与 Org 相关的配置放置于 with-eval-after-load 中， (with-eval-after-load &apos;org ;; Org 模式相关设定 ) 批量修改文件名C-x C-q 就可以直接在 Dired Mode 中进行编辑，使用之前学的 iedit-mode 和区域选择就可以直接对多个文件进行重命名编辑了。 搜索与替换全局搜索在我们的编辑工作中是不可缺少的，今天我们介绍的是 ag。它是非常快速的命令行搜索工具，它是 Linux 的所有搜索工具中最快的。 ag &gt; pt &gt; ack &gt; grep 在使用 ag 前我们需要进行安装，下面是 Mac OS X 与 Ubuntu 下的安装方法， # Mac OS X 通过 Homebrew 安装 brew install the_silver_searcher # Ubuntu 下安装 apt-get install silversearcher-ag # Windows 下通过 msys2 安装（确保在 path 中） pacman -S mingw-w64-i686-ag # 32 位电脑 pacman -S mingw-w64-x86_64-ag # 64 位电脑 安装好 ag 后我们就可以安装 helm-ag 插件了。（它的 GitHub 仓库地址在这里）在安装完成后可以为其设置快捷键， (global-set-key (kbd &quot;C-c p s&quot;) &apos;helm-do-ag-project-root) 使用这个插件我们同样可以在缓冲区对搜索到的结果进行直接的修改，这样就可以做到快速的搜索与替换。 语法检查器（Linter）语法检查器可以在开发动态语言（Interpreted/Dynamic Programming Language）时极大的提高你的开发效率，它会实时的检查你的代码并将句法错误（Syntax Error）与静态语义（Static Semantic Error）错误进行高亮与提示。 我们在这里使用的例子是 JavaScript 的语法检查器 eslint 它的安装方法可以在这里找到。 在安装好语法检查器后就可以安装 flycheck 的插件了，它的 GitHub 的地址在这里。 使用下面的代码可以将 flycheck-mode 在特定模式下激活（下面的例子就是只有在打开JavaScript 时才会激活语法检查器）， (add-hook &apos;js2-mode-hook &apos;flycheck-mode) 使用 flycheck-verify-setup 可以进行语法检查器的选择。 eslint 检查器的配置也可以使用项目目录下的 .eslintrc 来进行配置，更多配置方法可以在这里找到。 代码块yasnippet 是一个代码块补全的插件（GitHub 地址）。使用下面的配置文件将其在所有的编程语言的模式中激活。 (yas-reload-all) (add-hook &apos;prog-mode-hook #&apos;yas-minor-mode) 自定义代码块的方法可以在上面提供的链接中找到。 auto-yasnippetauto-yasnippet 也是一个非常好用代码块补全插件。安装并未其设置快捷键， (global-set-key (kbd &quot;H-w&quot;) #&apos;aya-create) (global-set-key (kbd &quot;H-y&quot;) #&apos;aya-expand) 简单的使用方法就是使用 ~ 来定义模板，然后调用 aya-create 再使用 aya-expand 来使用模板。 第七天：Evil 模式视频地址如下， 百度网盘 优酷 YouTube 开始之前我们先将 C-w 来使其可以向后删除一个单词，这样就可以与 Shell 中的快捷键操作同步。 (global-set-key (kbd &quot;C-w&quot;) &apos;backward-kill-word) 如果你不是 Vim 的用户，你可以选择跳过这一天的内容。但是我们强烈建议你花一些时间来学习基本的 Vim 操作，即使 Emacs 是你的最爱 Vim 的快捷键也在一定程度会增加你的编辑效率。基础的 Vim 操作可以在这里学会。 Evil 模式中的 State 就相当与 Vim 中的模式，常用的模式有下面几种（后面对于了相应的 Emacs 中的 State）， Normal Mode -&gt; Normal State Insert Mode -&gt; Insert State Visual Mode -&gt; Visual State Motion Mode -&gt; Motion State 还有一个 Emacs 中的特殊状态是 Emacs State。 Evil 的安装照例我们需要将 Evil 插件添加至我们的插件列表中来完成安装。在重启 Emacs 完成安装后可以添加下面的代码将其激活。 (evil-mode 1) 在激活 Evil 模式后就可以，在 Emacs 中使用 Vim 的快捷键了。有一点需要注意 C-u在 Emacs 中有特殊的功所（Universal args）以能我们可以通过使用 customize-group来对 Evil 模式进行修改，将 Evil Want C U Scroll 设置为开启。 下面的代码可以将 insert state map 中的快捷键清空，使其可以回退（Fallback）到Emacs State 中，这样我们之前的 Emacs State 里面定义的 C-w 等快捷键就不会被evil insert minor mode state 所覆盖， (setcdr evil-insert-state-map nil) (define-key evil-insert-state-map [escape] &apos;evil-normal-state) 这样你就可以使用 Evil 来在 Emacs 中完成百分之八十作用的快捷键操作了。 完整的 Evil Mode 的 PDF 版本的操作指南可以在这里找到，建议从 Vim 转 Emacs 的用户多次阅读来完整的掌握这个模式的使用方法。 Evil 模式插件 Leader Key在 Emacs 中使用 Leader Key 可以通过 evil-leader 来实现。你需要做的就是在安装后将其激活即可。 提示: 根据cofi/evil-leader 的说明，你应该在激活 evil-mode 之前就激活 global-evil-leader-mode，否则 evil-leader 在几个初始缓冲区(scratch, Message,&#x2026;)上将不生效。 (global-evil-leader-mode) Leader Key 可以通过 customize-group 来进行设置（Evil Leader/Leader）。因为之后我们会转移至 Spacemacs 所以我们可以将其设置为空格键 SPC 。 在通过下面的配置来设置简单的结合 Leader Key 快捷键组合（我们使用不同的键讲不同的功能分组，例如我们使用 f 键来做关于文件的操作，使用 b 键来做关于缓冲区（Buffer）的操作）， (evil-leader/set-key &quot;ff&quot; &apos;find-file &quot;bb&quot; &apos;switch-to-buffer &quot;0&quot; &apos;select-window-0 &quot;1&quot; &apos;select-window-1 &quot;2&quot; &apos;select-window-2 &quot;3&quot; &apos;select-window-3 &quot;w/&quot; &apos;split-window-right &quot;w-&quot; &apos;split-window-below &quot;:&quot; &apos;counsel-M-x &quot;wM&quot; &apos;delete-other-windows ) 注意上面窗口跳转相关的设置需要 window-numbering 安装后方可生效。 Window-numbering这个插件可以让我们快速的使用 Leader Key 与数字键的组合来在多个窗口之间进行跳转。它的 GitHub 地址可以在这里找到。 下载安装后通过下面的代码可以将其激活， (window-numbering-mode 1) Evil-SurroundEvil-surround 是一个 Vim 上非常常用的插件改写的，使用它可以快速的将选中区域进行匹配的操作，例如选中区域两边同时进行添加或修改括号，引号等操作。 下载安装后使用下面的代码将其激活， (require &apos;evil-surround) (global-evil-surround-mode) 简单的使用方法就是在选中所选区域后，使用 S( 来将选中区域包括在括号之中。如果想将括号改变成 &quot; 可以在选中后使用 cs(&quot; Evil-nerd-commenter这是一个快速添加与取消注释的插件，它的 GitHub 地址在这里。 使用下面代码可以将其激活， (evilnc-default-hotkeys) 使用下面的代码将其与 Evil 模式进行绑定，这里我们选择使用 ,/ 作为快捷键。 (define-key evil-normal-state-map (kbd &quot;,/&quot;) &apos;evilnc-comment-or-uncomment-lines) (define-key evil-visual-state-map (kbd &quot;,/&quot;) &apos;evilnc-comment-or-uncomment-lines) Which-keywhich-key 可以显示当前组合键下所有可以使用的全部组合键的选项。使用这个插件可以很好的解决快捷键太多的问题，我们无需在记忆任何快捷键，而是根据自己的需求使用不同分组的快捷键后再在其中去需找自己需要的功能。 在下载后可以使用下面的代码进行激活， (which-key-mode 1) Org Mode 中的搜索C-c a 中可以根据提示使用 s 来进行关键字所搜。使用 t 则可以进行代办事项的搜索。 第八天：Cask 介绍与实践视频地址如下: 百度网盘 优酷 YouTube 什么是 Cask: Cask 是一个 Emacs Lisp 的项目管理工具. Cask 的安装Cask 的地址: Cask 可以使用如下命令安装 Cask: curl -fsSL https://raw.githubusercontent.com/cask/cask/master/go | python 安装过程中 Cask 将会进行 Bootstrap, 安装一些包到~/.emacs.d 目录中. 安装完成之后需要将 Cask 的可执行文件目录加入到 PATH 中. 可以看到, Cask 的安装过程在 ~/.emacs.d 中新建了一个 .Cask 目录. 安装 Pallet: Pallet 是一个基于 Cask 的包管理工具, 可以使用 Emacs 的包安装方式安装. 然后使用以下代码启用 Pallet: (pallet-mode) (pallet-init) ; 在.emacs.d 中生成一个 Cask 文件, 写入源与现有包 (pallet-install) ; 将 elpa 中的 package 拷贝到.Cask/&lt;you version&gt;/elpa 目录中 然后在配置文件中加入以下代码(在其他包加载之前) : (require &apos;cask &quot;&lt;path-to-cask&gt;/cask.el&quot;) (cask-initialize) ; 类似于 package-initialize (require &apos;pallet) (pallet-mode t) ; 激活 pallet, 在安装包时将 Cask 文件写入相应信息 具体使用方式见文档: Pallet 为何使用 Cask 使用 Cask 文件保存包的信息, 可以通过 Cask install 自动安装 当有多个版本的 Emacs 时, 将各版本的包单独存放 故障排除 Emacs24.5 时不能安装 let-alist解决方案: 将 Gnu 的源加入源列表中, 示例代码如下(加入 Cask 文件) (source &quot;gnu&quot; &quot;http://elpa.zilongshanren.com/gnu/&quot;) 在 Emacs24.5 中没有定义 define-advicedefine-advice 是一个 Emacs25 中加入的宏, 在 Emacs24 中不能使用, 可以使用defadvice 代替: (defadvice show-paren-function (around fix-show-paren-function activate) (cond ((looking-at-p &quot;\\\\s(&quot;) ad-do-it) (t (save-excursion (ignore-errors (backward-up-list)) ad-do-it))) ) 而且使用 defadvice 相比 define-advice 还有一个优点: 使用 define-advice 定义的代码, 当在 Normal 模式时光标两边的括号不会高亮, 而使用defadvice 可以. 第九天：Macro 与 Use-package视频地址如下: 百度网盘 优酷 YouTube 这次主要介绍 Emacs Lisp 中的宏(Macro)以及 Use-package 插件. Macro 什么是 Macro宏是一种可以生成代码的代码. 类比与 C 语言中的宏以及 C++中的模板. 先看一个简单的例子: (defmacro inc (var) (list &apos;setq var (list &apos;1+ var))) (setq my-var 1) (setq my-var (+ 1 my-var)) (macroexpand &apos;(inc my-var)) 以上这个宏的作用是将变量的值+1. 执行以上代码之后, my-var 的结果为 2. 可以使用 macroexpand 获得宏展开的结果, 如以上代码结果为: (setq my-var (1+ my-var)) 我们也可以使用函数来实现相同的功能, 但 Macro 与函数有以下两个区别: 宏的参数并不会被马上求值, 解释器会先展开宏, 宏展开之后解释器才会执行宏展开的结果; 而函数的参数会马上求值 宏的执行结果是一个表达式, 该表达式会立即被解释器执行; 而函数的结果是一个值 backquotebackquote 是指反引号(`), 即键盘上数字 1 左边的键. 当在 Emacs 输入 backquote 时会插入两个反引号, 可以使用以下代码关闭这个功能: (sp-local-pair &apos;emacs-lisp-mode &quot;`&quot; nil :actions nil) 先看以下例子来体会 backquote 的作用: (defun my-print (number) (message &quot;This is a number: %d&quot; number)) (my-print 2) ; 1. output= This is a number: 2 (my-print (+ 2 3)) ; 2. output= This is a number: 5 (quote (+ 1 1)) ;; return a list= (+ 1 1) (defmacro my-print-2 (number) `(message &quot;This is a number: %d&quot; ,number)) (my-print-2 2) ; 3. output= This is a number: 2 (my-print-2 (+ 2 3)) ; 4. output= This is a number: 5 (setq my-var 2) (inc my-var) (defmacro inc2 (var1 var2) (list &apos;progn (list &apos;inc var1) (list &apos;inc var2))) (macroexpand &apos;(inc2 my-var my-var)) (macroexpand-all &apos;(inc2 my-var my-var)) quote 的作用是返回后面的表达式, 不对表达式进行求值. 所以以下代码: (quote (+ 1 1)) ;; return a list= (+ 1 1) 并没有对表达式 (+ 1 1) 进行求值返回 2, 而是返回一个 list. backquote 的作用与 quote 相似, 同样不对后面的表达式求值, 但是当 backquote 在宏中与逗号(,)一起使用时, 用逗号修饰的变量将进行求值. 例如以下代码: (defmacro my-print-2 (number) `(message &quot;This is a number: %d&quot; ,number)) (pp (macroexpand &apos;(my-print-2 (+ 2 3)))) (my-print-2 (+ 2 3)) 当输出 message 且 number 不带逗号时, my-print-2 的执行将提示错误. 因为宏不对参数进行求值, 所以以上宏展开相当于: (message &quot;This is a number:&quot; number) 因为我们没有定义 number 变量, 所以执行出错. 而如果加入逗号, 则在宏展开时会对变量 number 进行求值, 展开结果为: (message &quot;This is a number: %d&quot; (+ 2 3)) 在调试宏的过程中, 可以使用 macroexpand 和 macroexpand-all 获取宏展开的结果. 关于 backquote 的更多讨论, 可以见以下地址: lisp 中的`与，是怎么用的？ 为什么使用宏使用宏可以减少重复的代码, 以下是一个使用宏来定义函数的例子: (defun prelude-search (query-url prompt) &quot;Open the search url constructed with the QUERY-URL. PROMPT sets the `read-string prompt.&quot; (browse-url (concat query-url (url-hexify-string (if mark-active (buffer-substring (region-beginning) (region-end)) (read-string prompt)))))) (defmacro prelude-install-search-engine (search-engine-name search-engine-url search-engine-prompt) ; #1 &quot;Given some information regarding a search engine, install the interactive command to search through them&quot; `(defun ,(intern (format &quot;prelude-%s&quot; search-engine-name)) () ; #2 ,(format &quot;Search %s with a query or region if any.&quot; search-engine-name) ; #3 (interactive) (prelude-search ,search-engine-url ,search-engine-prompt))) ; #4 (prelude-install-search-engine &quot;google&quot; &quot;http://www.google.com/search?q=&quot; &quot;Google: &quot;) ; #5 (prelude-install-search-engine &quot;youtube&quot; &quot;http://www.youtube.com/results?search_query=&quot; &quot;Search YouTube: &quot;) (prelude-install-search-engine &quot;github&quot; &quot;https://github.com/search?q=&quot; &quot;Search GitHub: &quot;) (prelude-install-search-engine &quot;duckduckgo&quot; &quot;https://duckduckgo.com/?t=lm&amp;q=&quot; &quot;Search DuckDuckGo: &quot;) 下面对以上代码进行讲解: 第#1 行, 通过 prelude-install-search-engine 定义了一个需要 3 个参数的宏, 这个宏的作用是生成一个函数. 第#2 行, 通过 intern 生成一个符号作为函数名, 名称为 *prelude-xxx* , 其中 xxx为第一个参数的值. 第#3 行, 生成了这个函数的描述. 第#4 行, 调用 prelude-search 函数进行搜索处理. 第#5 行, 调用这个宏定义了一个名为 *prelude-google* 的函数. 从以上代码可以知道, 我们利用宏生成了４个名称不同的函数, 避免了手动编写函数的问题(因为这４个函数的代码非常相似, 根据 DRY 原则应该尽量避免做这种重复工作). 关于宏的更多内容, 可以阅读 Paul Graham 的著作 《On Lisp》 prelude-duckduckgo Use-package 简介Use-package 是一个宏, 它能让你将一个包的 require 和它的相关的初始化等配置组织在一起, 避免对同一个包的配置代码散落在不同的文件中. Use-package 的更多信息参见以下地址: Use-package 一些简单的用法 更安全的 require 在 Emacs 中, 当我们要引入一个包时, 通常会使用以下代码: (require &apos;package-name) 但是当 package-name 不在 load-path 中时, 以上代码会抛出错误. 使用Use-package 可以避免: (use-package package-name) 以上代码展开的结果如下: (if (not (require &apos;package-name nil &apos;t)) (ignore (message (format &quot;Cannot load %s&quot; &apos;package-name)))) 可以看到, Use-package 使用 ignore 来避免抛出错误, 这样当某个包不存在时,eamcs 也能够正常启动. 将配置集中 当我们引入某个包时, 有可能需要定义一些与这个包相关的变量, 使用 Use-package 实现这个需求如下: (use-package package-name :init (setq my-var1 &quot;xxx&quot;) :config (progn (setq my-var2 &quot;xxx&quot;) (setq my-var3 &quot;xxx&quot;) ) ) 在上例中, init 后的代码在包的 require 之前执行, 如果这段代码出错则跳过包的 require. config 后的代码在包的 require 之后执行. init 与 config 之后只能接单个表达式语句, 如果需要执行多个语句, 可以用 progn . autoload 使用 require 时会引入这个包, 但是当你的包很多时会影响启动速度. 而使用 autoload则可以在真正需要这个包时再 require, 提高启动速度, 避免无谓的 require. 使用 Use-package 可以轻松的实现这个功能: (use-package package-name :commands (global-company-mode) :defer t ) 使用 commands 可以让 package 延迟加载, 如以上代码会首先判断 package 的符号是否存在, 如果存在则在 package-name 的路径下加载. defer 也可以让 package-name进行延迟加载. 键绑定 在之前的代码中, 如果我们需要绑定一个键, 需要使用 global-key-bind 或define-key 实现, 而使用*Use-package* 实现更简单: (use-package color-moccur :commands (isearch-moccur isearch-all) :bind ((&quot;M-s O&quot; . moccur) :map isearch-mode-map (&quot;M-o&quot; . isearch-moccur) (&quot;M-O&quot; . isearch-moccur-all)) :init (setq isearch-lazy-highlight t) :config (use-package moccur-edit)) 为什么使用 Use-package Use-package 能让相关的配置更为集中, 避免配置分散带来的维护困难 Use-package 有完善的错误处理, 使配置代码更为健壮 Spacemacs 也大量使用了 Use-package 第十天: Company-mode 与 auto-completion视频地址如下: 百度网盘 优酷 YouTube 内容概要: 给出 Cask 和 Use-package 的简单示例 详细介绍 Company-mode 的工作原理, 各种 backend 及其用法 扩展阅读: 编写一个简单的 comopany backend Company Mode Emacs wiki 升级 Package 之后有 BUG 怎么办有些时候我们将一个 Package 升级到最新的版本(例如 github 上最新的 commit), 而该版本可能会存在一些 BUG, 这就会导致我们的配置不能使用. 如果我们使用 stable 版本的 Package(例如使用 github 上最新的 release), 就可以尽量地减少因为升级包之后的 BUG 导致配置不可用的情况. 另一种解决方式是使用 Cask 进行包管理, 举例如下: 首先我们添加一个包, 例如我们编辑 Cask 文件, 添加 monokai-theme : (depends-on &quot;monokai-theme&quot; :git &quot;https://github.com/oneKelvinSmith/monokai-emacs/releases&quot; :ref &quot;02c5f5d&quot;) 然后启动 emacs, 但是出现了 BUG.这时我们可以直接将 ref 的值修改为最新的 commit, Cask 即会更新这个包, 而不用等待 melpa 对包进行更新. Use-package 的更多用法如果我们启用 exec-path-from-shell , 在 emacs 启动时可能会提示 PATH 变量重复定义, 解决方案如下: (use-package exec-path-from-shell :ensure t :if (and (eq system-type &apos;darwin) (display-graphic-p)) :config (progn (when (string-match-p &quot;/zsh$&quot; (getenv &quot;SHELL&quot;)) ;; Use a non-interactive login shell. A login shell, because my ;; environment variables are mostly set in `.zprofile&apos;. (setq exec-path-from-shell-arguments &apos;(&quot;-l&quot;))) (exec-path-from-shell-initialize) ) ) ;; (use-package monokai-theme ;; :ensure t) 其中 if 子句可以确定启用 Package 的条件, 在 config 子句中向 exec-path-from-shell-arguments 即可消除这个警告. ensure 子句来确保 Package 被安装. 如果要使用 stable 版, 则添加以下子句: :pin melpa-stable Company-mode 的工作原理Company-mode 需要配合后端使用, 所有的 backend 都保存在 company-backends 这个变量中, 例如在我的环境中该变量值如下: (company-capf (company-dabbrev-code company-gtags company-etags company-keywords) company-files company-dabbrev ) *company-backends*变量的值是一个列表, 其中的每一项都是一个后端或 Group Backend. Company-mode 会依次调用该变量中的 backend, 并判断该 backend 是否合适当前 Buffer, 直到找到一个合适的补全后端. 在进行补全项选择的时候, 我们也可以在 mode-line 中看到是使用的哪一个后端. company-dabbrev: 将当前打开的所有 buffer 中的关键字作为补全显示(默认不使用 scratch buffer). company-files: 补全路径. 如果在补全过程中取消了补全, 也可以使用命令再次开启补全. 例如 company-files 补全方式就可以使用 company-files 函数开启. 在输入英文时可以使用 company-ispell 进行输入提示. 为什么有时 Python 的补全 不工作有时在编写 Python 代码的时候补全不能工作, 这时我们可以先查看 company-backends 的值, 查看是否需要安装 company-anaconda 用于补全. 在 Mac 系统中, 如果 anaconda-mode 的安装过程出现错误, 可以参照以下解决方案: Mac 上面编辑 python 的时候安装 anaconda-mode 出错 然后确保在 company-backends 中有 company-anaconda 这个后端即可. 可以使用如下代码: (add-hook &apos;python-mode-hook (lambda () (set (make-local-variable &apos;company-backends) &apos;(company-anaconda)))) 以上代码在 python-mode 被激活时设置 company-backends 的变量值为 (company-anaconda), 则在编辑 python 代码时就可以使用 anaconda-mode 进行补全. 在 emacs 中有两种补全方式: 如 company-files 等, 根据关键字等进行补全, 只需要 emacs 自己进行一些处理即可得到补全数据; 如 company-anaconda 等, 需要使用客户端-服务端模式, 补全后端需要服务端的配合才能得到补全数据. 在进行编程时, 一般使用第二种补全后端, 例如 编写 python 代码使用 company-anaconda, 编写 C/C++代码使用 company-ycmd, 编写 javascript 代码使用 company-tern. 上述示例代码开启 company-anaconda 时有一个缺点, 比如当我们在 python 的注释时没法使用补全, 因为补全后端只有 company-anaconda, 在注释时不工作. 我们可以将 dabbrev 加入后端列表: (add-hook &apos;python-mode-hook (lambda () (set (make-local-variable &apos;company-backends) &apos;(company-anaconda company-dabbrev)))) 当 company-anaconda 不合适时使用 company-dabbrev 进行补全, 即可满足上述需求. Group Backendcompany-dabbrev-code: 类似于 company-dabbrev, 但是 dabbrev 对代码和注释都进行补全, dabbrev-code 只补全代码. 假设我们的配置代码如下: (add-hook &apos;python-mode-hook (lambda () (set (make-local-variable &apos;company-backends) &apos;((company-anaconda company-dabbrev-code) company-dabbrev))) ) 如果我们在注释中出现了 xxx 这个字符串, 在编写 python 代码时 xxx 不会出现在补全选项中. 因为在此时会先匹配到 company-anaconda, 并不会进入 company-dabbrev.而因为 company-anaconda 是一个 Group Backend, 所以 company-dabbrev-code 的补全数据会出现在补全列表中. 怎样写一个简单的补全后端因为视频时间关系, 大家可以去阅读以下文章: Writing the Simplest Emacs company-mode Backend 实现方式简单介绍如下: 定义一个补全数据列表 定义一个补全函数, 返回对应输入的补全数据 更多的内容可以查看该文档, 同时在网页右侧的链接中有更多的详细内容. 第十一天: Spacemacs 简介及安装视频地址如下: 百度网盘 优酷 Youtube 从今天的内容开始介绍 Spacemacs. 地址: Spacemacs 今天的内容包括: 如何安装 Spacemacs 一些简单的配置, 以及 package 管理 管理自己的配置 安装 Spacemacs安装 Spacemacs 非常简单, 只需要将 github 上的仓库克隆即可, 即执行以下命令(如有必要可以先备份以前的配置): cd ~ mv .emacs.d .emacs.d.bak mv .emacs .emacs.bak git clone https://github.com/syl20bnr/spacemacs ~/.emacs.d 在克隆完成后直接运行 Emacs.在第一次使用 Spacemacs 时需要下载一些 Package, 然后在 Bootstrap 完成之后你需要进行如下一些配置: 使用哪种编辑方式, 包括 vim 方式(默认) 以及 emacs 方式. 使用哪种 Spacemacs distribution. 包括标准版(默认)以及基础版. 区别在于标准版包含非常多的功能, 而基础版只包含核心功能. 在完成以上两个配置之后, 就会在 HOME 目录生成一个 ~/.spacemacs 配置文件.然后 Spacemacs 会进行进一步的初始化, 下载更多的需要的 Package.如果你需要使用 emacs-china 的配置源, 此时可以终止 emacs, 然后在~/.spacemacs 中的 dotspacemacs/user-init 函数中加入以下代码: (setq configuration-layer--elpa-archives &apos;((&quot;melpa-cn&quot; . &quot;http://elpa.zilongshanren.com/melpa/&quot;) (&quot;org-cn&quot; . &quot;http://elpa.zilongshanren.com/org/&quot;) (&quot;gnu-cn&quot; . &quot;http://elpa.zilongshanren.com/gnu/&quot;))) 重新启动 emacs, 等待 Spacemacs 完成安装即可. 如果你需要更方便的管理你自己的配置, 可以创建 ~/.spacemacs.d 目录, 然后将 ~/.spacemacs 文件移动到该目录中并重命名为 init.el. 在 Spacemacs 中的操作方式如下: 按下 SPC f j 打开 dired 目录 按下按键 + , 创建 ~/.spacemacs.d 目录 将光标移动到 .spacemacs 文件上, 按下 R, 将该文件移动到 .spacemacs.d 目录中 进入 .spacemacs.d 目录, 将光标移动到 .spacemacs 文件上, 按下 R, 将该文件重命名为 init.el 按下 qq 退出 dired 然后启动 emacs 即可. 使用这种方式管理配置, 你可以将自己的配置集中到 ~/.spacemacs.d 目录中, 更容易进行统一管理. 你也可以将自己的配置 push 到 github 上. 添加内置的 layer在安装完成 Spacemacs 之后, 按下 SPC f e d 打开 ~/.spacemacs 文件, 修改 dotspacemacs-configuration-layers 变量的值,将 auto-completion, better-defaults, emacs-lisp, git, markdown, org, spell-checking, syntax-checking 等 layer 加入列表. 然后退出 emacs 再重启, 或者按下 SPC f e R 安装需要的 package. 一些简单的配置 启动时全屏显示在 dotspacemacs/init 函数中, 将 dotspacemacs-fullscreen-at-startup 变量设置为 t 即可. 代码如下: ;; If non nil the frame is maximized when Emacs starts up. ;; Takes effect only if `dotspacemacs-fullscreen-at-startup&apos; is nil. ;; (default nil) (Emacs 24.4+ only) dotspacemacs-maximized-at-startup t ivy layer将 ivy 加入 dotspacemacs-configuration-layers 列表中. 按下 CTRL s 使用 swiper 可以进行搜索. 查看 layer 下的 文档信息按下 SPC h SPC 即会弹出一个信息窗口, 可以从窗口中选择具体的 layer 或者其他信息进行查看. 删除安装的 package只需要将需要删除的 package 名称加入到 dotspacemacs-excluded-packages 变量中, 在下一次启动 emacs 时即会删除该 package.示例代码如下: ;; A list of packages and/or extensions that will not be install and loaded. dotspacemacs-excluded-packages &apos;(vi-tilde-fringe) 安装 package在 Spacemacs 中安装 package 时最好不要使用 package-install, 因为这样安装的 package 会在下一次启动时被删除. Spacemacs 提供了一个方式, 你只需将需要安装的 package 加入到 dotspacemacs-additional-package 变量中即可,示例代码如下: ;; List of additional packages that will be installed without being ;; wrapped in a layer. If you need some configuration for these ;; packages, then consider creating a layer. You can also put the ;; configuration in `dotspacemacs/user-config&apos;. dotspacemacs-additional-packages &apos;(youdao-dictionary) 配置 customize-group如果使用 customize-group 对配置进行了修改, 你可以以下代码将生成的 custom.el 配置文件纳入 ~/.spacemacs.d 目录中进行统一管理: (setq custom-file (expand-file-name &quot;custom.el&quot; dotspacemacs-directory)) (load custom-file &apos;no-error &apos;no-message) 修改主题只需修改 dotspacemacs-themes 变量的值, 将主题加入列表即可. 在列表中靠前的主题会优先使用.示例代码如下: ;; List of themes, the first of the list is loaded when spacemacs starts. ;; Press &lt;SPC&gt; T n to cycle to the next theme in the list (works great ;; with 2 themes variants, one dark and one light) dotspacemacs-themes &apos;( monokai ;; spacemacs-dark ;; spacemacs-light ;; solarized-light solarized-dark ;; leuven ;; monokai ;; zenburn ) 第十二天: 创建你的第一个 Spacemacs Layer视频地址如下: 百度网盘 优酷 YouTube 主要内容: 如何更新 Spacemacs, 同步官方 develop 分支及注意事项 Layer 的 variables 变量及使用方法 如何创建自己的 Layer 如何定制 modeline evlified state 如何更新 Spacemacs可以通过 git 的方式来更新代码, 假设我们使用的是 develop 分支: git checkout develop git fetch upstream git merge upstream/develop 一般来说, 如果你不熟悉 emacs 并且你的 Spacemacs 配置能够正常工作, 则不需要频繁的更新代码, 以避免更新之后配置不能使用. variables 变量每一个 layer 都可以配置一些变量, 可以通过 SPC h SPC 然后输入 layer 名称, 点击对应的选项即可打开该 layer 的 README.org 文件.然后按下 SPC f j 进入 dired 模式, 选择 config.el 文件打开, 该文件中即定义了该 layer 的变量. 例如 better-default layer 的变量如下: (defvar better-defaults-move-to-beginning-of-code-first t &quot;when t, first stroke of C-a will move the cursor to the beginning of code. When nil, first stroke will go to the beginning of line. Subsequent strokes will toggle between beginning of line and beginning of code.&quot;) (defvar better-defaults-move-to-end-of-code-first nil &quot;when t, first stroke of C-e will move the cursor to the end of code (before comments). When nil, first stroke will go to the end of line (after comments). Subsequent strokes will toggle between end of line and end of code.&quot;) 要配置使用这些变量, 可以在启用 layer 时使用如下的代码: (better-defaults :variables better-defaults-move-to-end-of-code-first t) 定制 modeline在 emacs25.1 中, 该版本的 modeline 和以前版本不同, 可以通过如下方式将 modeline 修改为以前的显示形状: 在 dotspacemacs/user-config 中加入如下代码: (setq ns-use-srgb-colorspace nil) 创建自己的 layer假设我们需要创建一个 layer, 名叫 zilongshanren, 并且在 layer 下包含一个名叫 youdao-dictionary 的 package. 首先利用 spacemacs 提供的函数创建 layer. 按下 M-x 并且输入 configuration-layer/create-layer, 然后选择路径 ~/.spacemacs.d,确定创建 README, 然后我们就可以看到 layer 创建成功. 每一个 layer 的结构如下: [layer_name] |__ [local] | |__ [package 1] | | ... | |__ [package n] |-- layers.el |__ packages.el |__ funcs.el |__ config.el |__ keybindings.el [] = directory 即每一个 layer 目录下都可以包含 layers.el, packages.el 等文件, 以及一个名叫 local 的目录. 每一个文件的内容描述如下: 文件名用处layers.el申明一些额外的 layer 依赖packages.el一些 layer 使用到的 package 以及相关配置函数funcs.el定义一些 layer 层次的函数, 即全局函数config.ellayer 的配置, 此处定义的配置可以在 .spacemacs 中申明 layer 时进行配置, 也可以定义 emacs 的默认配置keybindings.el快捷键配置 现在我们可以把 youdao-dictionary 加入到 layer 中, 编辑 packages.el: ;; 添加 package (defconst zilongshanren-packages &apos;(youdao-dictionary) ) ;; 初始化 package ;; 可以使用 , d m 快捷键, 然后按下 e 展开宏 (defun zilongshanren/init-youdao-dictionary () (use-package youdao-dictionary :defer t :init (spacemacs/set-leader-keys &quot;oy&quot; &apos;youdao-dictionary-search-at-point+) ) ) 编辑 config.el 文件: ;; 开启行号显示 (global-linum-mode t) ;; 定义快捷键 (global-set-key (kbd &quot;M-s o&quot;) &apos;occur-dwim) ;; 将 occur 的 buffer 中的光标移动方式修改为 HJKL (evilified-state-evilify-map occur-mode-map :mode occur-mode) 编辑 keybindings.el 文件: ;; dwin = do what i mean. (defun occur-dwim () &quot;Call `occur&apos; with a sane default.&quot; (interactive) (push (if (region-active-p) (buffer-substring-no-properties (region-beginning) (region-end)) (let ((sym (thing-at-point &apos;symbol))) (when (stringp sym) (regexp-quote sym)))) regexp-history) (call-interactively &apos;occur)) 然后将 zilongshanren 加到 dotspacemacs-configuration-layers 变量中, 即可让 layer 配置生效. 文档spacemacs 的文档保存在 doc 目录下, 包含有 CONVENTIONS.org, DOCUMENTATION.org 等文档文件, 建议大家多多阅读. 第十三天: 定制你的 Layer视频地址如下: 百度网盘 优酷 Youtube 主要内容: 修复上一期视频中 occur-mode 启动的问题 修复 ivy0.8 导致的问题, 同时简单探讨了一下今后如何避免和处理类似的问题 介绍 post-init 和 pre-init 的用法, 介绍了如何定制 spacemacs 的 company-mode 介绍 layers.el 文件, 演示该文件的作用 介绍 layer 的 package 的 location 变量, 演示了如何从 github 获取并安装 package 的方法 修复上一期视频中的配置问题在之前的配置代码中, 如果我们启动 emacs 会出现以下错误: Symbol&apos;s function definition is void: evilified-state-evilify-map 这是因为这个符号在 config.el 中使用的时候还是空的, 我们可以通过以下方式修复, 编辑 config.el 文件, 将以下代码移动到 dotspacemacs/user-config 函数中: (evilified-state-evilify-map occur-mode-map :mode occur-mode) 修复 ivy0.8 的问题在 ivy 升级到0.8版本时, 对其中一个API的返回值进行了修改: (let (res) (ivy-with &apos;(ivy-read &quot;test: &quot; &apos;((&quot;one&quot; . 1) (&quot;three&quot; . 3)) :action (lambda (x) (setq res x))) &quot;t C-m&quot;) res) ;; =&gt; ;; (&quot;three&quot; . 3) 在之前的版本中, 这个函数的返回值是 3, 在0.8版本中被修改为了一个列表. 如果要修复这个问题, 我们需要在使用返回值的时候加上 cdr, 具体的修改可以查看fix break API changes for ivy 0.8. post-init 和 pre-init有一些 mode 已经安装, 例如 company-mode 已经被 auto-completion layer 安装, 如果这时我们还想对该 mode 进行一些定制, 那么我们可以这样处理: 在我们的 layer 中添加这个包 ;; 添加 package(defconst zilongshanren-packages ‘(youdao-dictionary company ; 添加 company package ) ) 然后定义一个 post-init 函数 ;; 定制 company-mode(defun zilongshanren/post-init-company () (setq company-minimum-prefix-length 1) ) 然后重启 emacs 即可以看到定制的效果. 对于 package 的三个函数: pre-init, init, post-init, spacemacs是按照这个顺序来依次调用的. location在安装 package 时, 我们如果只输入 package 的名字, 那么默认是从 melpa 下载安装的. 如果我们想自定义 package 的安装地址, 那么我们就可以使用 location 变量. 自带 package例如我们使用一个自带的 occur package: ;; 自定义 package 安装地址 (defconst zilongshanren-packages &apos;(youdao-dictionary (occur-mode :location built-in) ) ) ;; 初始化 occur mode (defun zilongshanren/init-occur-mode () (evilified-state-evilify-map occur-mode-map :mode occur-mmode) ) 从 github 安装例如我们从 github 安装 gulpjs package: ;; 自定义 package 安装地址 (defconst zilongshanren-packages &apos;(youdao-dictionary (occur-mode :location built-in) (gulpjs :location (recipe :fetcher github :repo &quot;zilongshanren/emacs-gulpjs&quot;)) ) ) (defun zilongshanren/init-gulpjs () (use-package gulpjs :init) ) 在 emacs 启动时就会从 github 上下载 guiljs package 并安装到本地. layers.el如果我们需要对某些 layer 中的 package 配置进行大量的重写, 那么我们可以移除这个 layer 的某个 package. 我们可以通过 layers.el 来实现这一点, 例如移除 chinese layer 的 youdao-dictionary package: (configuration-layer/remove-layer &apos;youdao-dictionary) 然后我们可以在自己的 layer 中添加这个 package, 然后对它进行定制.在这种情况下, spacemacs 不会在 chinese layer 中加载 youdao-dictionary 这个 package, 而是在我们的 layer 中加载这个 package, 以实现对 spacemacs 内置的package 的定制. 第十四天: 文件和 Buffer 操作视频地址如下: 百度网盘 优酷 Youtube 主要内容: 我的配置和 spacemacs配置的一些不同点 文件相关操作 Buffer 相关操作 Dired 不同点从今天的视频开始, 将使用 子龙山人的配置 来讲解视频. 这份配置对 spacemacs 的定制有两个不同点: 没有使用官方的 modeline, 而是采用自己定制的 排除掉了大量的作者认为对他没有作用的 package, 因为这些 package 确实不经常使用, 反而可能导致一些 BUG 或者导致 spacemacs 启动或使用过程中变慢 文件相关操作 SPC p f 在当前的项目中查找文件, 类似于 vim 中的 Ctrl-p. 在作者的配置中, 该快捷键被绑定到了以下函数: (defun zilongshanren/open-file-with-projectile-or-counsel-git () (interactive) (if (zilongshanren/vcs-project-root) (counsel-git) (if (projectile-project-p) (projectile-find-file) (ido-find-file)))) 该函数会针对不同的项目类型使用不同的查找方式: 如果是 git 项目, 那么使用 counsel-git 来查找文件, 不使用 projectile 的原因是 counsel-git 更快 如果是 projectile 项目, 即在项目的根目录中存在 .projectile 文件, 那么使用 projectile-find-file 来查找文件 否则使用 ido-fine-file 来查找文件 SPC f f 从当前目录开始查找文件. 在作者的配置中同时启用了 ivy-layer 和 helm-layer, 默认使用的是 helm 来查找文件. SPC f L 使用 helm-locate 来在当前系统中查找文件. SPC f l 查找文件并使用 literal 的方式来打开文件, 使用 literal 方式打开的文件不会附加编码信息, 例如 utf-8 编码中可能存在的 BOM 头信息, 使用 literal 模式即可以看到 BOM头. SPC f h 查找文件并使用二进制的方式来打开文件, 可以使用 C-c C-c 回到之前的模式. SPC f o 使用外部程序打开文件. SPC f E 使用 sudo 来编辑文件, 当某些文件是只读的时候可以采用这种方式来编辑文件. SPC f D 删除当前的文件和 buffer. SPC f j 以当前文件的目录打开 dired buffer. SPC f r 使用 ivy 打开最近文件列表. SPC f R 重命名当前文件. SPC f v 添加 local variables, 可以通过这个功能给项目做一些特殊的设置.例如按下 SPC f v, 然后选择 add-dir-local-variable, 选择 org-mode, 再选择org-highlight-links 变量, 此时 emacs 会在当前文件的目录下生成一个 .dir-locals.el 文件, 内容如下: ;;; Directory Local Variables ;;; For more information see (info &quot;(emacs) Directory Variables&quot;) ((org-mode (org-highlight-links))) 这个文件中的代码会在当前目录下的所有文件 buffer 中生效. SPC f y 拷贝当前文件的全路径. SPC f a d 列出最近访问的目录, 使用命令行工具 fasd 实现. SPC f C d/u 将当前文件的编码转换为 DOS/UNIX 编码. SPC f e d 打开 .spacemacs 或 .spacemacs.d/init.el 文件. SPC f e i 打开 .emacs 或 .emacs.d/init.el 文件. SPC f e l 打开系统中已经安装的 el 文件. SPC f c 复制文件. SPC f b 打开标签. SPC f s/S 保存当前 buffer 或 所有 buffer. buffer 相关操作 SPC b . 打开 Buffer Selection Transient State, 在该模式下可以进行更多的操作, 由 hydra 提供. SPC b b 切换到已经打开的 buffer. SPC b d 关闭一个 buffer. SPC b f 在 finder 中打开当前文件, 只在 Mac系统下生效. SPC b B/i 以类似 Dired Mode 的形式打开 buffer 列表, 在这个列表中可以执行和 Dired Mode 类似的操作. SPC b h 进入 \\*spacemacs\\* buffer. SPC b k 使用正则表达式来删除 buffer. SPC b N 新建一个 buffer. SPC b m 删除除当前 buffer 外的所有 buffer. SPC b R 使用 emacs 自动备份的文件恢复文件. SPC b s 跳转到 scratch buffer. SPC b w 关闭/打开 buffer 的 read-only. SPC b Y 复制整个 buffer 的内容. SPC b P 将剪切板的内容粘贴到整个 buffer. SPC 在当前 buffer 和上一个打开的 buffer 中进行切换. Dired在第四天的内容中已经讲解过 Dired Mode 的操作, 具体可以查看 Dired Mode. 第十五天: layout, windows 和 project 相关视频地址如下: 百度网盘 优酷 Youtube 主要内容: Layout 相关操作 Window 相关操作 project 相关操作 Layout 相关操作 SPC l L 加载 layout 文件 SPC l l 在 layout 之间切换 SPC l s 将 layout 保存到文件 SPC l 在当前 layout 和上一个 layout 之间切换 SPC l o 配置 layout SPC l R 重命名 layout SPC l ? 显示更多的与 layout 相关的命令 Window 相关操作 SPC w - 上下拆分窗口 SPC w / 左右拆分窗口 SPC w . 显示更多的与 window micro state 的相关的命令 SPC w 2/3 左右显示 2/3 个窗口 SPC w = 将窗口均等分 SPC w b 切换到 minibuffer SPC w d 删除当前窗口 SPC w h/j/k/l 向 左/下/上/右 移动窗口 SPC w m 最大化显示当前窗口 SPC W H/J/K/L 将当前窗口向 左/下/上/右 移动 SPC w u/U 取消/重置上次操作 SPC w o 切换到其他 frame SPC w F 创建一个新的 frame SPC w 1/2/3/4 切换到对应的编号的窗口 SPC w w 依次切换到其他窗口 SPC w W 使用字母标识需要跳转的窗口, 并按下字母进行跳转 SPC t g 将当前显示的窗口与其他窗口进行黄金分割显示 SPC t - 开启/关闭 将光标始终显示在中心行 project 相关操作 SPC p f 在当前 project 中查找并打开文件 SPC p b 在当前 project 中查找打开的 buffer SPC p p 切换到其他的 project SPC p l 切换到其他的 project 并创建一个新的 layout find-file-in-project 这是一个插件, 支持全平台. 目前绑定在 SUPER f 快捷键上. 更多内容对 Spacemacs 中的快捷键操作就介绍到这里, 更多的快捷键介绍可以到 Spacemacs ABC 去查看. 第十六天: 使用 ctags 和 company-etags视频地址如下: 百度网盘 优酷 Youtube 主要内容: 这期视频主要介绍 ctags 和 company-mode 的使用. 为什么使用 ctagsctags 是一个开源的, 可以方便的对大型代码库进行索引的软件, 在使用 ctags 生成 tag 之后就可以非常方便的在这些 tag 中进行跳转.因为有些编程语言, 例如 javascript 或者 lua, 它们不能进行精确的语义补全, 在有 ctags 进行索引补全的情况下也可以方便编写代码. 在之前也介绍过 term-mode, 也可以做到一些语义补全. 但是它也有一些缺点: 配置方式复杂, 对于比较大的项目的配置比较有难度 有些时候不能得到想要的补全结果 之前作者使用 YCMD 来对 C/C++ 代码进行补全, 但是它不太稳定, 现在已经切换为 ctags 来进行补全, 对于调试和 profile 会使用 IDE 进行操作. 如何配置 ctags首先新建一个 testJs-ctags 目录, 然后在该目录下新建 a.js 以及 b.js 两个文件: mkdir testJs-ctags cd testJs-ctags touch a.js touch b.js 然后编辑 a.js 的内容如下: var func1 = function () { console.log(&quot;func1&quot;); }; var func2 = function () { }; 然后在 b.js 中的补全中可以显示处 func1 和 func2 的补全提示的. 为了更方便的讲解之后的内容, 我们可以查看使用的补全的后端: 输入 M-x, diminish-undo, 选择 company-mode, 这样在 modeline 就可以看到 company-mode 的具体信息. 再次输入 fun 等待弹出补全提示, 在补全选项中上下移动, 可以看到使用的补全后端包括 dabbrev-code 和 etags 等, 如果我们关闭 a.js 的 buffer, 就不会出现 func1 和 func2 的补全选项. 在之前的操作中, 我们并没有生成 ctags, 为什么也能使用 ctags 补全呢? 我们可以使用 SPC h d v, 然后输出 tags-table-list 来查看该变量的值, 当前的值是指向作者 cocos目录下的 TAGS 文件.使用以下代码清空该值: (setq-default tags-table-list nil) 然后再次尝试补全, 这时就不会使用 ctags 补全了. 那么如何生成 ctags 补全的文件呢? 使用以下命令即可: cd testJs-ctags ctags -e a.js # 针对目录 # ctags -eR foldername company-etags 在进行补全的时候, 会从变量 tags-table-list 值的文件列表中去查找 tags, 而且 tags 是不区分语言的. 如果需要手动加载 TAGS 文件, 那么可以调用 visit-tags-table 命令. 而在打开一个文件时, ctags 会从文件所在的目录进行查找, 一直到根目录, 加载所找到的 TAGS 文件. 如何高效的使用 ctags 自动重新生成 TAGS 文件在使用 ctags 的过程中, 如果文件的内容被改变, 那么需要重新生成 TAGS 文件, 以便 ctags 的补全结果更精确. 作者实现了一个函数来自动加载必须的 TAGS 文件: (defun my-setup-develop-environment () (interactive) (when (my-project-name-contains-substring &quot;guanghui&quot;) (cond ((my-project-name-contains-substring &quot;cocos2d-x&quot;) ;; C++ project don&apos;t need html tags (setq tags-table-list (list (my-create-tags-if-needed &quot;~/cocos2d-x/cocos&quot;)))) ((my-project-name-contains-substring &quot;Github/fireball&quot;) (message &quot;load tags for fireball engine repo...&quot;) ;; html project donot need C++ tags (setq tags-table-list (list (my-create-tags-if-needed &quot;~/Github/fireball/engine/cocos2d&quot;))))))) 有另外一个工具函数, 当保存文件时会自动的重新生成 TAGS: (defun my-auto-update-tags-when-save (prefix) (interactive &quot;P&quot;) (cond ((not my-tags-updated-time) (setq my-tags-updated-time (current-time))) ((and (not prefix) (&lt; (- (float-time (current-time)) (float-time my-tags-updated-time)) 300)) ;; &lt; 300 seconds (message &quot;no need to update the tags&quot;) ) (t (setq my-tags-updated-time (current-time)) (my-update-tags) (message &quot;updated tags after %d seconds.&quot; (- (float-time (current-time)) (float-time my-tags-updated-time)))))) 可以将 my-auto-udpate-tags-when-save 函数加入 after-save-hook 中, 或者绑定到快捷键上. 配置规则来生成更多的 TAGSctags 自身也有一个配置文件, 可以在该文件中定义规则来更好的生成 TAGS, 一个配置文件的示例如下: --exclude=*.svn* --exclude=*.git* --exclude=*tmp* --exclude=.#* --tag-relative=yes --recurse=yes --langdef=js --regex-js=/[ \\t.]([A-Z][A-Z0-9._$]+)[ \\t]*[=:][ \\t]*([0-9&quot;&apos;\\[\\{]|null)/\\1/n,constant/ --langdef=css --langmap=css:.css --regex-css=/^[ \\t]*\\.([A-Za-z0-9_-]+)/.\\1/c,class,classes/ 在配置文件中可以使用 &#x2013;exclude 来忽略文件或路径, 使用 &#x2013;langdef 来定义哪些文件属于 js 文件, 使用 &#x2013;regex-js 来定义 TAGS 生成时的匹配规则.这些匹配规则中可以使用正则表达式来提取内容生成 TAGS. 使用 etags-select 来浏览项目在有 TAGS 之后, 可以使用 ctags 来方便的浏览文件内容.例如在某个函数名上点击 [, g], 然后选择 etags-select-find-tag-at-point, 这时会把所有相关的内容列出到 buffer 中, 然后可以选择想要跳转的位置跳转过去. 最后的思考company-etags 不能对所有的 mode 进行补全, 例如在 org-mode 中默认是不使用 company-etags 的.因为在 company-etags.el 文件中有如下的代码: (defvar company-etags-modes &apos;(prog-mode c-mode objc-mode c++-mode java-mode jde-mode pascal-mode perl-mode python-mode)) 在该变量中定义了可以使用 company-etags 的 mode, 将 org-mode 加入该变量的值中即可在 org-mode 使用 company-etags 进行补全. ctags 支持上百种语言, 学会使用 ctags 能够提交效率.","tags":[]},{"title":"Atom无法安装插件的解决方案","date":"2018-04-15T17:20:30.000Z","path":"2018/04/16/Atom无法安装插件的解决方案/","text":"众所周知 Atom安装插件经常失败，全局SS也没什么用。终于找到了两个可靠的方法，分享一下。 第一种以Linter为例，到Atom官方插件库中搜索出Linter，点击插件详情页中的Repo，进入该插件的Github仓库，clone该项目到你的Atom插件目录（Win： C:\\Users\\你的用户名.atom\\packages，Mac： ~/.atom/packages），然后cd到该插件目录下，执行 npm install，安装完成。 这也是网上比较常见的手动安装插件的做法，但是实际安装完后经常出现再次打开Atom时崩溃的现象，建议尝试第二种方式。 第二种切换到Atom安装目录下（Win： C:\\Users\\你的用户名\\.atom，Mac： ~/.atom），编辑.atomrc文件（如果没有就新建一个）。将该文件内容改为1registry = https://registry.npm.taobao.org 或者123strict-ssl = falsehttp_proxy = socks5://127.0.0.1:1080https_proxy = socks5://127.0.0.1:1080 将http_proxy和https_proxy修改为你自己的代理。然后再去Atom中正常安装（File-Setting-Install）即可","tags":[{"name":"atom","slug":"atom","permalink":"http://kingle.online/tags/atom/"},{"name":"插件","slug":"插件","permalink":"http://kingle.online/tags/插件/"}]},{"title":"正则表达式教程","date":"2018-03-30T15:00:18.000Z","path":"2018/03/30/正则表达式教程/","text":"常见匹配模式 模式 描述 \\w 匹配字母数字及下划线 \\W 匹配非字母数字下划线 \\s 匹配任意空白字符，等价于 [\\t\\n\\r\\f]. \\S 匹配任意非空字符 \\d 匹配任意数字，等价于 [0-9] \\D 匹配任意非数字 \\A 匹配字符串开始 \\Z 匹配字符串结束，如果是存在换行，只匹配到换行前的结束字符串 \\z 匹配字符串结束 \\G 匹配最后匹配完成的位置 \\n 匹配一个换行符 \\t 匹配一个制表符 ^ 匹配字符串的开头 $ 匹配字符串的末尾。 . 匹配任意字符，除了换行符，当re.DOTALL标记被指定时，则可以匹配包括换行符的任意字符。 […] 用来表示一组字符,单独列出：[amk] 匹配 ‘a’，’m’或’k’ [^…] 不在[]中的字符：[^abc] 匹配除了a,b,c之外的字符。 * 匹配0个或多个的表达式。 + 匹配1个或多个的表达式。 ? 匹配0个或1个由前面的正则表达式定义的片段，非贪婪方式 {n} 精确匹配n个前面表达式。 {n, m} 匹配 n 到 m 次由前面的正则表达式定义的片段，贪婪方式 a&#124;b 匹配a或b ( ) 匹配括号内的表达式，也表示一个组 re.matchre.match 尝试从字符串的起始位置匹配一个模式，如果不是起始位置匹配成功的话，match()就返回none。re.match(pattern, string, flags=0) 最常规的匹配12345678import recontent = 'Hello 123 4567 World_This is a Regex Demo'print(len(content))result = re.match('^Hello\\s\\d\\d\\d\\s\\d&#123;4&#125;\\s\\w&#123;10&#125;.*Demo$', content)print(result)print(result.group())print(result.span()) 41 &lt;_sre.SRE_Match object; span=(0, 41), match=&apos;Hello 123 4567 World_This is a Regex Demo&apos;&gt; Hello 123 4567 World_This is a Regex Demo (0, 41) 泛匹配1234567import recontent = 'Hello 123 4567 World_This is a Regex Demo'result = re.match('^Hello.*Demo$', content)print(result)print(result.group())print(result.span()) &lt;_sre.SRE_Match object; span=(0, 41), match=&apos;Hello 123 4567 World_This is a Regex Demo&apos;&gt; Hello 123 4567 World_This is a Regex Demo (0, 41) 匹配目标1234567import recontent = 'Hello 1234567 World_This is a Regex Demo'result = re.match('^Hello\\s(\\d+)\\sWorld.*Demo$', content)print(result)print(result.group(1))print(result.span()) &lt;_sre.SRE_Match object; span=(0, 40), match=&apos;Hello 1234567 World_This is a Regex Demo&apos;&gt; 1234567 (0, 40) 贪婪匹配123456import recontent = 'Hello 1234567 World_This is a Regex Demo'result = re.match('^He.*(\\d+).*Demo$', content)print(result)print(result.group(1)) &lt;_sre.SRE_Match object; span=(0, 40), match=&apos;Hello 1234567 World_This is a Regex Demo&apos;&gt; 7 非贪婪匹配123456import recontent = 'Hello 1234567 World_This is a Regex Demo'result = re.match('^He.*?(\\d+).*Demo$', content)print(result)print(result.group(1)) &lt;_sre.SRE_Match object; span=(0, 40), match=&apos;Hello 1234567 World_This is a Regex Demo&apos;&gt; 1234567 匹配模式1234567import recontent = '''Hello 1234567 World_Thisis a Regex Demo'''result = re.match('^He.*?(\\d+).*?Demo$', content, re.S)print(result.group(1)) 1234567 转义12345import recontent = 'price is $5.00'result = re.match('price is $5.00', content)print(result) None 12345import recontent = 'price is $5.00'result = re.match('price is \\$5\\.00', content)print(result) &lt;_sre.SRE_Match object; span=(0, 14), match=&apos;price is $5.00&apos;&gt; 总结：尽量使用泛匹配、使用括号得到匹配目标、尽量使用非贪婪模式、有换行符就用re.S re.searchre.search 扫描整个字符串并返回第一个成功的匹配。 12345import recontent = 'Extra stings Hello 1234567 World_This is a Regex Demo Extra stings'result = re.match('Hello.*?(\\d+).*?Demo', content)print(result) None 123456import recontent = 'Extra stings Hello 1234567 World_This is a Regex Demo Extra stings'result = re.search('Hello.*?(\\d+).*?Demo', content)print(result)print(result.group(1)) &lt;_sre.SRE_Match object; span=(13, 53), match=&apos;Hello 1234567 World_This is a Regex Demo&apos;&gt; 1234567 总结：为匹配方便，能用search就不用match 匹配演练12345678910111213141516171819202122232425import rehtml = '''&lt;div id=\"songs-list\"&gt; &lt;h2 class=\"title\"&gt;经典老歌&lt;/h2&gt; &lt;p class=\"introduction\"&gt; 经典老歌列表 &lt;/p&gt; &lt;ul id=\"list\" class=\"list-group\"&gt; &lt;li data-view=\"2\"&gt;一路上有你&lt;/li&gt; &lt;li data-view=\"7\"&gt; &lt;a href=\"/2.mp3\" singer=\"任贤齐\"&gt;沧海一声笑&lt;/a&gt; &lt;/li&gt; &lt;li data-view=\"4\" class=\"active\"&gt; &lt;a href=\"/3.mp3\" singer=\"齐秦\"&gt;往事随风&lt;/a&gt; &lt;/li&gt; &lt;li data-view=\"6\"&gt;&lt;a href=\"/4.mp3\" singer=\"beyond\"&gt;光辉岁月&lt;/a&gt;&lt;/li&gt; &lt;li data-view=\"5\"&gt;&lt;a href=\"/5.mp3\" singer=\"陈慧琳\"&gt;记事本&lt;/a&gt;&lt;/li&gt; &lt;li data-view=\"5\"&gt; &lt;a href=\"/6.mp3\" singer=\"邓丽君\"&gt;&lt;i class=\"fa fa-user\"&gt;&lt;/i&gt;但愿人长久&lt;/a&gt; &lt;/li&gt; &lt;/ul&gt;&lt;/div&gt;'''result = re.search('&lt;li.*?active.*?singer=\"(.*?)\"&gt;(.*?)&lt;/a&gt;', html, re.S)if result: print(result.group(1), result.group(2)) 齐秦 往事随风 12345678910111213141516171819202122232425import rehtml = '''&lt;div id=\"songs-list\"&gt; &lt;h2 class=\"title\"&gt;经典老歌&lt;/h2&gt; &lt;p class=\"introduction\"&gt; 经典老歌列表 &lt;/p&gt; &lt;ul id=\"list\" class=\"list-group\"&gt; &lt;li data-view=\"2\"&gt;一路上有你&lt;/li&gt; &lt;li data-view=\"7\"&gt; &lt;a href=\"/2.mp3\" singer=\"任贤齐\"&gt;沧海一声笑&lt;/a&gt; &lt;/li&gt; &lt;li data-view=\"4\" class=\"active\"&gt; &lt;a href=\"/3.mp3\" singer=\"齐秦\"&gt;往事随风&lt;/a&gt; &lt;/li&gt; &lt;li data-view=\"6\"&gt;&lt;a href=\"/4.mp3\" singer=\"beyond\"&gt;光辉岁月&lt;/a&gt;&lt;/li&gt; &lt;li data-view=\"5\"&gt;&lt;a href=\"/5.mp3\" singer=\"陈慧琳\"&gt;记事本&lt;/a&gt;&lt;/li&gt; &lt;li data-view=\"5\"&gt; &lt;a href=\"/6.mp3\" singer=\"邓丽君\"&gt;但愿人长久&lt;/a&gt; &lt;/li&gt; &lt;/ul&gt;&lt;/div&gt;'''result = re.search('&lt;li.*?singer=\"(.*?)\"&gt;(.*?)&lt;/a&gt;', html, re.S)if result: print(result.group(1), result.group(2)) 任贤齐 沧海一声笑 12345678910111213141516171819202122232425import rehtml = '''&lt;div id=\"songs-list\"&gt; &lt;h2 class=\"title\"&gt;经典老歌&lt;/h2&gt; &lt;p class=\"introduction\"&gt; 经典老歌列表 &lt;/p&gt; &lt;ul id=\"list\" class=\"list-group\"&gt; &lt;li data-view=\"2\"&gt;一路上有你&lt;/li&gt; &lt;li data-view=\"7\"&gt; &lt;a href=\"/2.mp3\" singer=\"任贤齐\"&gt;沧海一声笑&lt;/a&gt; &lt;/li&gt; &lt;li data-view=\"4\" class=\"active\"&gt; &lt;a href=\"/3.mp3\" singer=\"齐秦\"&gt;往事随风&lt;/a&gt; &lt;/li&gt; &lt;li data-view=\"6\"&gt;&lt;a href=\"/4.mp3\" singer=\"beyond\"&gt;光辉岁月&lt;/a&gt;&lt;/li&gt; &lt;li data-view=\"5\"&gt;&lt;a href=\"/5.mp3\" singer=\"陈慧琳\"&gt;记事本&lt;/a&gt;&lt;/li&gt; &lt;li data-view=\"5\"&gt; &lt;a href=\"/6.mp3\" singer=\"邓丽君\"&gt;但愿人长久&lt;/a&gt; &lt;/li&gt; &lt;/ul&gt;&lt;/div&gt;'''result = re.search('&lt;li.*?singer=\"(.*?)\"&gt;(.*?)&lt;/a&gt;', html)if result: print(result.group(1), result.group(2)) beyond 光辉岁月 re.findall搜索字符串，以列表形式返回全部能匹配的子串。 12345678910111213141516171819202122232425262728import rehtml = '''&lt;div id=\"songs-list\"&gt; &lt;h2 class=\"title\"&gt;经典老歌&lt;/h2&gt; &lt;p class=\"introduction\"&gt; 经典老歌列表 &lt;/p&gt; &lt;ul id=\"list\" class=\"list-group\"&gt; &lt;li data-view=\"2\"&gt;一路上有你&lt;/li&gt; &lt;li data-view=\"7\"&gt; &lt;a href=\"/2.mp3\" singer=\"任贤齐\"&gt;沧海一声笑&lt;/a&gt; &lt;/li&gt; &lt;li data-view=\"4\" class=\"active\"&gt; &lt;a href=\"/3.mp3\" singer=\"齐秦\"&gt;往事随风&lt;/a&gt; &lt;/li&gt; &lt;li data-view=\"6\"&gt;&lt;a href=\"/4.mp3\" singer=\"beyond\"&gt;光辉岁月&lt;/a&gt;&lt;/li&gt; &lt;li data-view=\"5\"&gt;&lt;a href=\"/5.mp3\" singer=\"陈慧琳\"&gt;记事本&lt;/a&gt;&lt;/li&gt; &lt;li data-view=\"5\"&gt; &lt;a href=\"/6.mp3\" singer=\"邓丽君\"&gt;但愿人长久&lt;/a&gt; &lt;/li&gt; &lt;/ul&gt;&lt;/div&gt;'''results = re.findall('&lt;li.*?href=\"(.*?)\".*?singer=\"(.*?)\"&gt;(.*?)&lt;/a&gt;', html, re.S)print(results)print(type(results))for result in results: print(result) print(result[0], result[1], result[2]) [(&apos;/2.mp3&apos;, &apos;任贤齐&apos;, &apos;沧海一声笑&apos;), (&apos;/3.mp3&apos;, &apos;齐秦&apos;, &apos;往事随风&apos;), (&apos;/4.mp3&apos;, &apos;beyond&apos;, &apos;光辉岁月&apos;), (&apos;/5.mp3&apos;, &apos;陈慧琳&apos;, &apos;记事本&apos;), (&apos;/6.mp3&apos;, &apos;邓丽君&apos;, &apos;但愿人长久&apos;)] &lt;class &apos;list&apos;&gt; (&apos;/2.mp3&apos;, &apos;任贤齐&apos;, &apos;沧海一声笑&apos;) /2.mp3 任贤齐 沧海一声笑 (&apos;/3.mp3&apos;, &apos;齐秦&apos;, &apos;往事随风&apos;) /3.mp3 齐秦 往事随风 (&apos;/4.mp3&apos;, &apos;beyond&apos;, &apos;光辉岁月&apos;) /4.mp3 beyond 光辉岁月 (&apos;/5.mp3&apos;, &apos;陈慧琳&apos;, &apos;记事本&apos;) /5.mp3 陈慧琳 记事本 (&apos;/6.mp3&apos;, &apos;邓丽君&apos;, &apos;但愿人长久&apos;) /6.mp3 邓丽君 但愿人长久 1234567891011121314151617181920212223242526import rehtml = '''&lt;div id=\"songs-list\"&gt; &lt;h2 class=\"title\"&gt;经典老歌&lt;/h2&gt; &lt;p class=\"introduction\"&gt; 经典老歌列表 &lt;/p&gt; &lt;ul id=\"list\" class=\"list-group\"&gt; &lt;li data-view=\"2\"&gt;一路上有你&lt;/li&gt; &lt;li data-view=\"7\"&gt; &lt;a href=\"/2.mp3\" singer=\"任贤齐\"&gt;沧海一声笑&lt;/a&gt; &lt;/li&gt; &lt;li data-view=\"4\" class=\"active\"&gt; &lt;a href=\"/3.mp3\" singer=\"齐秦\"&gt;往事随风&lt;/a&gt; &lt;/li&gt; &lt;li data-view=\"6\"&gt;&lt;a href=\"/4.mp3\" singer=\"beyond\"&gt;光辉岁月&lt;/a&gt;&lt;/li&gt; &lt;li data-view=\"5\"&gt;&lt;a href=\"/5.mp3\" singer=\"陈慧琳\"&gt;记事本&lt;/a&gt;&lt;/li&gt; &lt;li data-view=\"5\"&gt; &lt;a href=\"/6.mp3\" singer=\"邓丽君\"&gt;但愿人长久&lt;/a&gt; &lt;/li&gt; &lt;/ul&gt;&lt;/div&gt;'''results = re.findall('&lt;li.*?&gt;\\s*?(&lt;a.*?&gt;)?(\\w+)(&lt;/a&gt;)?\\s*?&lt;/li&gt;', html, re.S)print(results)for result in results: print(result[1]) [(&apos;&apos;, &apos;一路上有你&apos;, &apos;&apos;), (&apos;&lt;a href=&quot;/2.mp3&quot; singer=&quot;任贤齐&quot;&gt;&apos;, &apos;沧海一声笑&apos;, &apos;&lt;/a&gt;&apos;), (&apos;&lt;a href=&quot;/3.mp3&quot; singer=&quot;齐秦&quot;&gt;&apos;, &apos;往事随风&apos;, &apos;&lt;/a&gt;&apos;), (&apos;&lt;a href=&quot;/4.mp3&quot; singer=&quot;beyond&quot;&gt;&apos;, &apos;光辉岁月&apos;, &apos;&lt;/a&gt;&apos;), (&apos;&lt;a href=&quot;/5.mp3&quot; singer=&quot;陈慧琳&quot;&gt;&apos;, &apos;记事本&apos;, &apos;&lt;/a&gt;&apos;), (&apos;&lt;a href=&quot;/6.mp3&quot; singer=&quot;邓丽君&quot;&gt;&apos;, &apos;但愿人长久&apos;, &apos;&lt;/a&gt;&apos;)] 一路上有你 沧海一声笑 往事随风 光辉岁月 记事本 但愿人长久 re.sub替换字符串中每一个匹配的子串后返回替换后的字符串。 12345import recontent = 'Extra stings Hello 1234567 World_This is a Regex Demo Extra stings'content = re.sub('\\d+', '', content)print(content) Extra stings Hello World_This is a Regex Demo Extra stings 12345import recontent = 'Extra stings Hello 1234567 World_This is a Regex Demo Extra stings'content = re.sub('\\d+', 'Replacement', content)print(content) Extra stings Hello Replacement World_This is a Regex Demo Extra stings 12345import recontent = 'Extra stings Hello 1234567 World_This is a Regex Demo Extra stings'content = re.sub('(\\d+)', r'\\1 8910', content)print(content) Extra stings Hello 1234567 8910 World_This is a Regex Demo Extra stings 12345678910111213141516171819202122import rehtml = '''&lt;div id=\"songs-list\"&gt; &lt;h2 class=\"title\"&gt;经典老歌&lt;/h2&gt; &lt;p class=\"introduction\"&gt; 经典老歌列表 &lt;/p&gt; &lt;ul id=\"list\" class=\"list-group\"&gt; &lt;li data-view=\"2\"&gt;一路上有你&lt;/li&gt; &lt;li data-view=\"7\"&gt; &lt;a href=\"/2.mp3\" singer=\"任贤齐\"&gt;沧海一声笑&lt;/a&gt; &lt;/li&gt; &lt;li data-view=\"4\" class=\"active\"&gt; &lt;a href=\"/3.mp3\" singer=\"齐秦\"&gt;往事随风&lt;/a&gt; &lt;/li&gt; &lt;li data-view=\"6\"&gt;&lt;a href=\"/4.mp3\" singer=\"beyond\"&gt;光辉岁月&lt;/a&gt;&lt;/li&gt; &lt;li data-view=\"5\"&gt;&lt;a href=\"/5.mp3\" singer=\"陈慧琳\"&gt;记事本&lt;/a&gt;&lt;/li&gt; &lt;li data-view=\"5\"&gt; &lt;a href=\"/6.mp3\" singer=\"邓丽君\"&gt;但愿人长久&lt;/a&gt; &lt;/li&gt; &lt;/ul&gt;&lt;/div&gt;''' 12345678910111213141516171819202122232425262728import rehtml = '''&lt;div id=\"songs-list\"&gt; &lt;h2 class=\"title\"&gt;经典老歌&lt;/h2&gt; &lt;p class=\"introduction\"&gt; 经典老歌列表 &lt;/p&gt; &lt;ul id=\"list\" class=\"list-group\"&gt; &lt;li data-view=\"2\"&gt;一路上有你&lt;/li&gt; &lt;li data-view=\"7\"&gt; &lt;a href=\"/2.mp3\" singer=\"任贤齐\"&gt;沧海一声笑&lt;/a&gt; &lt;/li&gt; &lt;li data-view=\"4\" class=\"active\"&gt; &lt;a href=\"/3.mp3\" singer=\"齐秦\"&gt;往事随风&lt;/a&gt; &lt;/li&gt; &lt;li data-view=\"6\"&gt;&lt;a href=\"/4.mp3\" singer=\"beyond\"&gt;光辉岁月&lt;/a&gt;&lt;/li&gt; &lt;li data-view=\"5\"&gt;&lt;a href=\"/5.mp3\" singer=\"陈慧琳\"&gt;记事本&lt;/a&gt;&lt;/li&gt; &lt;li data-view=\"5\"&gt; &lt;a href=\"/6.mp3\" singer=\"邓丽君\"&gt;但愿人长久&lt;/a&gt; &lt;/li&gt; &lt;/ul&gt;&lt;/div&gt;'''html = re.sub('&lt;a.*?&gt;|&lt;/a&gt;', '', html)print(html)results = re.findall('&lt;li.*?&gt;(.*?)&lt;/li&gt;', html, re.S)print(results)for result in results: print(result.strip()) &lt;div id=&quot;songs-list&quot;&gt; &lt;h2 class=&quot;title&quot;&gt;经典老歌&lt;/h2&gt; &lt;p class=&quot;introduction&quot;&gt; 经典老歌列表 &lt;/p&gt; &lt;ul id=&quot;list&quot; class=&quot;list-group&quot;&gt; &lt;li data-view=&quot;2&quot;&gt;一路上有你&lt;/li&gt; &lt;li data-view=&quot;7&quot;&gt; 沧海一声笑 &lt;/li&gt; &lt;li data-view=&quot;4&quot; class=&quot;active&quot;&gt; 往事随风 &lt;/li&gt; &lt;li data-view=&quot;6&quot;&gt;光辉岁月&lt;/li&gt; &lt;li data-view=&quot;5&quot;&gt;记事本&lt;/li&gt; &lt;li data-view=&quot;5&quot;&gt; 但愿人长久 &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; [&apos;一路上有你&apos;, &apos;\\n 沧海一声笑\\n &apos;, &apos;\\n 往事随风\\n &apos;, &apos;光辉岁月&apos;, &apos;记事本&apos;, &apos;\\n 但愿人长久\\n &apos;] 一路上有你 沧海一声笑 往事随风 光辉岁月 记事本 但愿人长久 re.compile将正则字符串编译成正则表达式对象 1将一个正则表达式串编译成正则对象，以便于复用该匹配模式 12345678import recontent = '''Hello 1234567 World_Thisis a Regex Demo'''pattern = re.compile('Hello.*Demo', re.S)result = re.match(pattern, content)#result = re.match('Hello.*Demo', content, re.S)print(result) &lt;_sre.SRE_Match object; span=(0, 40), match=&apos;Hello 1234567 World_This\\nis a Regex Demo&apos;&gt; 实战练习12345678910import requestsimport recontent = requests.get('https://book.douban.com/').textpattern = re.compile('&lt;li.*?cover.*?href=\"(.*?)\".*?title=\"(.*?)\".*?more-meta.*?author\"&gt;(.*?)&lt;/span&gt;.*?year\"&gt;(.*?)&lt;/span&gt;.*?&lt;/li&gt;', re.S)results = re.findall(pattern, content)for result in results: url, name, author, date = result author = re.sub('\\s', '', author) date = re.sub('\\s', '', date) print(url, name, author, date) https://book.douban.com/subject/26925834/?icn=index-editionrecommend 别走出这一步 [英]S.J.沃森 2017-1 https://book.douban.com/subject/26953532/?icn=index-editionrecommend 白先勇细说红楼梦 白先勇 2017-2-1 https://book.douban.com/subject/26959159/?icn=index-editionrecommend 岁月凶猛 冯仑 2017-2 https://book.douban.com/subject/26949210/?icn=index-editionrecommend 如果没有今天，明天会不会有昨天？ [瑞士]伊夫·博萨尔特（YvesBossart） 2017-1 https://book.douban.com/subject/27001447/?icn=index-editionrecommend 人类这100年 阿夏 2017-2 https://book.douban.com/subject/26864566/?icn=index-latestbook-subject 眼泪的化学 [澳]彼得·凯里 2017-2 https://book.douban.com/subject/26991064/?icn=index-latestbook-subject 青年斯大林 [英]西蒙·蒙蒂菲奥里 2017-3 https://book.douban.com/subject/26938056/?icn=index-latestbook-subject 带艾伯特回家 [美]霍默·希卡姆 2017-3 https://book.douban.com/subject/26954757/?icn=index-latestbook-subject 乳房 [美]弗洛伦斯·威廉姆斯 2017-2 https://book.douban.com/subject/26956479/?icn=index-latestbook-subject 草原动物园 马伯庸 2017-3 https://book.douban.com/subject/26956018/?icn=index-latestbook-subject 贩卖音乐 [美]大卫·伊斯曼 2017-3-1 https://book.douban.com/subject/26703649/?icn=index-latestbook-subject 被占的宅子 [阿根廷]胡利奥·科塔萨尔 2017-3 https://book.douban.com/subject/26578402/?icn=index-latestbook-subject 信仰与观看 [法]罗兰·雷希特(RolandRecht) 2017-2-17 https://book.douban.com/subject/26939171/?icn=index-latestbook-subject 妹妹的坟墓 [美]罗伯特·杜格尼(RobertDugoni) 2017-3-1 https://book.douban.com/subject/26972465/?icn=index-latestbook-subject 全栈市场人 Lydia 2017-2-1 https://book.douban.com/subject/26986928/?icn=index-latestbook-subject 终极X战警2 [英]马克·米勒&amp;nbsp;/&amp;nbsp;[美]亚当·库伯特 2017-3-15 https://book.douban.com/subject/26948144/?icn=index-latestbook-subject 格调（修订第3版） [美]保罗·福塞尔（PaulFussell） 2017-2 https://book.douban.com/subject/26945792/?icn=index-latestbook-subject 原谅石 [美]洛里·斯皮尔曼 2017-2 https://book.douban.com/subject/26974207/?icn=index-latestbook-subject 庇护二世闻见录 [意]皮科洛米尼 2017-2 https://book.douban.com/subject/26983143/?icn=index-latestbook-subject 遇见野兔的那一年 [芬]阿托·帕西林纳 2017-3-1 https://book.douban.com/subject/26976429/?icn=index-latestbook-subject 鲍勃·迪伦：诗人之歌 [法]让-多米尼克·布里埃 2017-4 https://book.douban.com/subject/26962860/?icn=index-latestbook-subject 牙医谋杀案 [英]阿加莎·克里斯蒂 2017-3 https://book.douban.com/subject/26923022/?icn=index-latestbook-subject 石挥谈艺录：把生命交给舞台 石挥 2017-2 https://book.douban.com/subject/26897190/?icn=index-latestbook-subject 理想 [美]安·兰德 2017-2 https://book.douban.com/subject/26985981/?icn=index-latestbook-subject 青苔不会消失 袁凌 2017-4 https://book.douban.com/subject/26984949/?icn=index-latestbook-subject 地下铁道 [美]科尔森·怀特黑德（ColsonWhitehead） 2017-3 https://book.douban.com/subject/26944012/?icn=index-latestbook-subject 极简进步史 [英]罗纳德·赖特 2017-4-1 https://book.douban.com/subject/26969002/?icn=index-latestbook-subject 驻马店伤心故事集 郑在欢 2017-2 https://book.douban.com/subject/26854223/?icn=index-latestbook-subject 致薇拉 [美]弗拉基米尔·纳博科夫 2017-3 https://book.douban.com/subject/26841616/?icn=index-latestbook-subject 北方档案 [法]玛格丽特·尤瑟纳尔 2017-2 https://book.douban.com/subject/26980391/?icn=index-latestbook-subject 食帖15：便当灵感集 林江 2017-2 https://book.douban.com/subject/26958882/?icn=index-latestbook-subject 生火 [法]克里斯多夫·夏布特（ChristopheChabouté）编绘 2017-3 https://book.douban.com/subject/26989163/?icn=index-latestbook-subject 文明之光（第四册） 吴军 2017-3-1 https://book.douban.com/subject/26878906/?icn=index-latestbook-subject 公牛山 [美]布赖恩·帕诺威奇 2017-2 https://book.douban.com/subject/26989534/?icn=index-latestbook-subject 几乎消失的偷闲艺术 [加拿大]达尼·拉费里埃 2017-4 https://book.douban.com/subject/26939973/?icn=index-latestbook-subject 散步去 [日]谷口治郎 2017-3 https://book.douban.com/subject/26865333/?icn=index-latestbook-subject 中国1945 [美]理查德·伯恩斯坦(RichardBernstein) 2017-3-1 https://book.douban.com/subject/26989242/?icn=index-latestbook-subject 有匪2：离恨楼 Priest 2017-3 https://book.douban.com/subject/26985790/?icn=index-latestbook-subject 女人、火与危险事物 [美]乔治·莱考夫 2017-3 https://book.douban.com/subject/26972277/?icn=index-latestbook-subject 寻找时间的人 [爱尔兰]凯特·汤普森 2017-3 https://www.douban.com/note/610758170/ 白先勇细说红楼梦【全二册】 白先勇 2017-2-1 https://read.douban.com/ebook/31540864/?dcs=book-hot&amp;amp;dcm=douban&amp;amp;dct=read-subject 奇爱博士 [英]彼得·乔治 2016-8-1 https://read.douban.com/ebook/31433872/?dcs=book-hot&amp;amp;dcm=douban&amp;amp;dct=read-subject 在时光中盛开的女子 李筱懿 2017-3 https://read.douban.com/ebook/31178635/?dcs=book-hot&amp;amp;dcm=douban&amp;amp;dct=read-subject 如何高效记忆（原书第2版） [美]肯尼思•希格比（KennethL.Higbee） 2017-3-5 https://read.douban.com/ebook/31358183/?dcs=book-hot&amp;amp;dcm=douban&amp;amp;dct=read-subject 愿无岁月可回头 回忆专用小马甲 2016-9 https://read.douban.com/ebook/31341636/?dcs=book-hot&amp;amp;dcm=douban&amp;amp;dct=read-subject 走神的艺术与科学 [新西兰]迈克尔·C.科尔巴里斯 2017-3-1 https://read.douban.com/ebook/27621094/?dcs=book-hot&amp;amp;dcm=douban&amp;amp;dct=read-subject 神秘的量子生命 [英]吉姆•艾尔－哈利利/约翰乔•麦克法登 2016-8 https://read.douban.com/ebook/31221966/?dcs=book-hot&amp;amp;dcm=douban&amp;amp;dct=read-subject 寻找时间的人 [爱尔兰]凯特·汤普森 2017-3 https://read.douban.com/ebook/31481323/?dcs=book-hot&amp;amp;dcm=douban&amp;amp;dct=read-subject 山之四季 [日]高村光太郎 2017-1 https://read.douban.com/ebook/31154855/?dcs=book-hot&amp;amp;dcm=douban&amp;amp;dct=read-subject 东北游记 [美]迈克尔·麦尔 2017-1","tags":[{"name":"regex","slug":"regex","permalink":"http://kingle.online/tags/regex/"},{"name":"正则表达式","slug":"正则表达式","permalink":"http://kingle.online/tags/正则表达式/"}]},{"title":"BeautifulSoup库详解","date":"2018-03-24T17:24:05.000Z","path":"2018/03/25/BeautifulSoup库详解/","text":"BeautifulSoup解析库 解析器 使用方法 优势 劣势 Python标准库 BeautifulSoup(markup, “html.parser”) Python的内置标准库、执行速度适中 、文档容错能力强 Python 2.7.3 or 3.2.2)前的版本中文容错能力差 lxml HTML 解析器 BeautifulSoup(markup, “lxml”) 速度快、文档容错能力强 需要安装C语言库 lxml XML 解析器 BeautifulSoup(markup, “xml”) 速度快、唯一支持XML的解析器 需要安装C语言库 html5lib BeautifulSoup(markup, “html5lib”) 最好的容错性、以浏览器的方式解析文档、生成HTML5格式的文档 速度慢、不依赖外部扩展 基本使用123456789101112131415html = \"\"\"&lt;html&gt;&lt;head&gt;&lt;title&gt;The Dormouse's story&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;p class=\"title\" name=\"dromouse\"&gt;&lt;b&gt;The Dormouse's story&lt;/b&gt;&lt;/p&gt;&lt;p class=\"story\"&gt;Once upon a time there were three little sisters; and their names were&lt;a href=\"http://example.com/elsie\" class=\"sister\" id=\"link1\"&gt;&lt;!-- Elsie --&gt;&lt;/a&gt;,&lt;a href=\"http://example.com/lacie\" class=\"sister\" id=\"link2\"&gt;Lacie&lt;/a&gt; and&lt;a href=\"http://example.com/tillie\" class=\"sister\" id=\"link3\"&gt;Tillie&lt;/a&gt;;and they lived at the bottom of a well.&lt;/p&gt;&lt;p class=\"story\"&gt;...&lt;/p&gt;\"\"\"from bs4 import BeautifulSoupsoup = BeautifulSoup(html, 'lxml')print(soup.prettify())print(soup.title.string) &lt;html&gt; &lt;head&gt; &lt;title&gt; The Dormouse&apos;s story &lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;p class=&quot;title&quot; name=&quot;dromouse&quot;&gt; &lt;b&gt; The Dormouse&apos;s story &lt;/b&gt; &lt;/p&gt; &lt;p class=&quot;story&quot;&gt; Once upon a time there were three little sisters; and their names were &lt;a class=&quot;sister&quot; href=&quot;http://example.com/elsie&quot; id=&quot;link1&quot;&gt; &lt;!-- Elsie --&gt; &lt;/a&gt; , &lt;a class=&quot;sister&quot; href=&quot;http://example.com/lacie&quot; id=&quot;link2&quot;&gt; Lacie &lt;/a&gt; and &lt;a class=&quot;sister&quot; href=&quot;http://example.com/tillie&quot; id=&quot;link3&quot;&gt; Tillie &lt;/a&gt; ; and they lived at the bottom of a well. &lt;/p&gt; &lt;p class=&quot;story&quot;&gt; ... &lt;/p&gt; &lt;/body&gt; &lt;/html&gt; The Dormouse&apos;s story 12 标签选择器选择元素1234567891011121314151617html = \"\"\"&lt;html&gt;&lt;head&gt;&lt;title&gt;The Dormouse's story&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;p class=\"title\" name=\"dromouse\"&gt;&lt;b&gt;The Dormouse's story&lt;/b&gt;&lt;/p&gt;&lt;p class=\"story\"&gt;Once upon a time there were three little sisters; and their names were&lt;a href=\"http://example.com/elsie\" class=\"sister\" id=\"link1\"&gt;&lt;!-- Elsie --&gt;&lt;/a&gt;,&lt;a href=\"http://example.com/lacie\" class=\"sister\" id=\"link2\"&gt;Lacie&lt;/a&gt; and&lt;a href=\"http://example.com/tillie\" class=\"sister\" id=\"link3\"&gt;Tillie&lt;/a&gt;;and they lived at the bottom of a well.&lt;/p&gt;&lt;p class=\"story\"&gt;...&lt;/p&gt;\"\"\"from bs4 import BeautifulSoupsoup = BeautifulSoup(html, 'lxml')print(soup.title)print(type(soup.title))print(soup.head)print(soup.p) &lt;title&gt;The Dormouse&apos;s story&lt;/title&gt; &lt;class &apos;bs4.element.Tag&apos;&gt; &lt;head&gt;&lt;title&gt;The Dormouse&apos;s story&lt;/title&gt;&lt;/head&gt; &lt;p class=&quot;title&quot; name=&quot;dromouse&quot;&gt;&lt;b&gt;The Dormouse&apos;s story&lt;/b&gt;&lt;/p&gt; 获取名称1234567891011121314html = \"\"\"&lt;html&gt;&lt;head&gt;&lt;title&gt;The Dormouse's story&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;p class=\"title\" name=\"dromouse\"&gt;&lt;b&gt;The Dormouse's story&lt;/b&gt;&lt;/p&gt;&lt;p class=\"story\"&gt;Once upon a time there were three little sisters; and their names were&lt;a href=\"http://example.com/elsie\" class=\"sister\" id=\"link1\"&gt;&lt;!-- Elsie --&gt;&lt;/a&gt;,&lt;a href=\"http://example.com/lacie\" class=\"sister\" id=\"link2\"&gt;Lacie&lt;/a&gt; and&lt;a href=\"http://example.com/tillie\" class=\"sister\" id=\"link3\"&gt;Tillie&lt;/a&gt;;and they lived at the bottom of a well.&lt;/p&gt;&lt;p class=\"story\"&gt;...&lt;/p&gt;\"\"\"from bs4 import BeautifulSoupsoup = BeautifulSoup(html, 'lxml')print(soup.title.name) title 获取属性123456789101112131415html = \"\"\"&lt;html&gt;&lt;head&gt;&lt;title&gt;The Dormouse's story&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;p class=\"title\" name=\"dromouse\"&gt;&lt;b&gt;The Dormouse's story&lt;/b&gt;&lt;/p&gt;&lt;p class=\"story\"&gt;Once upon a time there were three little sisters; and their names were&lt;a href=\"http://example.com/elsie\" class=\"sister\" id=\"link1\"&gt;&lt;!-- Elsie --&gt;&lt;/a&gt;,&lt;a href=\"http://example.com/lacie\" class=\"sister\" id=\"link2\"&gt;Lacie&lt;/a&gt; and&lt;a href=\"http://example.com/tillie\" class=\"sister\" id=\"link3\"&gt;Tillie&lt;/a&gt;;and they lived at the bottom of a well.&lt;/p&gt;&lt;p class=\"story\"&gt;...&lt;/p&gt;\"\"\"from bs4 import BeautifulSoupsoup = BeautifulSoup(html, 'lxml')print(soup.p.attrs['name'])print(soup.p['name']) dromouse dromouse 获取内容1234567891011121314html = \"\"\"&lt;html&gt;&lt;head&gt;&lt;title&gt;The Dormouse's story&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;p clss=\"title\" name=\"dromouse\"&gt;&lt;b&gt;The Dormouse's story&lt;/b&gt;&lt;/p&gt;&lt;p class=\"story\"&gt;Once upon a time there were three little sisters; and their names were&lt;a href=\"http://example.com/elsie\" class=\"sister\" id=\"link1\"&gt;&lt;!-- Elsie --&gt;&lt;/a&gt;,&lt;a href=\"http://example.com/lacie\" class=\"sister\" id=\"link2\"&gt;Lacie&lt;/a&gt; and&lt;a href=\"http://example.com/tillie\" class=\"sister\" id=\"link3\"&gt;Tillie&lt;/a&gt;;and they lived at the bottom of a well.&lt;/p&gt;&lt;p class=\"story\"&gt;...&lt;/p&gt;\"\"\"from bs4 import BeautifulSoupsoup = BeautifulSoup(html, 'lxml')print(soup.p.string) The Dormouse&apos;s story 嵌套选择1234567891011121314html = \"\"\"&lt;html&gt;&lt;head&gt;&lt;title&gt;The Dormouse's story&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;p class=\"title\" name=\"dromouse\"&gt;&lt;b&gt;The Dormouse's story&lt;/b&gt;&lt;/p&gt;&lt;p class=\"story\"&gt;Once upon a time there were three little sisters; and their names were&lt;a href=\"http://example.com/elsie\" class=\"sister\" id=\"link1\"&gt;&lt;!-- Elsie --&gt;&lt;/a&gt;,&lt;a href=\"http://example.com/lacie\" class=\"sister\" id=\"link2\"&gt;Lacie&lt;/a&gt; and&lt;a href=\"http://example.com/tillie\" class=\"sister\" id=\"link3\"&gt;Tillie&lt;/a&gt;;and they lived at the bottom of a well.&lt;/p&gt;&lt;p class=\"story\"&gt;...&lt;/p&gt;\"\"\"from bs4 import BeautifulSoupsoup = BeautifulSoup(html, 'lxml')print(soup.head.title.string) The Dormouse&apos;s story 子节点和子孙节点123456789101112131415161718192021html = \"\"\"&lt;html&gt; &lt;head&gt; &lt;title&gt;The Dormouse's story&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;p class=\"story\"&gt; Once upon a time there were three little sisters; and their names were &lt;a href=\"http://example.com/elsie\" class=\"sister\" id=\"link1\"&gt; &lt;span&gt;Elsie&lt;/span&gt; &lt;/a&gt; &lt;a href=\"http://example.com/lacie\" class=\"sister\" id=\"link2\"&gt;Lacie&lt;/a&gt; and &lt;a href=\"http://example.com/tillie\" class=\"sister\" id=\"link3\"&gt;Tillie&lt;/a&gt; and they lived at the bottom of a well. &lt;/p&gt; &lt;p class=\"story\"&gt;...&lt;/p&gt;\"\"\"from bs4 import BeautifulSoupsoup = BeautifulSoup(html, 'lxml')print(soup.p.contents) [&apos;\\n Once upon a time there were three little sisters; and their names were\\n &apos;, &lt;a class=&quot;sister&quot; href=&quot;http://example.com/elsie&quot; id=&quot;link1&quot;&gt; &lt;span&gt;Elsie&lt;/span&gt; &lt;/a&gt;, &apos;\\n&apos;, &lt;a class=&quot;sister&quot; href=&quot;http://example.com/lacie&quot; id=&quot;link2&quot;&gt;Lacie&lt;/a&gt;, &apos; \\n and\\n &apos;, &lt;a class=&quot;sister&quot; href=&quot;http://example.com/tillie&quot; id=&quot;link3&quot;&gt;Tillie&lt;/a&gt;, &apos;\\n and they lived at the bottom of a well.\\n &apos;] 1234567891011121314151617181920212223html = \"\"\"&lt;html&gt; &lt;head&gt; &lt;title&gt;The Dormouse's story&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;p class=\"story\"&gt; Once upon a time there were three little sisters; and their names were &lt;a href=\"http://example.com/elsie\" class=\"sister\" id=\"link1\"&gt; &lt;span&gt;Elsie&lt;/span&gt; &lt;/a&gt; &lt;a href=\"http://example.com/lacie\" class=\"sister\" id=\"link2\"&gt;Lacie&lt;/a&gt; and &lt;a href=\"http://example.com/tillie\" class=\"sister\" id=\"link3\"&gt;Tillie&lt;/a&gt; and they lived at the bottom of a well. &lt;/p&gt; &lt;p class=\"story\"&gt;...&lt;/p&gt;\"\"\"from bs4 import BeautifulSoupsoup = BeautifulSoup(html, 'lxml')print(soup.p.children)for i, child in enumerate(soup.p.children): print(i, child) &lt;list_iterator object at 0x1064f7dd8&gt; 0 Once upon a time there were three little sisters; and their names were 1 &lt;a class=&quot;sister&quot; href=&quot;http://example.com/elsie&quot; id=&quot;link1&quot;&gt; &lt;span&gt;Elsie&lt;/span&gt; &lt;/a&gt; 2 3 &lt;a class=&quot;sister&quot; href=&quot;http://example.com/lacie&quot; id=&quot;link2&quot;&gt;Lacie&lt;/a&gt; 4 and 5 &lt;a class=&quot;sister&quot; href=&quot;http://example.com/tillie&quot; id=&quot;link3&quot;&gt;Tillie&lt;/a&gt; 6 and they lived at the bottom of a well. 1234567891011121314151617181920212223html = \"\"\"&lt;html&gt; &lt;head&gt; &lt;title&gt;The Dormouse's story&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;p class=\"story\"&gt; Once upon a time there were three little sisters; and their names were &lt;a href=\"http://example.com/elsie\" class=\"sister\" id=\"link1\"&gt; &lt;span&gt;Elsie&lt;/span&gt; &lt;/a&gt; &lt;a href=\"http://example.com/lacie\" class=\"sister\" id=\"link2\"&gt;Lacie&lt;/a&gt; and &lt;a href=\"http://example.com/tillie\" class=\"sister\" id=\"link3\"&gt;Tillie&lt;/a&gt; and they lived at the bottom of a well. &lt;/p&gt; &lt;p class=\"story\"&gt;...&lt;/p&gt;\"\"\"from bs4 import BeautifulSoupsoup = BeautifulSoup(html, 'lxml')print(soup.p.descendants)for i, child in enumerate(soup.p.descendants): print(i, child) &lt;generator object descendants at 0x10650e678&gt; 0 Once upon a time there were three little sisters; and their names were 1 &lt;a class=&quot;sister&quot; href=&quot;http://example.com/elsie&quot; id=&quot;link1&quot;&gt; &lt;span&gt;Elsie&lt;/span&gt; &lt;/a&gt; 2 3 &lt;span&gt;Elsie&lt;/span&gt; 4 Elsie 5 6 7 &lt;a class=&quot;sister&quot; href=&quot;http://example.com/lacie&quot; id=&quot;link2&quot;&gt;Lacie&lt;/a&gt; 8 Lacie 9 and 10 &lt;a class=&quot;sister&quot; href=&quot;http://example.com/tillie&quot; id=&quot;link3&quot;&gt;Tillie&lt;/a&gt; 11 Tillie 12 and they lived at the bottom of a well. 父节点和祖先节点123456789101112131415161718192021html = \"\"\"&lt;html&gt; &lt;head&gt; &lt;title&gt;The Dormouse's story&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;p class=\"story\"&gt; Once upon a time there were three little sisters; and their names were &lt;a href=\"http://example.com/elsie\" class=\"sister\" id=\"link1\"&gt; &lt;span&gt;Elsie&lt;/span&gt; &lt;/a&gt; &lt;a href=\"http://example.com/lacie\" class=\"sister\" id=\"link2\"&gt;Lacie&lt;/a&gt; and &lt;a href=\"http://example.com/tillie\" class=\"sister\" id=\"link3\"&gt;Tillie&lt;/a&gt; and they lived at the bottom of a well. &lt;/p&gt; &lt;p class=\"story\"&gt;...&lt;/p&gt;\"\"\"from bs4 import BeautifulSoupsoup = BeautifulSoup(html, 'lxml')print(soup.a.parent) &lt;p class=&quot;story&quot;&gt; Once upon a time there were three little sisters; and their names were &lt;a class=&quot;sister&quot; href=&quot;http://example.com/elsie&quot; id=&quot;link1&quot;&gt; &lt;span&gt;Elsie&lt;/span&gt; &lt;/a&gt; &lt;a class=&quot;sister&quot; href=&quot;http://example.com/lacie&quot; id=&quot;link2&quot;&gt;Lacie&lt;/a&gt; and &lt;a class=&quot;sister&quot; href=&quot;http://example.com/tillie&quot; id=&quot;link3&quot;&gt;Tillie&lt;/a&gt; and they lived at the bottom of a well. &lt;/p&gt; 123456789101112131415161718192021html = \"\"\"&lt;html&gt; &lt;head&gt; &lt;title&gt;The Dormouse's story&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;p class=\"story\"&gt; Once upon a time there were three little sisters; and their names were &lt;a href=\"http://example.com/elsie\" class=\"sister\" id=\"link1\"&gt; &lt;span&gt;Elsie&lt;/span&gt; &lt;/a&gt; &lt;a href=\"http://example.com/lacie\" class=\"sister\" id=\"link2\"&gt;Lacie&lt;/a&gt; and &lt;a href=\"http://example.com/tillie\" class=\"sister\" id=\"link3\"&gt;Tillie&lt;/a&gt; and they lived at the bottom of a well. &lt;/p&gt; &lt;p class=\"story\"&gt;...&lt;/p&gt;\"\"\"from bs4 import BeautifulSoupsoup = BeautifulSoup(html, 'lxml')print(list(enumerate(soup.a.parents))) [(0, &lt;p class=&quot;story&quot;&gt; Once upon a time there were three little sisters; and their names were &lt;a class=&quot;sister&quot; href=&quot;http://example.com/elsie&quot; id=&quot;link1&quot;&gt; &lt;span&gt;Elsie&lt;/span&gt; &lt;/a&gt; &lt;a class=&quot;sister&quot; href=&quot;http://example.com/lacie&quot; id=&quot;link2&quot;&gt;Lacie&lt;/a&gt; and &lt;a class=&quot;sister&quot; href=&quot;http://example.com/tillie&quot; id=&quot;link3&quot;&gt;Tillie&lt;/a&gt; and they lived at the bottom of a well. &lt;/p&gt;), (1, &lt;body&gt; &lt;p class=&quot;story&quot;&gt; Once upon a time there were three little sisters; and their names were &lt;a class=&quot;sister&quot; href=&quot;http://example.com/elsie&quot; id=&quot;link1&quot;&gt; &lt;span&gt;Elsie&lt;/span&gt; &lt;/a&gt; &lt;a class=&quot;sister&quot; href=&quot;http://example.com/lacie&quot; id=&quot;link2&quot;&gt;Lacie&lt;/a&gt; and &lt;a class=&quot;sister&quot; href=&quot;http://example.com/tillie&quot; id=&quot;link3&quot;&gt;Tillie&lt;/a&gt; and they lived at the bottom of a well. &lt;/p&gt; &lt;p class=&quot;story&quot;&gt;...&lt;/p&gt; &lt;/body&gt;), (2, &lt;html&gt; &lt;head&gt; &lt;title&gt;The Dormouse&apos;s story&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;p class=&quot;story&quot;&gt; Once upon a time there were three little sisters; and their names were &lt;a class=&quot;sister&quot; href=&quot;http://example.com/elsie&quot; id=&quot;link1&quot;&gt; &lt;span&gt;Elsie&lt;/span&gt; &lt;/a&gt; &lt;a class=&quot;sister&quot; href=&quot;http://example.com/lacie&quot; id=&quot;link2&quot;&gt;Lacie&lt;/a&gt; and &lt;a class=&quot;sister&quot; href=&quot;http://example.com/tillie&quot; id=&quot;link3&quot;&gt;Tillie&lt;/a&gt; and they lived at the bottom of a well. &lt;/p&gt; &lt;p class=&quot;story&quot;&gt;...&lt;/p&gt; &lt;/body&gt;&lt;/html&gt;), (3, &lt;html&gt; &lt;head&gt; &lt;title&gt;The Dormouse&apos;s story&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;p class=&quot;story&quot;&gt; Once upon a time there were three little sisters; and their names were &lt;a class=&quot;sister&quot; href=&quot;http://example.com/elsie&quot; id=&quot;link1&quot;&gt; &lt;span&gt;Elsie&lt;/span&gt; &lt;/a&gt; &lt;a class=&quot;sister&quot; href=&quot;http://example.com/lacie&quot; id=&quot;link2&quot;&gt;Lacie&lt;/a&gt; and &lt;a class=&quot;sister&quot; href=&quot;http://example.com/tillie&quot; id=&quot;link3&quot;&gt;Tillie&lt;/a&gt; and they lived at the bottom of a well. &lt;/p&gt; &lt;p class=&quot;story&quot;&gt;...&lt;/p&gt; &lt;/body&gt;&lt;/html&gt;)] 兄弟节点12345678910111213141516171819202122html = \"\"\"&lt;html&gt; &lt;head&gt; &lt;title&gt;The Dormouse's story&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;p class=\"story\"&gt; Once upon a time there were three little sisters; and their names were &lt;a href=\"http://example.com/elsie\" class=\"sister\" id=\"link1\"&gt; &lt;span&gt;Elsie&lt;/span&gt; &lt;/a&gt; &lt;a href=\"http://example.com/lacie\" class=\"sister\" id=\"link2\"&gt;Lacie&lt;/a&gt; and &lt;a href=\"http://example.com/tillie\" class=\"sister\" id=\"link3\"&gt;Tillie&lt;/a&gt; and they lived at the bottom of a well. &lt;/p&gt; &lt;p class=\"story\"&gt;...&lt;/p&gt;\"\"\"from bs4 import BeautifulSoupsoup = BeautifulSoup(html, 'lxml')print(list(enumerate(soup.a.next_siblings)))print(list(enumerate(soup.a.previous_siblings))) [(0, &apos;\\n&apos;), (1, &lt;a class=&quot;sister&quot; href=&quot;http://example.com/lacie&quot; id=&quot;link2&quot;&gt;Lacie&lt;/a&gt;), (2, &apos; \\n and\\n &apos;), (3, &lt;a class=&quot;sister&quot; href=&quot;http://example.com/tillie&quot; id=&quot;link3&quot;&gt;Tillie&lt;/a&gt;), (4, &apos;\\n and they lived at the bottom of a well.\\n &apos;)] [(0, &apos;\\n Once upon a time there were three little sisters; and their names were\\n &apos;)] 标准选择器find_all( name , attrs , recursive , text , **kwargs )可根据标签名、属性、内容查找文档 name12345678910111213141516171819202122html='''&lt;div class=\"panel\"&gt; &lt;div class=\"panel-heading\"&gt; &lt;h4&gt;Hello&lt;/h4&gt; &lt;/div&gt; &lt;div class=\"panel-body\"&gt; &lt;ul class=\"list\" id=\"list-1\"&gt; &lt;li class=\"element\"&gt;Foo&lt;/li&gt; &lt;li class=\"element\"&gt;Bar&lt;/li&gt; &lt;li class=\"element\"&gt;Jay&lt;/li&gt; &lt;/ul&gt; &lt;ul class=\"list list-small\" id=\"list-2\"&gt; &lt;li class=\"element\"&gt;Foo&lt;/li&gt; &lt;li class=\"element\"&gt;Bar&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/div&gt;'''from bs4 import BeautifulSoupsoup = BeautifulSoup(html, 'lxml')print(soup.find_all('ul'))print(type(soup.find_all('ul')[0])) [&lt;ul class=&quot;list&quot; id=&quot;list-1&quot;&gt; &lt;li class=&quot;element&quot;&gt;Foo&lt;/li&gt; &lt;li class=&quot;element&quot;&gt;Bar&lt;/li&gt; &lt;li class=&quot;element&quot;&gt;Jay&lt;/li&gt; &lt;/ul&gt;, &lt;ul class=&quot;list list-small&quot; id=&quot;list-2&quot;&gt; &lt;li class=&quot;element&quot;&gt;Foo&lt;/li&gt; &lt;li class=&quot;element&quot;&gt;Bar&lt;/li&gt; &lt;/ul&gt;] &lt;class &apos;bs4.element.Tag&apos;&gt; 12345678910111213141516171819202122html='''&lt;div class=\"panel\"&gt; &lt;div class=\"panel-heading\"&gt; &lt;h4&gt;Hello&lt;/h4&gt; &lt;/div&gt; &lt;div class=\"panel-body\"&gt; &lt;ul class=\"list\" id=\"list-1\"&gt; &lt;li class=\"element\"&gt;Foo&lt;/li&gt; &lt;li class=\"element\"&gt;Bar&lt;/li&gt; &lt;li class=\"element\"&gt;Jay&lt;/li&gt; &lt;/ul&gt; &lt;ul class=\"list list-small\" id=\"list-2\"&gt; &lt;li class=\"element\"&gt;Foo&lt;/li&gt; &lt;li class=\"element\"&gt;Bar&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/div&gt;'''from bs4 import BeautifulSoupsoup = BeautifulSoup(html, 'lxml')for ul in soup.find_all('ul'): print(ul.find_all('li')) [&lt;li class=&quot;element&quot;&gt;Foo&lt;/li&gt;, &lt;li class=&quot;element&quot;&gt;Bar&lt;/li&gt;, &lt;li class=&quot;element&quot;&gt;Jay&lt;/li&gt;] [&lt;li class=&quot;element&quot;&gt;Foo&lt;/li&gt;, &lt;li class=&quot;element&quot;&gt;Bar&lt;/li&gt;] attrs12345678910111213141516171819202122html='''&lt;div class=\"panel\"&gt; &lt;div class=\"panel-heading\"&gt; &lt;h4&gt;Hello&lt;/h4&gt; &lt;/div&gt; &lt;div class=\"panel-body\"&gt; &lt;ul class=\"list\" id=\"list-1\" name=\"elements\"&gt; &lt;li class=\"element\"&gt;Foo&lt;/li&gt; &lt;li class=\"element\"&gt;Bar&lt;/li&gt; &lt;li class=\"element\"&gt;Jay&lt;/li&gt; &lt;/ul&gt; &lt;ul class=\"list list-small\" id=\"list-2\"&gt; &lt;li class=\"element\"&gt;Foo&lt;/li&gt; &lt;li class=\"element\"&gt;Bar&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/div&gt;'''from bs4 import BeautifulSoupsoup = BeautifulSoup(html, 'lxml')print(soup.find_all(attrs=&#123;'id': 'list-1'&#125;))print(soup.find_all(attrs=&#123;'name': 'elements'&#125;)) [&lt;ul class=&quot;list&quot; id=&quot;list-1&quot; name=&quot;elements&quot;&gt; &lt;li class=&quot;element&quot;&gt;Foo&lt;/li&gt; &lt;li class=&quot;element&quot;&gt;Bar&lt;/li&gt; &lt;li class=&quot;element&quot;&gt;Jay&lt;/li&gt; &lt;/ul&gt;] [&lt;ul class=&quot;list&quot; id=&quot;list-1&quot; name=&quot;elements&quot;&gt; &lt;li class=&quot;element&quot;&gt;Foo&lt;/li&gt; &lt;li class=&quot;element&quot;&gt;Bar&lt;/li&gt; &lt;li class=&quot;element&quot;&gt;Jay&lt;/li&gt; &lt;/ul&gt;] 12345678910111213141516171819202122html='''&lt;div class=\"panel\"&gt; &lt;div class=\"panel-heading\"&gt; &lt;h4&gt;Hello&lt;/h4&gt; &lt;/div&gt; &lt;div class=\"panel-body\"&gt; &lt;ul class=\"list\" id=\"list-1\"&gt; &lt;li class=\"element\"&gt;Foo&lt;/li&gt; &lt;li class=\"element\"&gt;Bar&lt;/li&gt; &lt;li class=\"element\"&gt;Jay&lt;/li&gt; &lt;/ul&gt; &lt;ul class=\"list list-small\" id=\"list-2\"&gt; &lt;li class=\"element\"&gt;Foo&lt;/li&gt; &lt;li class=\"element\"&gt;Bar&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/div&gt;'''from bs4 import BeautifulSoupsoup = BeautifulSoup(html, 'lxml')print(soup.find_all(id='list-1'))print(soup.find_all(class_='element')) [&lt;ul class=&quot;list&quot; id=&quot;list-1&quot;&gt; &lt;li class=&quot;element&quot;&gt;Foo&lt;/li&gt; &lt;li class=&quot;element&quot;&gt;Bar&lt;/li&gt; &lt;li class=&quot;element&quot;&gt;Jay&lt;/li&gt; &lt;/ul&gt;] [&lt;li class=&quot;element&quot;&gt;Foo&lt;/li&gt;, &lt;li class=&quot;element&quot;&gt;Bar&lt;/li&gt;, &lt;li class=&quot;element&quot;&gt;Jay&lt;/li&gt;, &lt;li class=&quot;element&quot;&gt;Foo&lt;/li&gt;, &lt;li class=&quot;element&quot;&gt;Bar&lt;/li&gt;] text123456789101112131415161718192021html='''&lt;div class=\"panel\"&gt; &lt;div class=\"panel-heading\"&gt; &lt;h4&gt;Hello&lt;/h4&gt; &lt;/div&gt; &lt;div class=\"panel-body\"&gt; &lt;ul class=\"list\" id=\"list-1\"&gt; &lt;li class=\"element\"&gt;Foo&lt;/li&gt; &lt;li class=\"element\"&gt;Bar&lt;/li&gt; &lt;li class=\"element\"&gt;Jay&lt;/li&gt; &lt;/ul&gt; &lt;ul class=\"list list-small\" id=\"list-2\"&gt; &lt;li class=\"element\"&gt;Foo&lt;/li&gt; &lt;li class=\"element\"&gt;Bar&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/div&gt;'''from bs4 import BeautifulSoupsoup = BeautifulSoup(html, 'lxml')print(soup.find_all(text='Foo')) [&apos;Foo&apos;, &apos;Foo&apos;] find( name , attrs , recursive , text , **kwargs )find返回单个元素，find_all返回所有元素 1234567891011121314151617181920212223html='''&lt;div class=\"panel\"&gt; &lt;div class=\"panel-heading\"&gt; &lt;h4&gt;Hello&lt;/h4&gt; &lt;/div&gt; &lt;div class=\"panel-body\"&gt; &lt;ul class=\"list\" id=\"list-1\"&gt; &lt;li class=\"element\"&gt;Foo&lt;/li&gt; &lt;li class=\"element\"&gt;Bar&lt;/li&gt; &lt;li class=\"element\"&gt;Jay&lt;/li&gt; &lt;/ul&gt; &lt;ul class=\"list list-small\" id=\"list-2\"&gt; &lt;li class=\"element\"&gt;Foo&lt;/li&gt; &lt;li class=\"element\"&gt;Bar&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/div&gt;'''from bs4 import BeautifulSoupsoup = BeautifulSoup(html, 'lxml')print(soup.find('ul'))print(type(soup.find('ul')))print(soup.find('page')) &lt;ul class=&quot;list&quot; id=&quot;list-1&quot;&gt; &lt;li class=&quot;element&quot;&gt;Foo&lt;/li&gt; &lt;li class=&quot;element&quot;&gt;Bar&lt;/li&gt; &lt;li class=&quot;element&quot;&gt;Jay&lt;/li&gt; &lt;/ul&gt; &lt;class &apos;bs4.element.Tag&apos;&gt; None find_parents() find_parent()find_parents()返回所有祖先节点，find_parent()返回直接父节点。 find_next_siblings() find_next_sibling()find_next_siblings()返回后面所有兄弟节点，find_next_sibling()返回后面第一个兄弟节点。 find_previous_siblings() find_previous_sibling()find_previous_siblings()返回前面所有兄弟节点，find_previous_sibling()返回前面第一个兄弟节点。 find_all_next() find_next()find_all_next()返回节点后所有符合条件的节点, find_next()返回第一个符合条件的节点 find_all_previous() 和 find_previous()find_all_previous()返回节点后所有符合条件的节点, find_previous()返回第一个符合条件的节点 CSS选择器通过select()直接传入CSS选择器即可完成选择 123456789101112131415161718192021222324html='''&lt;div class=\"panel\"&gt; &lt;div class=\"panel-heading\"&gt; &lt;h4&gt;Hello&lt;/h4&gt; &lt;/div&gt; &lt;div class=\"panel-body\"&gt; &lt;ul class=\"list\" id=\"list-1\"&gt; &lt;li class=\"element\"&gt;Foo&lt;/li&gt; &lt;li class=\"element\"&gt;Bar&lt;/li&gt; &lt;li class=\"element\"&gt;Jay&lt;/li&gt; &lt;/ul&gt; &lt;ul class=\"list list-small\" id=\"list-2\"&gt; &lt;li class=\"element\"&gt;Foo&lt;/li&gt; &lt;li class=\"element\"&gt;Bar&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/div&gt;'''from bs4 import BeautifulSoupsoup = BeautifulSoup(html, 'lxml')print(soup.select('.panel .panel-heading'))print(soup.select('ul li'))print(soup.select('#list-2 .element'))print(type(soup.select('ul')[0])) [&lt;div class=&quot;panel-heading&quot;&gt; &lt;h4&gt;Hello&lt;/h4&gt; &lt;/div&gt;] [&lt;li class=&quot;element&quot;&gt;Foo&lt;/li&gt;, &lt;li class=&quot;element&quot;&gt;Bar&lt;/li&gt;, &lt;li class=&quot;element&quot;&gt;Jay&lt;/li&gt;, &lt;li class=&quot;element&quot;&gt;Foo&lt;/li&gt;, &lt;li class=&quot;element&quot;&gt;Bar&lt;/li&gt;] [&lt;li class=&quot;element&quot;&gt;Foo&lt;/li&gt;, &lt;li class=&quot;element&quot;&gt;Bar&lt;/li&gt;] &lt;class &apos;bs4.element.Tag&apos;&gt; 12345678910111213141516171819202122html='''&lt;div class=\"panel\"&gt; &lt;div class=\"panel-heading\"&gt; &lt;h4&gt;Hello&lt;/h4&gt; &lt;/div&gt; &lt;div class=\"panel-body\"&gt; &lt;ul class=\"list\" id=\"list-1\"&gt; &lt;li class=\"element\"&gt;Foo&lt;/li&gt; &lt;li class=\"element\"&gt;Bar&lt;/li&gt; &lt;li class=\"element\"&gt;Jay&lt;/li&gt; &lt;/ul&gt; &lt;ul class=\"list list-small\" id=\"list-2\"&gt; &lt;li class=\"element\"&gt;Foo&lt;/li&gt; &lt;li class=\"element\"&gt;Bar&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/div&gt;'''from bs4 import BeautifulSoupsoup = BeautifulSoup(html, 'lxml')for ul in soup.select('ul'): print(ul.select('li')) [&lt;li class=&quot;element&quot;&gt;Foo&lt;/li&gt;, &lt;li class=&quot;element&quot;&gt;Bar&lt;/li&gt;, &lt;li class=&quot;element&quot;&gt;Jay&lt;/li&gt;] [&lt;li class=&quot;element&quot;&gt;Foo&lt;/li&gt;, &lt;li class=&quot;element&quot;&gt;Bar&lt;/li&gt;] 获取属性1234567891011121314151617181920212223html='''&lt;div class=\"panel\"&gt; &lt;div class=\"panel-heading\"&gt; &lt;h4&gt;Hello&lt;/h4&gt; &lt;/div&gt; &lt;div class=\"panel-body\"&gt; &lt;ul class=\"list\" id=\"list-1\"&gt; &lt;li class=\"element\"&gt;Foo&lt;/li&gt; &lt;li class=\"element\"&gt;Bar&lt;/li&gt; &lt;li class=\"element\"&gt;Jay&lt;/li&gt; &lt;/ul&gt; &lt;ul class=\"list list-small\" id=\"list-2\"&gt; &lt;li class=\"element\"&gt;Foo&lt;/li&gt; &lt;li class=\"element\"&gt;Bar&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/div&gt;'''from bs4 import BeautifulSoupsoup = BeautifulSoup(html, 'lxml')for ul in soup.select('ul'): print(ul['id']) print(ul.attrs['id']) list-1 list-1 list-2 list-2 获取内容12345678910111213141516171819202122html='''&lt;div class=\"panel\"&gt; &lt;div class=\"panel-heading\"&gt; &lt;h4&gt;Hello&lt;/h4&gt; &lt;/div&gt; &lt;div class=\"panel-body\"&gt; &lt;ul class=\"list\" id=\"list-1\"&gt; &lt;li class=\"element\"&gt;Foo&lt;/li&gt; &lt;li class=\"element\"&gt;Bar&lt;/li&gt; &lt;li class=\"element\"&gt;Jay&lt;/li&gt; &lt;/ul&gt; &lt;ul class=\"list list-small\" id=\"list-2\"&gt; &lt;li class=\"element\"&gt;Foo&lt;/li&gt; &lt;li class=\"element\"&gt;Bar&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/div&gt;'''from bs4 import BeautifulSoupsoup = BeautifulSoup(html, 'lxml')for li in soup.select('li'): print(li.get_text()) Foo Bar Jay Foo Bar 总结 推荐使用lxml解析库，必要时使用html.parser 标签选择筛选功能弱但是速度快 建议使用find()、find_all() 查询匹配单个结果或者多个结果 如果对CSS选择器熟悉建议使用select() 记住常用的获取属性和文本值的方法","tags":[{"name":"python","slug":"python","permalink":"http://kingle.online/tags/python/"},{"name":"BeautifulSoup","slug":"BeautifulSoup","permalink":"http://kingle.online/tags/BeautifulSoup/"}]},{"title":"python进阶与强化note3","date":"2018-03-18T15:19:40.000Z","path":"2018/03/18/python进阶与强化note3/","text":"note3拆分字符串123456789101112131415161718# 普通拆分，可以使用map函数s = 'ab;cd|efg|hi,jkl|mn\\topq;rst,uvw\\txyz'res = s.split(';')t = []# 将res中的每一项用|分隔符，分割之后，添加到t列表中去map(lambda x: t.extend(x.split('|')), res)#总结为一个函数def mySplit(s, ds): res = [s] for d in ds: t = [] map(lambda x: t.extend(x.split(d)), res) res = t return [x for x in res if x]s = 'ab;cd|efg|hi,jkl|mn\\topq;rst,uvw\\txyz'mySplit(s, ';|,\\t') 直接使用正则表达式123import re# 速度慢一些re.split(r'[,;\\t|]+', s) 如何判断字符串是否以a开头或结尾使用s.endswith()和s.startswith()123456import os, stat#os.listdir('.')l = [name for name in os.listdir('.') if name.endswith(('.sh', '.py'))]for f in l: # 改变文件权限 os.chmod(f, os.stat(f).st_mode | stat.S_IXUSR) 如何调整字符串中文本的格式123456import relog = open('/var/log/dpkg.log').read()# 将2015-02-28格式转换为02/28/2015re.sub('(\\d&#123;4&#125;)-(\\d&#123;2&#125;)-(\\d&#123;2&#125;)', r'\\2/\\3/\\1', log)# 起别名# print(re.sub('(?P&lt;year&gt;\\d&#123;4&#125;)-(?P&lt;month&gt;\\d&#123;2&#125;)-(?P&lt;day&gt;\\d&#123;2&#125;)',r'\\g&lt;month&gt;/\\g&lt;day&gt;/\\g&lt;year&gt;',log)) 如何将多个小字符串拼接成一个大的字符串12345678910111213pl = [\"&lt;0112&gt;\", \"&lt;32&gt;\", \"&lt;1024*768&gt;\", \"&lt;10&gt;\", \"&lt;1&gt;\", \"&lt;100.0&gt;\", \"&lt;500.0&gt;\"]s = ''# 存在浪费for p in pl: s += p# ';'.join(['abc', '123', 'xyz'])# 'abc;123;xyz'# 不存在浪费，推荐''.join(pl)# l = ['abc', 123, 45, 'xyz']# ''.join([str(x) for x in l])# 元组的括号省略了，生成器比列表解析更节省空间# ''.join(str(x) for x in l) 如何对字符串进行左右，居中对齐使用str.ljust(), str.rjust(), str.center()12s.ljust(20, '=')# 'abc=================' 使用format函数123456# 左对齐format(s, '&lt;20')# 右对齐format(s, '&gt;20')# 居中对齐format(s, '^20') 如何去掉字符串中不需要的字符 使用strip()12345678s = ' abc dd ca '# 去掉两端的空白，保留中间的空白s.strip()s.lstrip()s.rstrip()# 去掉符号s = '----abc+++'s.strip('-+') 使用切片拼接12s = 'abc:123's[:3] + s[4:] 利用正则表达式1234567s = '\\tabc\\t123\\txyz'# 只能替换一种s.replace('\\t', '')# 替换多种import res = '\\tabc\\t123\\txyz\\r're.sub('[\\t\\r]', '', s) 使用translate()123456s = 'abc1345xyz'import string # 使用string生成映射表s.translate(string.maketrans('abcxyz', 'xyzabc'))s = 'abc\\tkdjfk\\n's.translate(None, '\\t\\n')","tags":[{"name":"python","slug":"python","permalink":"http://kingle.online/tags/python/"}]},{"title":"百度云限速解决办法:支持Windows和Mac","date":"2018-03-13T14:30:01.000Z","path":"2018/03/13/百度云限速解决办法-支持Windows和Mac/","text":"安装说明本软件需要安装浏览器插件和客户端 下载地址链接：https://share.weiyun.com/d10ce31c7b58645340c3d8ac85cfae0a 密码：n3k2tn 浏览器插件安装 下载包解压 在 Chrome 地址栏输入 chrome://extensions/ 以打开扩展程序管理页面 顶部勾选“开发者模式”，再点击“加载已解压的扩展程序…”，路径为刚才的解压目录 客户端安装 mac:正常安装即可。 windows(32位/64位)免安装:下载解压打开downloader.exe 使用说明效果图 使用方法 安装高速下载器客户端和浏览器插件 打开百度网盘点击高速下载即可 在弹出的对话框中点击立即下载 下载页面 项目链接：https://github.com/high-speed-downloader/high-speed-downloader","tags":[{"name":"百度云","slug":"百度云","permalink":"http://kingle.online/tags/百度云/"}]},{"title":"Requests库详解","date":"2018-03-02T17:27:05.000Z","path":"2018/03/03/Requests库详解/","text":"requests实例引入12345678import requestsresponse = requests.get('https://www.baidu.com/')print(type(response))print(response.status_code)print(type(response.text))print(response.text)print(response.cookies) 各种请求方式123456import requestsrequests.post('http://httpbin.org/post')requests.put('http://httpbin.org/put')requests.delete('http://httpbin.org/delete')requests.head('http://httpbin.org/get')requests.options('http://httpbin.org/get') 请求基本GET请求基本写法1234import requestsresponse = requests.get('http://httpbin.org/get')print(response.text) 带参数GET请求123import requestsresponse = requests.get(\"http://httpbin.org/get?name=germey&amp;age=22\")print(response.text) 12345678import requestsdata = &#123; 'name': 'germey', 'age': 22&#125;response = requests.get(\"http://httpbin.org/get\", params=data)print(response.text) 解析json12345678import requestsimport jsonresponse = requests.get(\"http://httpbin.org/get\")print(type(response.text))print(response.json())print(json.loads(response.text))print(type(response.json())) 获取二进制数据123456import requestsresponse = requests.get(\"https://github.com/favicon.ico\")print(type(response.text), type(response.content))print(response.text)print(response.content) 123456import requestsresponse = requests.get(\"https://github.com/favicon.ico\")with open('favicon.ico', 'wb') as f: f.write(response.content) f.close() 添加headers1234import requestsresponse = requests.get(\"https://www.zhihu.com/explore\")print(response.text) 1234567import requestsheaders = &#123; 'User-Agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_4) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/52.0.2743.116 Safari/537.36'&#125;response = requests.get(\"https://www.zhihu.com/explore\", headers=headers)print(response.text) 基本POST请求12345import requestsdata = &#123;'name': 'germey', 'age': '22'&#125;response = requests.post(\"http://httpbin.org/post\", data=data)print(response.text) 12345678import requestsdata = &#123;'name': 'germey', 'age': '22'&#125;headers = &#123; 'User-Agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_4) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/52.0.2743.116 Safari/537.36'&#125;response = requests.post(\"http://httpbin.org/post\", data=data, headers=headers)print(response.json()) 响应reponse属性12345678import requestsresponse = requests.get('http://www.jianshu.com')print(type(response.status_code), response.status_code)print(type(response.headers), response.headers)print(type(response.cookies), response.cookies)print(type(response.url), response.url)print(type(response.history), response.history) 状态码判断1234import requestsresponse = requests.get('http://www.jianshu.com/hello.html')exit() if not response.status_code == requests.codes.not_found else print('404 Not Found') 1234import requestsresponse = requests.get('http://www.jianshu.com')exit() if not response.status_code == 200 else print('Request Successfully') 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475100: ('continue',),101: ('switching_protocols',),102: ('processing',),103: ('checkpoint',),122: ('uri_too_long', 'request_uri_too_long'),200: ('ok', 'okay', 'all_ok', 'all_okay', 'all_good', '\\\\o/', '✓'),201: ('created',),202: ('accepted',),203: ('non_authoritative_info', 'non_authoritative_information'),204: ('no_content',),205: ('reset_content', 'reset'),206: ('partial_content', 'partial'),207: ('multi_status', 'multiple_status', 'multi_stati', 'multiple_stati'),208: ('already_reported',),226: ('im_used',),# Redirection.300: ('multiple_choices',),301: ('moved_permanently', 'moved', '\\\\o-'),302: ('found',),303: ('see_other', 'other'),304: ('not_modified',),305: ('use_proxy',),306: ('switch_proxy',),307: ('temporary_redirect', 'temporary_moved', 'temporary'),308: ('permanent_redirect', 'resume_incomplete', 'resume',), # These 2 to be removed in 3.0# Client Error.400: ('bad_request', 'bad'),401: ('unauthorized',),402: ('payment_required', 'payment'),403: ('forbidden',),404: ('not_found', '-o-'),405: ('method_not_allowed', 'not_allowed'),406: ('not_acceptable',),407: ('proxy_authentication_required', 'proxy_auth', 'proxy_authentication'),408: ('request_timeout', 'timeout'),409: ('conflict',),410: ('gone',),411: ('length_required',),412: ('precondition_failed', 'precondition'),413: ('request_entity_too_large',),414: ('request_uri_too_large',),415: ('unsupported_media_type', 'unsupported_media', 'media_type'),416: ('requested_range_not_satisfiable', 'requested_range', 'range_not_satisfiable'),417: ('expectation_failed',),418: ('im_a_teapot', 'teapot', 'i_am_a_teapot'),421: ('misdirected_request',),422: ('unprocessable_entity', 'unprocessable'),423: ('locked',),424: ('failed_dependency', 'dependency'),425: ('unordered_collection', 'unordered'),426: ('upgrade_required', 'upgrade'),428: ('precondition_required', 'precondition'),429: ('too_many_requests', 'too_many'),431: ('header_fields_too_large', 'fields_too_large'),444: ('no_response', 'none'),449: ('retry_with', 'retry'),450: ('blocked_by_windows_parental_controls', 'parental_controls'),451: ('unavailable_for_legal_reasons', 'legal_reasons'),499: ('client_closed_request',),# Server Error.500: ('internal_server_error', 'server_error', '/o\\\\', '✗'),501: ('not_implemented',),502: ('bad_gateway',),503: ('service_unavailable', 'unavailable'),504: ('gateway_timeout',),505: ('http_version_not_supported', 'http_version'),506: ('variant_also_negotiates',),507: ('insufficient_storage',),509: ('bandwidth_limit_exceeded', 'bandwidth'),510: ('not_extended',),511: ('network_authentication_required', 'network_auth', 'network_authentication'), 高级操作文件上传12345import requestsfiles = &#123;'file': open('favicon.ico', 'rb')&#125;response = requests.post(\"http://httpbin.org/post\", files=files)print(response.text) 获取cookie123456import requestsresponse = requests.get(\"https://www.baidu.com\")print(response.cookies)for key, value in response.cookies.items(): print(key + '=' + value) 会话维持模拟登录 12345import requestsrequests.get('http://httpbin.org/cookies/set/number/123456789')response = requests.get('http://httpbin.org/cookies')print(response.text) 123456import requestss = requests.Session()s.get('http://httpbin.org/cookies/set/number/123456789')response = s.get('http://httpbin.org/cookies')print(response.text) 证书验证1234import requestsresponse = requests.get('https://www.12306.cn')print(response.status_code) 12345import requestsfrom requests.packages import urllib3urllib3.disable_warnings()response = requests.get('https://www.12306.cn', verify=False)print(response.status_code) 1234import requestsresponse = requests.get('https://www.12306.cn', cert=('/path/server.crt', '/path/key'))print(response.status_code) 代理设置123456789import requestsproxies = &#123; \"http\": \"http://127.0.0.1:9743\", \"https\": \"https://127.0.0.1:9743\",&#125;response = requests.get(\"https://www.taobao.com\", proxies=proxies)print(response.status_code) 1234567import requestsproxies = &#123; \"http\": \"http://user:password@127.0.0.1:9743/\",&#125;response = requests.get(\"https://www.taobao.com\", proxies=proxies)print(response.status_code) 1pip3 install 'requests[socks]' 12345678import requestsproxies = &#123; 'http': 'socks5://127.0.0.1:9742', 'https': 'socks5://127.0.0.1:9742'&#125;response = requests.get(\"https://www.taobao.com\", proxies=proxies)print(response.status_code) 超时设置1234567import requestsfrom requests.exceptions import ReadTimeouttry: response = requests.get(\"http://httpbin.org/get\", timeout = 0.5) print(response.status_code)except ReadTimeout: print('Timeout') 认证设置12345import requestsfrom requests.auth import HTTPBasicAuthr = requests.get('http://120.27.34.24:9001', auth=HTTPBasicAuth('user', '123'))print(r.status_code) 1234import requestsr = requests.get('http://120.27.34.24:9001', auth=('user', '123'))print(r.status_code) 异常处理1234567891011import requestsfrom requests.exceptions import ReadTimeout, ConnectionError, RequestExceptiontry: response = requests.get(\"http://httpbin.org/get\", timeout = 0.5) print(response.status_code)except ReadTimeout: print('Timeout')except ConnectionError: print('Connection error')except RequestException: print('Error') Connection error","tags":[{"name":"python","slug":"python","permalink":"http://kingle.online/tags/python/"},{"name":"requests","slug":"requests","permalink":"http://kingle.online/tags/requests/"}]},{"title":"JavaScript常用API","date":"2018-01-16T21:34:42.000Z","path":"2018/01/17/JavaScript常用API合集/","text":"JavaScript常用API合集一、节点1.1 节点属性1234567891011121314151617181920Node.nodeName //返回节点名称，只读Node.nodeType //返回节点类型的常数值，只读Node.nodeValue //返回Text或Comment节点的文本值，只读Node.textContent //返回当前节点和它的所有后代节点的文本内容，可读写Node.baseURI //返回当前网页的绝对路径Node.ownerDocument //返回当前节点所在的顶层文档对象，即documentNode.nextSibling //返回紧跟在当前节点后面的第一个兄弟节点Node.previousSibling //返回当前节点前面的、距离最近的一个兄弟节点Node.parentNode //返回当前节点的父节点Node.parentElement //返回当前节点的父Element节点Node.childNodes //返回当前节点的所有子节点Node.firstChild //返回当前节点的第一个子节点Node.lastChild //返回当前节点的最后一个子节点//parentNode接口Node.children //返回指定节点的所有Element子节点Node.firstElementChild //返回当前节点的第一个Element子节点Node.lastElementChild //返回当前节点的最后一个Element子节点Node.childElementCount //返回当前节点所有Element子节点的数目。 1.2 操作12345678910111213141516ppendChild(node) //向节点添加最后一个子节点Node.hasChildNodes() //返回布尔值，表示当前节点是否有子节点Node.cloneNode(true); // 默认为false(克隆节点), true(克隆节点及其属性，以及后代)Node.insertBefore(newNode,oldNode) // 在指定子节点之前插入新的子节点Node.removeChild(node) //删除节点，在要删除节点的父节点上操作Node.replaceChild(newChild,oldChild) //替换节点Node.contains(node) //返回一个布尔值，表示参数节点是否为当前节点的后代节点。Node.compareDocumentPosition(node) //返回一个7个比特位的二进制值，表示参数节点和当前节点的关系Node.isEqualNode(noe) //返回布尔值，用于检查两个节点是否相等。所谓相等的节点，指的是两个节点的类型相同、属性相同、子节点相同。Node.normalize() //用于清理当前节点内部的所有Text节点。它会去除空的文本节点，并且将毗邻的文本节点合并成一个。//ChildNode接口Node.remove() //用于删除当前节点Node.before() //Node.after()Node.replaceWith() 1.3 Document节点1.3.1Document节点的属性12345678910111213141516171819202122232425262728document.doctype //document.documentElement //返回当前文档的根节点document.defaultView //返回document对象所在的window对象document.body //返回当前文档的&lt;body&gt;节点document.head //返回当前文档的&lt;head&gt;节点document.activeElement //返回当前文档中获得焦点的那个元素。//节点集合属性document.links //返回当前文档的所有a元素document.forms //返回页面中所有表单元素document.images //返回页面中所有图片元素document.embeds //返回网页中所有嵌入对象document.scripts //返回当前文档的所有脚本document.styleSheets //返回当前网页的所有样式表//文档信息属性document.documentURI //表示当前文档的网址document.URL //返回当前文档的网址document.domain //返回当前文档的域名document.lastModified //返回当前文档最后修改的时间戳document.location //返回location对象，提供当前文档的URL信息document.referrer //返回当前文档的访问来源document.title //返回当前文档的标题document.characterSet属性返回渲染当前文档的字符集，比如UTF-8、ISO-8859-1。document.readyState //返回当前文档的状态document.designMode //控制当前文档是否可编辑，可读写document.compatMode //返回浏览器处理文档的模式document.cookie //用来操作Cookie 1.3.2 Document节点的方法 (1)读写方法 1234document.open() //用于新建并打开一个文档document.close() //不安比open方法所新建的文档document.write() //用于向当前文档写入内容document.writeIn() //用于向当前文档写入内容，尾部添加换行符。 (2)查找节点 1234567document.querySelector(selectors) //接受一个CSS选择器作为参数，返回第一个匹配该选择器的元素节点。document.querySelectorAll(selectors) //接受一个CSS选择器作为参数，返回所有匹配该选择器的元素节点。document.getElementsByTagName(tagName) //返回所有指定HTML标签的元素document.getElementsByClassName(className) //返回包括了所有class名字符合指定条件的元素document.getElementsByName(name) //用于选择拥有name属性的HTML元素（比如&lt;form&gt;、&lt;radio&gt;、&lt;img&gt;、&lt;frame&gt;、&lt;embed&gt;和&lt;object&gt;等）document.getElementById(id) //返回匹配指定id属性的元素节点。document.elementFromPoint(x,y) //返回位于页面指定位置最上层的Element子节点。 (3)生成节点 1234document.createElement(tagName) //用来生成HTML元素节点。document.createTextNode(text) //用来生成文本节点document.createAttribute(name) //生成一个新的属性对象节点，并返回它。document.createDocumentFragment() //生成一个DocumentFragment对象 (4)事件方法 1234document.createEvent(type) //生成一个事件对象，该对象能被element.dispatchEvent()方法使用document.addEventListener(type,listener,capture) //注册事件document.removeEventListener(type,listener,capture) //注销事件document.dispatchEvent(event) //触发事件 (5)其他 123document.hasFocus() //返回一个布尔值，表示当前文档之中是否有元素被激活或获得焦点。document.adoptNode(externalNode) //将某个节点，从其原来所在的文档移除，插入当前文档，并返回插入后的新节点。document.importNode(externalNode, deep) //从外部文档拷贝指定节点，插入当前文档。 Element节点Element节点属性 (1)特性属性 12345678Element.attributes //返回当前元素节点的所有属性节点Element.id //返回指定元素的id属性，可读写Element.tagName //返回指定元素的大写标签名Element.innerHTML //返回该元素包含的HTML代码，可读写Element.outerHTML //返回指定元素节点的所有HTML代码，包括它自身和包含的的所有子元素，可读写Element.className //返回当前元素的class属性，可读写Element.classList //返回当前元素节点的所有class集合Element.dataset //返回元素节点中所有的data-*属性。 (2)尺寸属性 12345678910111213Element.clientHeight //返回元素节点可见部分的高度Element.clientWidth //返回元素节点可见部分的宽度Element.clientLeft //返回元素节点左边框的宽度Element.clientTop //返回元素节点顶部边框的宽度Element.scrollHeight //返回元素节点的总高度Element.scrollWidth //返回元素节点的总宽度Element.scrollLeft //返回元素节点的水平滚动条向右滚动的像素数值,通过设置这个属性可以改变元素的滚动位置Element.scrollTop //返回元素节点的垂直滚动向下滚动的像素数值Element.offsetHeight //返回元素的垂直高度(包含border,padding)Element.offsetWidth //返回元素的水平宽度(包含border,padding)Element.offsetLeft //返回当前元素左上角相对于Element.offsetParent节点的垂直偏移Element.offsetTop //返回水平位移Element.style //返回元素节点的行内样式 (3)节点相关属性 1234567Element.children //包括当前元素节点的所有子元素Element.childElementCount //返回当前元素节点包含的子HTML元素节点的个数Element.firstElementChild //返回当前节点的第一个Element子节点 Element.lastElementChild //返回当前节点的最后一个Element子节点 Element.nextElementSibling //返回当前元素节点的下一个兄弟HTML元素节点Element.previousElementSibling //返回当前元素节点的前一个兄弟HTML节点Element.offsetParent //返回当前元素节点的最靠近的、并且CSS的position属性不等于static的父元素。 1.4.2 Element节点的方法 (1)位置方法 1234567891011121314151617getBoundingClientRect() // getBoundingClientRect返回一个对象，包含top,left,right,bottom,width,height // width、height 元素自身宽高// top 元素上外边界距窗口最上面的距离// right 元素右外边界距窗口最上面的距离// bottom 元素下外边界距窗口最上面的距离// left 元素左外边界距窗口最上面的距离// width 元素自身宽(包含border,padding) // height 元素自身高(包含border,padding) getClientRects() //返回当前元素在页面上形参的所有矩形。// 元素在页面上的偏移量 var rect = el.getBoundingClientRect() return &#123; top: rect.top + document.body.scrollTop, left: rect.left + document.body.scrollLeft &#125; (2)属性方法 1234Element.getAttribute()：读取指定属性 Element.setAttribute()：设置指定属性 Element.hasAttribute()：返回一个布尔值，表示当前元素节点是否有指定的属性 Element.removeAttribute()：移除指定属性 (3)查找方法 1234Element.querySelector() Element.querySelectorAll() Element.getElementsByTagName() Element.getElementsByClassName() (4)事件方法 1234567891011121314151617181920Element.addEventListener()：添加事件的回调函数 Element.removeEventListener()：移除事件监听函数 Element.dispatchEvent()：触发事件//ie8Element.attachEvent(oneventName,listener)Element.detachEvent(oneventName,listener)// event对象 var event = window.event||event; // 事件的目标节点 var target = event.target || event.srcElement;// 事件代理 ul.addEventListener('click', function(event) &#123; if (event.target.tagName.toLowerCase() === 'li') &#123; console.log(event.target.innerHTML) &#125; &#125;); 其他 1234567891011Element.scrollIntoView() //滚动当前元素，进入浏览器的可见区域//解析HTML字符串，然后将生成的节点插入DOM树的指定位置。Element.insertAdjacentHTML(where, htmlString); Element.insertAdjacentHTML('beforeBegin', htmlString); // 在该元素前插入 Element.insertAdjacentHTML('afterBegin', htmlString); // 在该元素第一个子元素前插入 Element.insertAdjacentHTML('beforeEnd', htmlString); // 在该元素最后一个子元素后面插入 Element.insertAdjacentHTML('afterEnd', htmlString); // 在该元素后插入Element.remove() //用于将当前元素节点从DOM中移除Element.focus() //用于将当前页面的焦点，转移到指定元素上 CSS操作类名操作123456789101112131415161718Element.className //获取元素节点的类名Element.className += ' ' + newClassName //新增一个类名//判断是否有某个类名function hasClass(element,className)&#123; return new RegExp(className,'gi').test(element.className);&#125;//移除classfunction removeClass(element,className)&#123; element.className = element.className.replace(new RegExp('(^|\\\\b)' + className.split(' ').join('|') + '(\\\\b|$)', 'gi'),'');&#125;//ie10 element.classList.add(className) //新增element.classList.remove(className) //删除element.classList.contains(className) //是否包含element.classList.toggle(className) //toggle class sytle操作1234567891011121314151617element.setAttribute('style','')element.style.backgroundColor = 'red'element.style.cssText //用来读写或删除整个style属性element.style.setProperty(propertyName,value) //设置css属性element.style.getPropertyValue(property) //获取css属性element.style.removeProperty(property) //删除css属性操作非内联样式//ie8element.currentStyle[attrName]//ie9+window.getComputedStyle(el,null)[attrName] window.getComputedStyle(el,null).getPropertyValue(attrName)//伪类window.getComputedStyle(el,':after')[attrName] 三、对象3.1 Object对象 (1)对象实例对象 1var o = new Object(); (2)属性 1Object.prototype //返回原型对象 (3)方法 12Object.keys(o) //遍历对象的可枚举属性Object.getOwnPropertyName(o) //遍历对象不可枚举的属性 对象实例的方法 123456valueOf()：返回当前对象对应的值。 toString()：返回当前对象对应的字符串形式。 toLocaleString()：返回当前对象对应的本地字符串形式。 hasOwnProperty()：判断某个属性是否为当前对象自身的属性，还是继承自原型对象的属性。 isPrototypeOf()：判断当前对象是否为另一个对象的原型。propertyIsEnumerable()：判断某个属性是否可枚举。 3.2 Array对象 (1)生成实例对象 1var a = new Array(); (2)属性 1a.length (3) Array.isArray() 1Array.isArray(a) //用来判断一个值是否为数组 (4) Array实例的方法 12345678910111213141516171819202122a.valueof() //返回数组本身a.toString() //返回数组的字符串形式a.push(value,vlaue....) //用于在数组的末端添加一个或多个元素，并返回添加新元素后的数组长度。pop() //用于删除数组的最后一个元素，并返回该元素join() //以参数作为分隔符，将所有数组成员组成一个字符串返回。如果不提供参数，默认用逗号分隔。concat() //用于多个数组的合并。它将新数组的成员，添加到原数组的尾部，然后返回一个新数组，原数组不变。shift() //用于删除数组的第一个元素，并返回该元素。unshift(value) //用于在数组的第一个位置添加元素，并返回添加新元素后的数组长度。reverse() //用于颠倒数组中元素的顺序，返回改变后的数组slice(start_index, upto_index); //用于提取原数组的一部分，返回一个新数组，原数组不变。第一个参数为起始位置（从0开始），第二个参数为终止位置（但该位置的元素本身不包括在内）。如果省略第二个参数，则一直返回到原数组的最后一个成员。负数表示倒数第几个。splice(index, count_to_remove, addElement1, addElement2, ...); //用于删除原数组的一部分成员，并可以在被删除的位置添加入新的数组成员，返回值是被删除的元素。第一个参数是删除的起始位置，第二个参数是被删除的元素个数。如果后面还有更多的参数，则表示这些就是要被插入数组的新元素。sort() //对数组成员进行排序，默认是按照字典顺序排序。排序后，原数组将被改变。如果想让sort方法按照自定义方式排序，可以传入一个函数作为参数，表示按照自定义方法进行排序。该函数本身又接受两个参数，表示进行比较的两个元素。如果返回值大于0，表示第一个元素排在第二个元素后面；其他情况下，都是第一个元素排在第二个元素前面。map() //对数组的所有成员依次调用一个函数，根据函数结果返回一个新数组。map(elem,index,arr) //map方法接受一个函数作为参数。该函数调用时，map方法会将其传入三个参数，分别是当前成员、当前位置和数组本身。forEach() //遍历数组的所有成员，执行某种操作,参数是一个函数。它接受三个参数，分别是当前位置的值、当前位置的编号和整个数组。filter() //参数是一个函数，所有数组成员依次执行该函数，返回结果为true的成员组成一个新数组返回。该方法不会改变原数组。some() //用来判断数组成员是否符合某种条件。接受一个函数作为参数，所有数组成员依次执行该函数，返回一个布尔值。该函数接受三个参数，依次是当前位置的成员、当前位置的序号和整个数组。只要有一个数组成员的返回值是true，则整个some方法的返回值就是true，否则false。every() //用来判断数组成员是否符合某种条件。接受一个函数作为参数，所有数组成员依次执行该函数，返回一个布尔值。该函数接受三个参数，依次是当前位置的成员、当前位置的序号和整个数组。所有数组成员的返回值都是true，才返回true，否则false。reduce() //依次处理数组的每个成员，最终累计为一个值。从左到右处理（从第一个成员到最后一个成员）reduceRight() //依次处理数组的每个成员，最终累计为一个值。从右到左（从最后一个成员到第一个成员）indexOf(s) //返回给定元素在数组中第一次出现的位置，如果没有出现则返回-1。可以接受第二个参数，表示搜索的开始位置lastIndexOf() //返回给定元素在数组中最后一次出现的位置，如果没有出现则返回-1。 3.3Number对象 (1)生成对象 1var n = new Number() (2)Number对象属性 1234567Number.POSITIVE_INFINITY：正的无限，指向Infinity。 Number.NEGATIVE_INFINITY：负的无限，指向-Infinity。 Number.NaN：表示非数值，指向NaN。 Number.MAX_VALUE：表示最大的正数，相应的，最小的负数为-Number.MAX_VALUE。 Number.MIN_VALUE：表示最小的正数（即最接近0的正数，在64位浮点数体系中为5e-324），相应的，最接近0的负数为-Number.MIN_VALUE。 Number.MAX_SAFE_INTEGER：表示能够精确表示的最大整数，即9007199254740991。 Number.MIN_SAFE_INTEGER：表示能够精确表示的最小整数，即-9007199254740991。 (4)Number对象实例的方法 1234toString() //用来将一个数值转为字符串形式.可以接受一个参数，表示输出的进制。如果省略这个参数，默认将数值先转为十进制，再输出字符串；否则，就根据参数指定的进制，将一个数字转化成某个进制的字符串。toFixed() //用于将一个数转为指定位数的小数，返回这个小数对应的字符串。toExponential() //用于将一个数转为科学计数法形式。可传入一个参数，参数表示小数点后有效数字的位数，范围为0到20，超出这个范围，会抛出一个RangeError。toPrecision() //用于将一个数转为指定位数的有效数字 String对象 (1)生成实例对象 1var s = new String(); (2)String对象属性 1s.length (3)方法 1234567891011121314151617s.chatAt(index) //返回指定位置的字符s.fromCharCode() //该方法的参数是一系列Unicode码点，返回对应的字符串。s.charCodeAt(index) //返回给定位置字符的Unicode码点（十进制表示）s.concat(s2) //用于连接两个字符串s.slice(start,end) //用于从原字符串取出子字符串并返回，不改变原字符串。第一个参数是子字符串的开始位置，第二个参数是子字符串的结束位置（不含该位置）。如果参数是负值，表示从结尾开始倒数计算的位置，即该负值加上字符串长度。s.substring(start,end) //用于从原字符串取出子字符串并返回，不改变原字符串.第一个参数表示子字符串的开始位置，第二个位置表示结束位置。s.substr(start,length) //用于从原字符串取出子字符串并返回，不改变原字符串。第一个参数是子字符串的开始位置，第二个参数是子字符串的长度。如果第一个参数是负数，表示倒数计算的字符位置。如果第二个参数是负数，将被自动转为0，因此会返回空字符串。s.indexOf(s) //返回给定元素在字符串中第一次出现的位置，如果没有出现则返回-1。可以接受第二个参数，表示搜索的开始位置 s.lastIndexOf() //返回给定元素在字符串中最后一次出现的位置，如果没有出现则返回-1。s.trim() //用于去除字符串两端的空格，返回一个新字符串s.toLowerCase() //用于将一个字符串全部转为小写,返回一个新字符串，不改变原字符串。s.toUpperCase() //全部转为大写s.localeCompare(s2) //用于比较两个字符串。它返回一个整数，如果小于0，表示第一个字符串小于第二个字符串；如果等于0，表示两者相等；如果大于0，表示第一个字符串大于第二个字符串。s.match(regexp) //用于确定原字符串是否匹配某个子字符串，返回一个数组，成员为匹配的第一个字符串。如果没有找到匹配，则返回null。s.search() //返回值为匹配的第一个位置。如果没有找到匹配，则返回-1。s.replace(oldValue,newValue) //用于替换匹配的子字符串，一般情况下只替换第一个匹配（除非使用带有g修饰符的正则表达式）。s.split() //按照给定规则分割字符串，返回一个由分割出来的子字符串组成的数组。还可传入第二个参数，决定了返回数组的成员数。 3.5 Math对象 (1)属性 12345678Math.E：常数e。 Math.LN2：2的自然对数。 Math.LN10：10的自然对数。 Math.LOG2E：以2为底的e的对数。 Math.LOG10E：以10为底的e的对数。 Math.PI：常数Pi。 Math.SQRT1_2：0.5的平方根。 Math.SQRT2：2的平方根。 (2)数学方法 1234567891011Math.abs()：返回参数的绝对值 Math.ceil()：向上取整，接受一个参数，返回大于该参数的最小整数。 Math.floor()：向下取整 Math.max(n,n1,...)：可接受多个参数，返回最大值 Math.min(n,n1,..)：可接受多个参数，返回最小值 Math.pow(n,e)：指数运算, 返回以第一个参数为底数、第二个参数为幂的指数值。 Math.sqrt()：返回参数值的平方根。如果参数是一个负值，则返回NaN。 Math.log()：返回以e为底的自然对数值。Math.exp()：返回e的指数，也就是常数e的参数次方。Math.round()：四舍五入 Math.random()：返回0到1之间的一个伪随机数，可能等于0，但是一定小于1。 (3)三角函数方法 123456Math.sin()：返回参数的正弦 Math.cos()：返回参数的余弦 Math.tan()：返回参数的正切 Math.asin()：返回参数的反正弦（弧度值） Math.acos()：返回参数的反余弦（弧度值） Math.atan()：返回参数的反正切（弧度值） 3.6 JSON对象 (1)方法123456JSON.stringify() //用于将一个值转为字符串。该字符串应该符合JSON格式，并且可以被JSON.parse方法还原。//（JSON.stringify(obj, selectedProperties)）还可以接受一个数组，作为第二个参数，指定需要转成字符串的属性。//还可以接受第三个参数，用于增加返回的JSON字符串的可读性。如果是数字，表示每个属性前面添加的空格（最多不超过10个）；如果是字符串（不超过10个字符），则该字符串会添加在每行前面。JSON.parse() //用于将JSON字符串转化成对象。 3.7 console对象 (1)方法1234567891011121314151617181920212223242526onsole.log(text,text2,...) //用于在console窗口输出信息。它可以接受多个参数，将它们的结果连接起来输出。如果第一个参数是格式字符串（使用了格式占位符），console.log方法将依次用后面的参数替换占位符，然后再进行输出。console.info() //在console窗口输出信息，同时，会在输出信息的前面，加上一个蓝色图标。console.debug() //在console窗口输出信息，同时，会在输出信息的前面，加上一个蓝色图标。console.warn() //输出信息时，在最前面加一个黄色三角，表示警告；console.error() //输出信息时，在最前面加一个红色的叉，表示出错，同时会显示错误发生的堆栈console.table() //可以将复合类型的数据转为表格显示。console.count() //用于计数，输出它被调用了多少次。console.dir() //用来对一个对象进行检查（inspect），并以易于阅读和打印的格式显示。console.dirxml() //用于以目录树的形式，显示DOM节点。console.assert() //接受两个参数，第一个参数是表达式，第二个参数是字符串。只有当第一个参数为false，才会输出第二个参数，否则不会有任何结果。//这两个方法用于计时，可以算出一个操作所花费的准确时间。console.time()console.timeEnd()//time方法表示计时开始，timeEnd方法表示计时结束。它们的参数是计时器的名称。调用timeEnd方法之后，console窗口会显示“计时器名称: 所耗费的时间”。console.profile() //用来新建一个性能测试器（profile），它的参数是性能测试器的名字。console.profileEnd() //用来结束正在运行的性能测试器。console.group()console.groupend()//上面这两个方法用于将显示的信息分组。它只在输出大量信息时有用，分在一组的信息，可以用鼠标折叠/展开。console.groupCollapsed() //用于将显示的信息分组，该组的内容，在第一次显示时是收起的（collapsed），而不是展开的。console.trace() //显示当前执行的代码在堆栈中的调用路径。console.clear() //用于清除当前控制台的所有输出，将光标回置到第一行。","tags":[{"name":"javascript","slug":"javascript","permalink":"http://kingle.online/tags/javascript/"},{"name":"api","slug":"api","permalink":"http://kingle.online/tags/api/"}]},{"title":"Mac系统下非常好用的软件和工具","date":"2018-01-15T20:04:08.000Z","path":"2018/01/16/Mac系统下非常好用的软件和工具/","text":"Awesome Mac这个仓库主要是收集非常好用的Mac应用程序、软件以及工具，主要面向开发者和设计师。 目录 编辑器 开发者工具 测试工具 命令行工具 版本控制 数据库 设计和产品 虚拟机 通信 数据恢复 音频和视频 书签阅读写作 FTP客户端 软件打包工具 制作电子书 下载工具 网盘 输入法 浏览器 翻译工具 科学上网 其它实用工具 远程协助 QuickLook插件 第三方应用市场APP Mac软件下载网站 编辑器一种用于编辑纯文本文件的程序，建议使用免费开源的编辑器 Atom - GitHub推出的开源编辑器 Sublime Text - 一个比较简洁大方带插件管理系统的流行编辑器 Brackets - Adobe推出的Brackets免费/开源编辑器。(https://github.com/adobe/brackets/) Espresso - Web编程利器，具备了快速且强大的编辑功能、专业检查与分 类、即时预览编辑成果、发布与同步功能等。 Visual Studio Code - 微软推出的免费/开源编辑器，TypeScript支持杠杠的， Emacs - Emacs是基于控制台的编辑器和高度可定制的。 LightTable - 下一代代码编辑器。(https://github.com/LightTable/LightTable) TextMate - 文本编辑器软件，与BBedit一起并称苹果机上的emacs和vim，这是以前。 BBEdit - 强大的文件编辑器，用于编辑文件，文本文件及程序源代码。 Coda2 - 编写Web应用长得漂亮的编辑器。 Vim - Vim古老命令行中使用的编辑器 Vimr - Vim客户端，升级Vim体验。(https://github.com/qvacua/vimr/) ONI - 由Neovim提供的IDE。(https://github.com/onivim/oni) micro - 一个现代直观的基于终端的文本编辑器。(https://github.com/ory/editor) HBuilder - HBuilder是DCloud（数字天堂）推出的一款支持HTML5的Web开发IDE。 Tincta - 一个免费的文本编辑器。(https://github.com/CodingFriends/Tincta) Xcode - 开发iOS和MacOS基本IDE。 AppCode - 适用于iOS / macOS开发的智能IDE IntelliJ IDEA - 一款Java开发集成环境。(学生免费) Webstorm - 是JetBrains公司旗下一款JavaScript开发工具。学生免费，点击这里 查看更多。 NodeJS - 集成Node.js，你肯定需要它，很多功能需要它。 EditorConfig - 帮助开发者在不同的编辑器和IDE之间定义和维护一致的代码风格。 Material Theme UI - Google为React开发的主题。 Deco IDE - React Native IDE 支持控件拖拽界面实时变更。(https://github.com/decosoftware/deco-ide) Xamarin Studio - 免费的跨平台的C# IDE。支持iOS、Android和.net开发。(https://github.com/mono/monodevelop) NetBeans IDE - 免费、开源的IDE，主要用于java开发，可支持多种语言和框架。https://netbeans.org/community/sources/) Android Studio - Android的官方IDE，基于Intellij IDEA。 (http://tools.android.com/) Visual Studio Community for Mac - 免费，功能齐全的IDE为学生，开源和个人开发人员。 Eclipse - 流行的开源IDE，主要用于Java，但为多种语言和平台的插件支持。 CotEditor - 轻量级的纯文本编辑器。 (https://github.com/coteditor/CotEditor/) Chocolat 轻量级本地编辑器。 开发者工具 WeFlow - 一个基于 tmt-workflow 前端工作流的开发工具。 (https://github.com/Tencent/WeFlow) Koala - 预处理器语言图形编译工具，支持Less、Sass、CoffeeScript、Compass framework 的即时编译。(https://github.com/oklai/koala/) CodeKit - 自动编译Less、Sass、Stylus、CoffeeScript、Jade &amp; Haml等文件。 PaintCode - 将设计转换成Objective-C,Swift或C#代码。 Hosts.prefpane - 编辑 hosts 文件的工具。 (https://github.com/specialunderwear/Hosts.prefpane) iHosts - 唯一上架 Mac App Store 的 /etc/hosts 编辑神器。 (https://itunes.apple.com/app/id1102004240?mt=12) SwitchHosts - 一个管理、切换多个 hosts 方案的工具。(https://github.com/oldj/SwitchHosts) Gas Mask - 编辑 hosts 文件的工具，更简单方便。(https://github.com/2ndalpha/gasmask) *[必备] DiffMerge - 可视化的文件比较（也可进行目录比较）与合并工具。 Gemini - 智能的重复文件查找器。 BetterRename - 一款强大的批量重命名工具，可以通过搜索功能改名。(https://itunes.apple.com/us/app/better-rename-9/id414209656) PPRows - 计算你写了多少行代码。(https://github.com/jkpang/PPRows) Beyond Compare - 对比两个文件夹或者文件，并将差异以颜色标示。 Kaleidoscope - 一款很强大的文本文件和图像比较工具，同时和 git、svn 等版本控制工具能够完美的结合。 Fanvas - 把swf转为HTML5 canvas动画的系统。 (https://github.com/oklai/koala/) EnvPane - 图形终端查看环境变量的应用工具。 (https://github.com/hschmidt/EnvPane) Dash - 强大到你无法想象的API离线文档软件。 [推荐] [必备] Dlite - 简单的使用Docker的一个软件。 (https://github.com/nlf/dlite) SnippetsLab - 管理和组织你的代码片段。 StarUML - 强大的软件建模软件。 Vagrant Manager - 管理你本地服务。 (https://github.com/lanayotech/vagrant-manager/) FinderGo Finder中快速打开终端，定位到目录 (https://github.com/onmyway133/FinderGo) Localname - 提供对本地开发服务器的访问权限。 zeplin - 前端与设计协同工作专用工具。 Go2Shell - 从Finder打开命令行。 SecureCRT - 一款支持SSH、Telnet等多种协议的终端仿真程序。 MJML - 简化设计回应电子邮件的方式。 (https://github.com/mjmlio/mjml) TeXstudio - 集成创建LaTeX文档的写作环境。 (https://sourceforge.net/projects/texstudio/) Vagrant - 用来构建虚拟开发环境的工具。 (https://github.com/mitchellh/vagrant) LaunchRocket - 在Mac系统偏好设置中创建服务管理。 (https://sourceforge.net/projects/texstudio/) Swiftify - Xcode＆Finder扩展 Objective-C转Swift代码转换器 正则编辑器 Patterns - 正则表达式编辑器。 Reginald - 正则表达式测试应用程序，使用 RegexKitLite。(https://github.com/michaeltyson/Reginald) Regex - 感觉是用过最漂亮的正则表达式测试工具。 Reggy - 正则表达式编辑器。(https://github.com/samsouder/reggy) RegExRX - 正则表达式的开发工具。 测试工具 Wireshark - 世界上最广泛使用的网络协议分析软件。 (https://github.com/wireshark/wireshark) Charles - 一个代理工具，允许你查看所有的HTTP和HTTPS流量。 James - 用于https和http进行查询映射请求。 (https://github.com/james-proxy/james) mitmproxy - 一款支持HTTP(S)的中间人代理工具，可在终端下运行，可用于抓包 (https://github.com/james-proxy/james) Insomnia 3.0 - 漂亮的HTTP请求测试工具。 Cocoa Rest Client - 比Postman看起来漂亮的客户端，测试HTTP/REST endpoints。 (https://github.com/mmattozzi/cocoa-rest-client) Paw - 先进的 HTTP 客户端。 Cellist - HTTP调试客户端。 Integrity - 轻松找到无效链接。 Postman - Postman 帮助我们快速测试API。 [必备] Insomnia - 最直观的跨平台REST API客户端。 (https://github.com/getinsomnia/insomnia) 命令行工具 Mac OS X Manual Pages - 官方Mac命令操作手册。 [必备] Termius - 免费的终端工具，可以与windows平台的xshell媲美。 iTerm2 - 免费的终端工具，直接替代自带的Terminal，有非常多惊人的特性。(https://github.com/gnachman/iTerm2) [推荐] [必备] cool-retro-term - 怀旧的命令行终端。 (https://github.com/Swordfish90/cool-retro-term) Oh my zsh - 拥有大量的有用的功能，助手，插件，主题，等特性的命令行工具插件。 [推荐] [必备](https://github.com/robbyrussell/oh-my-zsh) autojump - 告别又臭又长的路径名，一键直达任何目录。 (https://github.com/wting/autojump) * Glances - 在命令行中查看你系统运行状态的工具。 (https://github.com/nicolargo/glances) Cakebrew - Homebrew 的客户端软件。摆脱命令方便安装、查看、卸载软件。 (https://github.com/brunophilipe/Cakebrew/) ndm - 查看本地NPM安装的包客户端软件。摆脱命令方便安装、查看、卸载软件。(https://github.com/720kb/ndm) Black Screen - 来自 21 世纪的强大终端。 (https://github.com/shockone/black-screen) Fish Shell - 智能且用户友好的命令行终端。 [推荐] oh-my-fish - 和Oh my zsh相似，建立在Fish Shell框架上。 [推荐] bash-it - 一个社区的bash的框架。 color-retro-term - 一款复古风格的终端，非常酷炫。 HyperTerm - 一款基于Node开发的终端软件，逼格很高。(https://github.com/zeit/hyperterm) itunes-remote - 通过终端控制您的iTunes。(https://github.com/mischah/itunes-remote) mycli - 为MySQL命令行客户端，提供语法高亮和提示功能的工具！ (https://github.com/dbcli/mycli) [推荐] m-cli - 用于macOS的瑞士军刀。 (https://github.com/rgcr/m-cli) Mac-CLI - 自动化您的OS X系统的使用。 (https://github.com/guarinogabriel/Mac-CLI) LNav - 日志文件阅读器. (https://github.com/tstack/lnav) tmux 终端登录远程主机的命令行工具。(https://github.com/tmux/tmux) mas - 一个简单的命令行界面的苹果应用商店。 (https://github.com/mas-cli/mas) cmus - 命令行播放音乐应用。 (https://github.com/cmus) Serial - 为工程师和系统管理员嵌入式硬件更容易。 版本控制 Git - 版本控制工具，官网提供数十种GUI客户端 for Mac。 [推荐] [必备](https://github.com/git/git) SVN - 版本控制工具。 GUI GitFinder - 一个快速和轻量级的Git客户端的Mac与Finder集成。 Fork - 一个快速友好的git客户端。 GitX - Pieter’s的衍生版本，维护增强生产力和团队开发变化。 (https://github.com/rowanj/gitx) Gitbar - 开源，在你的菜单栏上显示GitHub贡献统计。 (https://github.com/Shikkic/gitbar) GitHub Desktop - 使用GitHub的GUI应用。 OhMyStar 最好的组织Github Star 的软件。(https://itunes.apple.com/us/app/ohmystar2/id1218642292) [必备] GitUp - 一个简单功能强大的git客户端。(https://github.com/git-up/GitUp) Hub - 将GitHub接口和git命令进行包装。(https://github.com/github/hub) SourceTree - 强大的Git跨平台客户端。 Tower2 - 最强大的Git客户端。 Versions - Mac上最好的SVN管理工具。 Cornerstone - Mac上最佳的SVN管理工具。 SmartGit - 非商业用途免费，全平台支持，集成 Github服务。 GitKraken - 最流行的图形用户界面的git管理工具。 [推荐] 版本控制系统 GitLab - 一个用于仓库管理系统的开源项目。 [推荐] [必备] GitHub GitHub代码托管，项目管理，演示部署，瞧，您现在就访问GitHub。 [推荐] [必备] Coding.net - 代码托管，项目管理，WebIDE，演示部署，开启云端开发模式，让开发更简单。 phabricator phabricator支持Git、SVN、HG 基于 PHP + Mysql 的开放源代码软件开发平台。 Gogs - 一款极易搭建的自助 Git 服务Golang版本。(https://github.com/gogits/gogs) Gerrit Gerrit 是一个免费、开放源代码的代码审查软件，使用网页界面。 Gitblit Java版本Git代码托管，项目管理。(https://github.com/gitblit/gitblit) 数据库 Sequel Pro - 一个MySQL数据库管理软件。(https://github.com/sequelpro/sequelpro) [必备] MySQL Workbench - MySQL数据库官方管理软件。 Navicat Data Modeler - 一个数据库设计工具，它帮助创建高质素的概念、逻辑和物理数据模型。 SQLPro Studio - 支持SQL Server, Postgres, Oracle 以及MySQL等主流的数据库可视化管理工具. Bdash - SQL客户端应用程序，支持MySQL、 PostgreSQL (Redshift)、 BigQuery、。 (https://github.com/bdash-app/bdash) Postico - 现代PostgreSQL客户端，漂亮功能多。 ElectroCRUD - MySQL数据库CRUD应用程序。 (https://github.com/garrylachman/ElectroCRUD) Base 2 - 一个用于管理SQLite数据库的软件。 SQLight - 一个SQLite数据库管理器工具，非常好用。 DB Browser for SQLite - 一个用于管理SQLite数据库的软件，跨平台。 (https://github.com/sqlitebrowser/sqlitebrowser) Postgres.app - Mac上最简单的方法的使用PostgreSQL关系型数据库管理系统。 (https://github.com/PostgresApp/PostgresApp) PSequel - PostgreSQL数据库GUI软件。 Robo 3T - 基于Shell的MongoDB图形化客户端管理软件。 (https://github.com/Studio3T/robomongo) MongoBooster - MongoDB图形化管理软件，内嵌MongoShell，ES6语法，流畅查询及智能感知。 Mongo Management Studio - MongoDB图形化客户端管理软件。 MongoChef - MongoDB图形化客户端管理软件。 Mongotron - 使用Electron和Angular开发的MongoDB图形化客户端。 (https://github.com/officert/mongotron) Chrome MySQL Admin - 一个Chrome插件，是MySQL开发的跨平台、可视化数据库工具。 (https://github.com/yoichiro/chrome_mysql_admin) JackDB - 直接的SQL访问你所有的数据，无论在哪里。(https://github.com/yoichiro/chrome_mysql_admin) medis - 漂亮的Redis管理软件。 (https://github.com/luin/medis) RedisClient - 漂亮跨平台的Redis管理软件。 (https://github.com/UUGU/redis-client-app) RedisDesktopManager - Redis跨平台的GUI管理工具。(https://github.com/uglide/RedisDesktopManager) MDB Explorer - Mac上查看编辑Access数据库的工具。 Datum - SQLite - Sqlite3数据库管理软件。 mongoDB.app - 在Mac 上最简单的使用MongoDB (https://github.com/gcollazo/mongodbapp) DataGrip - 是JetBrains公司旗下一款数据库管理工具。点击这里 学生免费。 Tableau Public - 数据可视化工具。 Core Data Editor - 核心数据编辑器可让您轻松查看，编辑和分析应用程序的数据。 (https://github.com/luin/medis) Keylord - Redis，Bolt，LevelDB和Memcached键值数据库的桌面GUI客户端。 DBeaver - 跨平台SQL客户端，支持大部分主流数据库 设计和产品设计工具 Acorn - 一个像PS，全面的功能集的图像编辑器。 Affinity Designer - 矢量图像设计工具，可能的Adobe Illustrator的替代。 Affinity Photo - 光栅图像设计工具，可以替代Adobe PS图象处理软件。 Blender - 全功能可扩展的跨平台3D内容套件。 (https://developer.blender.org/) Pixelmator - 强大的图像编辑器，可能PS图像处理软件的选择。 Sketch - 混合矢量/位图布局应用，特别适用于用户界面，Web和移动设计。 [推荐] [必备] Sketch Toolbox - 一个超级简单的Sketch插件管理器。(https://github.com/buzzfeed/Sketch-Toolbox) [推荐] Measure - 设计稿标注、测量工具。 (https://github.com/utom/sketch-measure) [推荐] User Flows - 直接从画板生成流程图。 (https://github.com/abynim/UserFlows) Sketch Cache Cleaner - 清理 Sketch 历史文件，释放磁盘空间。 (https://github.com/yo-op/sketchcachecleaner) Gravit Designer - 混合矢量/位图布局应用，比起Sketch还差一点。 (https://itunes.apple.com/app/id1207744923) inklet - 将Mac上的触摸板变成绘图板。[推荐] Alchemy - 开源的绘图工具软件，用于素描、会话以及一种新的绘图方式。(http://svn.al.chemy.org/) MyPaint - 开源的绘图工具软件，用于素描、会话以及一种新的绘图方式。(https://github.com/mypaint) GIMP - 图像编辑软件，号称Linux下的PhotoShop，同时有Mac版本。(https://www.gimp.org/source/#gimp-source-code) Inkscape - 一款开源矢量图形编辑软件，与Illustrator、Freehand、CorelDraw、Xara X 等其他软件相似。(https://launchpad.net/inkscape) Monodraw - 一款文本图像编辑器。 SketchBook - 出众的绘图软件。 Tayasui Sketches - 专业的绘图软件。 Art Text 3 - 生成各种特效字体。 FontForge - 字体编辑工具。 (https://github.com/fontforge) Nik Collection - 专业照片后期制作工具Google收购后免费。[推荐] Paintbrush - 位图图像编辑器。(https://sourceforge.net/projects/paintbrush/files/) [star 2][star2 Icon] Krita - 一个开源的位图形编辑软件，包含一个绘画程式和照片编辑器。 (http://download.kde.org/stable/krita/3.0/krita-3.0.tgz.mirrorlist) Vectr - 免费图形编辑器。这是一个简单而强大的Web和桌面跨平台工具，把你的设计变成现实。 Principle - 使用它很容易设计动画和交互式用户界面。 MagicaVoxel - 轻量级的8位像素编辑和交互路径追踪渲染器。 ScreenToLayers - 轻松导出桌面分层文件PSD文件。(https://github.com/jeremyvizzini/ScreenToLayers) Pixel Perfect - 比较UI模型和开发结果非常容易。 (https://itunes.apple.com/us/app/pixel-perfect/id916097243) Sparkle - 可视化网页设计工具。 Figma - 一款基于Web的实时协作的云设计软件。 [Recommend] 原型流程 Origami Studio - 一种设计现代界面的新工具，由Facebook设计师构建和使用。 Flinto - 快速制作高保真的互交原型工具，支持Sketch导入。 [推荐] Kite - 一个强大的动画制作工具制作Mac和iOS原型中的应用。 [推荐] Justinmind - 功能更丰富团队协作方便。[推荐] MockFlow - 用于网页设计和可用性测试的在线原型设计套件。 Axure RP 8 - 画原型图工具，团队协作SVN方便好用。 pencil - 开源免费制作软件原型的工具 (https://github.com/evolus/pencil) Mockplus - 更快更简单的原型设计工具。 OmniGraffle - 可用来绘制图表、流程图、组织结构图、思维导图以及插图或原型。 XMind - 一款实用的思维导图软件。 [必备] Lighten - XMind出品的一款实用的思维导图软件。 Scapple - 一款实用的思维导图软件。 Framer - 做交互原型的工具。 Balsamiq Mockups - 一个快速的网页设计原型工具，帮助你更快、更聪明的工作。 Marvel - 简单设计，原型设计和协作。 MindNode - 简洁的风格与人性化的操作，绘制思维脑图。 WriteMapper - 专为写作者而设的脑图工具。 SimpleMind - 超小体积的思维导图工具。 Adobe XD (Experience Design) - 用于网站和移动应用的设计和原型设计。 其它工具 TinyPNG4Mac - 图片压缩专用开源工具。 (https://github.com/kyleduo/TinyPNG4Mac) Image2icon - 将你的图片转换成图标。 ImageAlpha - 压缩PNG图片，去掉无效的透明。(https://github.com/pornel/ImageAlpha) Resize Master - 更快速和容易批量调整图像和加水印。 (https://itunes.apple.com/app/resize-master/id1025306797) * JPEGmini - 将图像尺寸降低高达80％，而不会影响质量。 (https://itunes.apple.com/cn/app/jpegmini-lite/id525742250) ImageOptim - 压缩图片，删除EXIF信息。(https://github.com/ImageOptim/ImageOptim) Sip - 收集，整理和分享你的颜色拾色器。[推荐] 马克鳗 - 高效的设计稿标注、测量工具。[推荐] Frank DeLoupe - 支持 Retina 的屏幕拾色器。 ColorSchemer - 专业的配色、调色软件。 IconKit - App图标自动生成器。(https://itunes.apple.com/cn/app/iconkit-icon-resizer-for-app/id507135296?mt=12) GifCapture 开源 macOS 截屏生成 Gif 工具。(https://github.com/onmyway133/GifCapture) Gifox 专业的高颜值 GIF 录制应用。 (https://itunes.apple.com/cn/app/gifox-gif-recording-and-sharing/id1082624744) APNGb - 编辑apng图片格式的软件。 (https://github.com/mancunianetz/APNGb) Licecap - 是一款屏幕录制工具输出GIF，录制过程中可以随意改变录屏范围。(https://github.com/justinfrankel/licecap) [必备] Kap - 轻量 GIF 录屏小工具。(https://github.com/wulkano/kap) [必备] KeyCastr - 录屏好帮手，实时显示按键操作的小工具。(https://github.com/keycastr/keycastr) GIPHY Capture - 免费软件的捕捉和分享图片在桌面上 Skitch - 截图附带强大的标注功能。 Teampaper Snap - 为设计师量身定做的屏幕截图兼注释工具。 (https://itunes.apple.com/cn/app/monosnap/id1199502670) Monosnap - 制作截图，录制视频共享文件。 [推荐] [必备] (https://itunes.apple.com/cn/app/monosnap/id540348655) 截图(Jietu) - 截图附带强大的标注功能，腾讯作品。[推荐] Snipaste - 一个简单但强大的截图工具。[star3 Icon] ScreenShot PSD - 将屏幕捕获存为分层的PSD，便于编辑。 (https://itunes.apple.com/us/app/screenshot-psd/id489880259) Snip - 高效的截图工具，支持滚动截屏，腾讯作品。[推荐] iPic - 上传图片至七牛、阿里云等图床，支持 Markdown 链接。(https://itunes.apple.com/cn/app/id1101244278?ls=1&amp;mt=12&amp;at=1000lv4R&amp;ct=iPic_me) Iconjar - 图标管理软件，带组织和搜索功能。 [推荐] svgus - SVG 图片管理器。(https://itunes.apple.com/cn/app/svgsus/id1106867065) RightFont - 字体管理工具。[推荐] Solarized - 干净清爽的颜色主题，支持iTerm、Intellij IDEA、Vim等。[推荐] Couleurs - 简单的屏幕取色应用程序。 Tropy - 简单的屏幕取色应用程序。(https://github.com/tropy/tropy) 虚拟机 Parallels Desktop - 虽然好用但是收费机制，更新花钱、花钱、花钱。 Virtual Box - 免费、免费、免费，带NTFS读写，不用买ParagonNTFS，省100块。[推荐] VMWare Fusion - 强大的虚拟机，商业软件。 Veertu - Mac上轻量级的虚拟机。通过一种高响应，沙箱且本地化的方式在你在 Mac 上运行虚拟机。[推荐] 通信推荐一些通信工具，沟通，团队协同 Franz - 一个使用 Electron开发的，可以同时登录23个平台的即时通讯软件。 QQ - QQ for Mac App。 WeChat - 微信 for Mac App。 Electronic WeChat - 调用微信接口，使用 Electron 开发的第三方漂亮开源微信应用。 (https://github.com/geeeeeeeeek/electronic-wechat) Skype - Skype共享、跨平台的短信和电话。 Maipo脉搏 - 微博第三方Mac应用。[推荐] (https://itunes.apple.com/cn/app/weibox/id789066512) 御飯 - 饭否第三方Mac应用。 ChitChat - WhatsApp非官方。 (https://github.com/stonesam92/ChitChat) Telegram - 通讯新时代。 Messenger - Facebook第三方聊天工具。 (https://github.com/rsms/fb-mac-messenger) Adium - 呃这个是老的集成多个平台的聊天客户端。* Textual - 最受欢迎的世界与我们相关的KPI应用 for OS X。(https://github.com/Codeux-Software/Textual) Gitter - 关于GitHub的项目交流，支持 Markdown，对开发者极为友好。 简聊 - 企业级即时沟通工具，已经下线了，可以自己搭建一套系统玩儿。(https://github.com/jianliaoim/talk-os) 钉钉 - 企业级办公通讯免费平台。 Slack - 团队协作，沟通工具。 零信 - 随时随地工作，跨平台。 今目标 - 一款面向中小企业的互联网工作平台。 BearyChat - 互联网团队协作，沟通工具。 Bitpost - 私人分散消息。它是一个p2p的去中心化和无须第三方提供信用担保协议。(https://github.com/Voluntarynet/Bitpost) Teambition - 团队协作。提供管理任务、安排日程、查找文件、即时讨论等团队所需要的一切协作功能。 日事清 - 个人日程管理，团队协作工具。日程安排，计划分配，笔记总结等。 Coding.net - 代码托管，项目管理，WebIDE，演示部署，开启云端开发模式，让开发更简单。 WeeChat - 一个命令行聊天客户端。 Rambox - 消息和电子邮件应用程序，将常见的Web应用程序组合成一个程序。 (https://github.com/saenzramiro/rambox) Keybase - 一个安全的消息应用程序 (https://github.com/keybase) Email Spark - 新推出的快速邮件客户端支持Mac和iPhone。 Airmail - 快速的邮件客户端支持Mac和iPhone。 Nylas Mail - 免费邮件客户端。 (https://github.com/nylas/nylas-mail) Foxmail - 快速的邮件客户端。 [推荐] 网易邮箱大师 - 全平台的邮箱管理客户端，网易邮箱大师电脑版。 [推荐] MailTags - 管理和组织邮件，日程和标签进行分类邮件。 N1 - 可以扩展的开源收费邮件客户端。 Postbox - 这个貌似也非常强大哦，关键是简洁漂亮的收费邮件客户端。 Polymail - 简单，功能强大，长得好看的新晋邮件客户端。 Newton(原Cloudmagic) - 界面非常简洁的一个邮件客户端。 ThunderBird - Mozilla 公司出品的强大的Email客户端程序。 Yomail - 新出的国内开发的比较好的邮件客户端。 数据恢复 DiskWarrior - 恢复文件系统损坏时，磁盘工具进行选择。 Data Rescue - 多种情况下的全面和专业的数据恢复。 Stellar Phoenix Mac Data Recovery - 一个功能强大的恢复文件面向Mac的工具。 R-Studio for Mac - 可恢复分区被格式化、损坏或被删除的文件。 音频和视频 Popcorn Time - 电影播放器，观看torrent电影。 Kodi - 一款一流的免费开源媒体中心软件，可用于播放视频、音乐，查看图片，玩游戏等。(https://github.com/xbmc/xbmc) MPV - 一个免费、开源和跨平台的媒体播放器。(https://github.com/mpv-player/mpv) IINA - 基于MPV的，现代视频播放器，支持多点触摸控制。(https://github.com/lhc70000/iina) Soda Player - 一款能够直接播放种子、磁力链接、在线视频、自动获取字幕、链接和本地视频文件的播放器。 VOX Player - 免费全能音乐播放器，撸码之余听听歌是一种享受。 [推荐] [必备] Radiant Player - Google Play音乐播放器。(https://github.com/radiant-player/radiant-player-mac) Sonora - 一个很小的音乐播放器。(https://github.com/sonoramac/Sonora) Audacity - 免费开源的编辑音频的软件。(https://github.com/audacity/audacity) Metadatics - 音频元数据编辑器，支持大多数常见的音频文件。(https://itunes.apple.com/us/app/tincta/id448340648) Natron - 开源的视频合成软件，功能与 Adobe After Effects 或者 Nuke 类似。(https://github.com/MrKepzie/Natron) Ardour - 录制，编辑和混合多轨音频。(https://github.com/Ardour/ardour) Hydrogen - 专业鼓乐类工具，创建专业但简单而直观的鼓乐节目。(https://github.com/hydrogen-music/hydrogen) Audio Hijack - 一个记录任何应用程序的音频，包括网络电话Skype，网络流从Safari，以及更多。 Stringed 2 - 音频编辑处理工具。 Mixxx - 免费的DJ软件，给你一切你需要的表演组合，名副其实的替代Traktor。(https://github.com/mixxxdj/mixxx) MuseScore - 免费的作曲与乐谱软件。(https://github.com/musescore/MuseScore) * Cog - 一个免费的开源音频播放器。(https://bitbucket.org/mamburu/cog/) Elmedia Player - 支持FLV, MP4, AVI, MOV, DAT, MKV, MP3, FLAC, M4V等格式播放. VLC - 开源的跨平台多媒体播放器及框架，可播放大多数多媒体文件。(https://github.com/videolan/vlc) XLD - 解码/解码/转换/播放各种“无损”音频文件。(https://code.google.com/archive/p/xld/source) [推荐] HandBrake - 高性能的视频编码和转换工具，具有很好的图形用户界面。(https://github.com/HandBrake/HandBrake) MPlayerX - 媒体播放器。(https://github.com/niltsh/MPlayerX) Playback - 实验性质的视频播放器。 (https://github.com/mafintosh/playback) Shotcut - 免费开源视频编辑器。 (https://github.com/mltframework/shotcut) ScreenFlow - 屏幕和视频编辑软件。 ArcTime - 跨平台字幕制作软件。 [推荐] [必备] Perian - 让QuickTime播放所有常见格式的免费插件。 (https://github.com/MaddTheSane/perian) [推荐] [必备] Adapter - 视频，音频和图像转换工具。[推荐] Synfig Studio - 工业级、强大的2D矢量动画制作软件。(https://github.com/synfig/synfig) Aegisub - 免费、开源、跨平台的专业字幕编辑软件，可以快速打轴，制作特效字幕等，字幕组必备。 (https://github.com/Aegisub/Aegisub/) *[推荐] iFFmpeg - MacOS 上功能强大、易用的视频压制软件。 [推荐] Movie Catcher - 电影美剧搜索及在线观看离线下载软件，借助百度云实现离线下载以及在线播放功能。 (https://github.com/EvilCult/moviecatcher) LyricsX - 一款功能完备的歌词工具。 (https://github.com/ddddxxx/LyricsX) (https://itunes.apple.com/us/app/lyricsx/id1254743014?mt=12) SpotMenu - Spotify和iTunes在状态菜单栏中显示。 (https://github.com/kmikiy/SpotMenu) 云音乐播放器 网易云音乐 ieaseMusic 基于网易云音乐 (https://github.com/Binaryify/NeteaseCloudMusicApi) QQ音乐 虾米音乐 酷我音乐 酷狗音乐 书签阅读写作 OpenOffice - 是一套跨平台的办公室软件套件。(http://openoffice.apache.org/source.html) [推荐] [必备] LibreOffice - 一款功能强大的免费开源办公软件，默认使用开放文档格式，并支持其他多种文档格式。(http://zh-cn.libreoffice.org/download/source-code/) KOffice - 集成化办公套件，包含文字处理器、电子 表格、幻灯片制作、项目管理等多种工具。 Spillo - 功能强大，美观、快速网络书签网页阅读。 iChm - 读chm文件的软件。 Chmox - 读chm文件的软件。 CHM Reader - 读chm文件的软件。[推荐] Skim - PDF阅读器和笔记本。 (https://sourceforge.net/projects/skim-app/) PDF Expert - PDF阅读、批注，编辑文本，添加照片，填写表单。 MarginNote - 一款优秀的 PDF 有标注软件，批注、抽认卡、思维导图、汇总视图等功能。 Kindle App - 亚马逊 Kindle App 电子书阅读器。 Klib - 全新的 Kindle、iBooks 标注管理工具。(https://itunes.apple.com/cn/app/id1196268448?mt=12&amp;at=1000lv4R&amp;ct=klib_me) texpad - Mac下非常棒的LaTeX编辑器。 支持自动编译预览，自动补全等。 Bear Writer - 漂亮，灵活的写作应用程序，用于制作笔记和散文。 (https://itunes.apple.com/us/app/bear-beautiful-writing-app/id1091189122?ls=1&amp;mt=12) Boostnote - 为程序员量身定做的笔记应用。 (https://github.com/BoostIO/Boostnote) [推荐] QOwnNotes - 是开源记事本，带有markdown支持和待办事项列表管理器。 (https://github.com/pbek/QOwnNotes) Feeds 2 - 监控任何RSS。(https://github.com/nfarina/feeds) ReadKit - 书签RSS管理客户端。 Reeder 3 - RSS 服务订阅。 [推荐] [必备] Leaf - RSS 客户端程序。 Vienna - RSS/Atom 新闻阅读客户端。(https://github.com/ViennaRSS/vienna-rss) * Markdown Yu Writer - 一款能找到写作乐趣的 Markdown 文本编辑器。 [推荐] [必备] Mou - 免费 Markdown 编辑神器。 Marp - Markdown 制作幻灯片编辑器。(https://github.com/yhatt/marp) TextNut - Markdown编辑器，富文本之间自由切换。 MWeb - 专业的 Markdown 写作、记笔记、静态博客生成软件。 Typora - 基于 Electron 的“读写一体” Markdown 编辑器。 [推荐] MacDown - 一款开源的Markdown编辑器，深受Mou的影响。 [推荐] EME - 最近刚出的一款Markdown编辑器，界面很像Chrome浏览器的界面，很简约。 LightPaper - 简单的Markdown文本编辑器。 Marked 2 - Markdown文本预览编辑。 iA Writer - Markdown文本预览编辑，注重语法检查，专门为作家提供的编辑器。 Ulysses - 适用于Mac，iPad和iPhone的写作应用程序，支持Markdown。 Cmd Markdown - Cmd Markdown 编辑阅读器，支持实时同步预览，区分写作和阅读模式，支持在线存储，分享文稿网址。 Quiver - 程序猿的笔记本。 有道云笔记 - 支持多目录，Markdown，iWork/Office预览。[推荐] [必备] 为知笔记 - 支持Markdown，搜集整理图片链接导入文档。[推荐] [必备] leanote - 支持Markdown的一款开源笔记软件，支持直接成为个人博客。(https://github.com/leanote/leanote) Evernote - 笔记本应用程序。 [推荐] [必备] OneNote - 微软备注应用。 [推荐] [必备] Inkdrop - Markdown爱好者的笔记本应用程序。 Notes - 简洁的笔记应用。 (https://github.com/nuttyartist/notes) Notebook 漂亮的笔记本应用程序。 制作电子书 Calibre - 丑陋的软件，但强大的软件电子书管理和转换。(https://github.com/kovidgoyal/calibre) Sigil - 多平台EPUB编辑器。 (https://github.com/Sigil-Ebook/Sigil) Scribus - 开源电子杂志制作软件。 (https://sourceforge.net/projects/scribus/) FTP客户端 Transmit - 一个FTP客户端，支持FTP + SFTP + S3。 Flow - 支持简单的 FTP + SFTP 客户端。 Yummy FTP - 专业快速，可靠的FTP客户端。 Cyberduck - 免费FTP，SFTP，S3和WebDAV客户端 &amp; OpenStack Swift Client。 FileZilla - 跨平台的FTP，FTPS和SFTP客户端。 软件打包工具 create-dmg - 快速创建一个压缩镜像文件。 (https://github.com/sindresorhus/create-dmg) Finicky - Web应用程序转化为苹果的应用程序。(https://github.com/johnste/finicky) nw.js - 使用HTML和JavaScript来制作桌面应用。(https://github.com/nwjs/nw.js) Electron - 前身是 AtomShell，使用 JS、HTML 和CSS 构建跨平台的桌面应用程序。(https://github.com/electron/electron) Electrino - 使用 JS、HTML 和CSS 构建跨平台的桌面应用程序，构建出的应用体积比Electron小。(https://github.com/pojala/electrino) react-desktop - 为 macOS Sierra带来React UI组件。(https://github.com/gabrielbull/react-desktop) ReactXP - 微软官方出品，支持平台Web，iOS，Android和Windows UWP仍然是一项正在进行的工作。(https://github.com/microsoft/reactxp) React Native macOS - 用 React Native 技术构建 OS X 下的桌面应用程序。(https://github.com/ptmt/react-native-desktop) [推荐] React Native Desktop for Ubuntu - 用 React Native 技术构建 Ubuntu 下的桌面应用程序。(https://github.com/CanonicalLtd/react-native) [推荐] AppJS - 使用 JS、HTML 和CSS 构建跨平台的桌面应用程序。(https://github.com/appjs/appjs) HEX - 使用 JS、HTML 和CSS 构建跨平台的桌面应用程序，有道出品。(https://github.com/netease-youdao/hex) AlloyDesktop - 同上，腾讯出品，给个差评。(https://github.com/AlloyTeam/webtop) * MacGap - 桌面WebKit打包HTML、CSS、JS应用。(https://github.com/MacGapProject) ionic - 一个用来开发混合手机应用的，开源的，免费的代码库。 (https://github.com/driftyco/ionic) 下载工具 Transmission - 免费的BitTorrent客户端 (https://github.com/transmission/transmission) aria2 - 一款支持多种协议的轻量级命令行下载工具。(https://github.com/aria2) JDownloader - 下载工具，下载文件的一键式托管。 You-Get - 网络富媒体命令行下载工具。(https://github.com/soimort/you-get) Free Download Manager - 功能强大的下载加速器。 FOLX - 一个Mac osx 系统风格界面的下载管理工具。 Downie - 支持多达近 1200 个视频站点的视频下载工具。 网盘*推荐一些有Mac客户端的网盘。 Dropbox - 非常好用的免费网络文件同步工具，提供在线存储服务。* 百度云 - 百度云客户端。 腾讯微云 - 腾讯云客户端。 坚果云 - 坚果云客户端。 115 - 115云客户端。 ~~360 - 360云客户端。~ ~~快盘 - 金山快盘。 ~ ownCloud - 私有云网盘。 NextCloud - 基于ownCloud完全开源免费开源，企业文件同步和共享。 Mega - 免费的云服务，提供50GB的免费存储空间。 亿方云 - 硅谷团队打造，个人免费。 Seafile - 是由国内团队开发的国际化的开源云存储软件项目。 输入法 ~~QQ输入法 - 腾讯出品的输入法。~ 搜狗输入法 - 搜狗输入法。 百度输入法 - 支持拼音五笔输入。 落格输入法 - 打破 Mac 双拼多年来的窘境。 清歌五笔输入法 - 为 iOS 和 Mac 专门打造的五笔输入法。 WBIM - 五笔输入法。 颜文字 - 颜文字输入。 RIME - 中州韻輸入法引擎。(https://github.com/rime) [推荐] [必备] 哈利路亚英文输入法 - 智能英文输入法，具备自动补全，自动纠错功能。 Rocket - 使用冒号快捷键可以更快捷地输入表情符号。 Type2Phone - 把Macbook键盘变为iPhone的蓝牙键盘。 (https://itunes.apple.com/cn/app/type2phone-bluetooth-keyboard/id472717129?mt=12) Kawa - 给每个输入法定义一个快捷键. (https://github.com/utatti/kawa) 浏览器 这里放Mac的浏览器应用 Safari - Mac预装自带浏览器。 Chrome - Chrome浏览器谷歌出品。 Firefox - 迎接 Firefox Quantum。快，只为更好。火狐浏览器。 Opera - Opera 浏览器。 QQ浏览器 - QQ浏览器－腾讯出品。 傲游云浏览器 - 傲游云浏览器。 Vivaldi - Opera开发商出品新的浏览器。 Ōryōki - 小的web浏览器。这是一个试验性的项目，目前正在开发中 Brave - 用Brave浏览更快更安全。 翻译工具 有道翻译 - 有道词典桌面版 辞海词典 - 学单词、背单词、辞海词典。 eudic - 欧路词典词典。 iTranslate - 支持全世界超过 80 种语言发音和输出。 Grammarly - 修正英语语法及用语 iText - 截图识别文字、翻译 (https://itunes.apple.com/cn/app/id1314980676?mt=12) 科学上网假设你是个勤奋的同学，你总有一天会强烈需要它们，上帝保佑他们吧。 SpechtLite - 支持 Shadowsocks 及规则管理的高效率代理。(https://github.com/shadowsocks) ShadowsocksX - 一个快速的隧道代理，可以帮助你绕过防火墙。(https://github.com/shadowsocks) ShadowsocksX-NG - 一款ShadowsocksX客户端软件。(https://github.com/qiuyuzhou/ShadowsocksX-NG) Lantern - 科学上网。(https://github.com/getlantern/lantern) [推荐] [必备] 鱼摆摆 - 科学上网。 Tunnelbear - 简单的私人VPN。 Tunnelblick - OpenVPN的免费软件。* GoAgentX - 科学上网。(https://github.com/getlantern/lantern) Surge - 科学上网。(https://itunes.apple.com/us/app/surge-web-developer-tool-proxy/id1040100637) 云梯 - 在圈内小有名气的VPN服务提供商。[推荐] srocket - 开启科学上网。 LoCoVPN - 每天签到可获得2小时免费VPN加速。 二师兄VPN - 提供无限流量、无限续期免费VPN账号。 GTX加速器 - 每天签到领取500M流量。 GreenVPN - 注册激活送免费VPN加速流量。 WiseVPN - 无限流量，免费VPN。 风驰VPN - 无限流量、无限续期的免费VPN加速服务。 PlutoX - 一款网络调试工具，科学上网工具。(https://itunes.apple.com/us/app/manico/id1176077430) tinc - VPN软件. (https://www.tinc-vpn.org/git/browse?p=tinc) Shimo - 连接大量VPN的应用 V2Ray - 原生支持Socks、HTTP、Shadowsocks、VMess 等协议。 FreeVPN Plus - 永不过期Mac免费VPN。 (https://itunes.apple.com/cn/app/freevpn-plus-永不过期mac免费vpn/id1202726435) Firefly 萤火虫 - 免费科学上网。 其它实用工具 12306ForMac - Mac版12306 订票/捡票 助手。(https://github.com/fancymax/12306ForMac) [推荐] AirServer - 将手机投影到电脑上。 Manta - 灵活的发票桌面应用程序，漂亮和可定制模板。(https://github.com/hql287/Manta) CheatSheet - CheatSheet 是一款Mac上的非常实用的快捷键快速提醒工具。 Snap - 一款可以给 Dock 上的程序添加快捷键的小工具。 (https://itunes.apple.com/cn/app/id418073146) WWDC - Mac OS的非官方的WWDC APP。(https://github.com/insidegui/WWDC) xScope - 测量、检查和测试屏幕上的图形和布局的工具。搜索你的苹果和网络，快速打开应用程序。 f.lux - 自动调整您的电脑屏幕，以匹配亮度。 Todoist - 跨平台的任务管理器与移动应用程序。 滴答清单 - 轻便的待办事项应用。 TaskPaper - 漂亮的纯文本任务列表。 Wunderlist - 奇妙清单跨平台的任务管理器与移动应用程序。 Ukelele - Unicode键盘布局编辑器。 Karabiner - 一个强大的和稳定的OS X的键盘定制。(https://github.com/tekezo/Karabiner) Keyboard Maestro - 根据键盘，菜单，位置，添加的设备等触发器自动执行日常操作。 Keytty - 让你通过键盘使用鼠标。 Mos - 让你的鼠标滚轮丝滑如触控板。(https://github.com/Caldis/Mos) AppCleaner - 一个小应用程序，让你彻底卸载不需要的应用程序。[推荐] Cleaner for Xcode - Xcode 的清理工具，清理几十G应该不是问题。(https://github.com/waylybaye/XcodeCleaner) [推荐] BetterZip 3 - 压缩解压缩工具支持格式 ZIP、TAR、TGZ、TBZ、TXZ (new)、7-ZIP、RAR。 [推荐] [必备] DNS Heaven - 可以令基于 glibc 的 macOS 应用直接使用原生栈来解析 DNS，主要适用于 VPN。 (https://github.com/greenboxal/dns-heaven) The Unarchiver - 解压许多不同种类的归档压缩文件。 (https://bitbucket.org/kosovan/theunarchiver) Keka - 一个免费的 macOS 文件解压缩程序。 (https://sourceforge.net/projects/keka/) [推荐] Numi - 漂亮的计算器应用。 Memo - 给你的便笺加个密。(https://itunes.apple.com/app/id1212409035) Fantastical - 日历应用程序，你将管理好生活。[推荐] Day-O 2 - 菜单日历更换内置日历。 OnyX - 多功能实用工具来验证磁盘和文件，运行清洁和系统维护任务，配置隐藏选项等。 Focus - 一个漂亮的番茄工作法为基础的时间管理工具。 (https://itunes.apple.com/us/app/focus-productivity-timer/id777233759?mt=12) SSH Tunnel - 管理你的SSH。 Mounty - NTFS 分区读写组件。 Paragon NTFS - 在Mac OS X中完全读写、修改、访问Windows NTFS硬盘、U盘等外接设备的文件。 Tuxera NTFS - Mac上的NTFS文件系统驱动。 gfxCardStatus - 控制Mac独立显卡与集成显卡之间的切换。[推荐] openEmu - 模拟器，可以玩魂斗罗之类，放松回到小时候。(https://github.com/OpenEmu/OpenEmu) [推荐] Porting Kit - 在Mac中安装Windows®游戏 Alfred - 效率神器。[推荐] Hammerspoon - 功能强大的自动化工具，Lua 脚本驱动，支持窗口管理。(https://github.com/Hammerspoon/hammerspoon) DaisyDisk - 磁盘空间使用扫描工具。 OmniDiskSweeper - 磁盘空间使用扫描工具。 [推荐] iStat pro - 免费的Mac OS电脑硬件信息检测软件。 BitBar - 支持使用各种语言将信息展示到Mac OS的菜单栏。(https://github.com/matryer/bitbar) CopyQ - 高级功能剪贴板管理工具。 (https://github.com/hluk/CopyQ) ClipMenu - 一个剪贴板操作的管理器。(https://github.com/naotaka/ClipMenu) Paste - 智能剪贴板历史片段管理。 (https://itunes.apple.com/us/app/paste-clipboard-history-manager/id967805235) iPaste - 简洁高效的剪贴板增加工具。(https://itunes.apple.com/cn/app/id1056935452?ls=1&amp;mt=12&amp;at=1000lv4R&amp;ct=iPaste_me) ControlPlane - 自定义Mac情景模式。某些场景让Mac自动静音或是自动打开Mail客户端等等。(https://github.com/dustinrue/ControlPlane) Caffeine - 实用工具，菜单栏按钮，点击休眠。 Itsycal - 一款简洁实用的开源日历工具。(https://github.com/sfsam/itsycal) HTML5 Player - Chrome插件解决中国视频网站播放视频电脑发热的情况。 Monity - 帮助用户实时监控系统的一款非常漂亮的软件。 BetterTouchTool - 代替默认的系统操作方式（组合键、修饰键、手势等）。 iStats - iStats 是一个可以让你快速查看电脑 CPU 温度，磁盘转速和电池等信息的命令行工具。 (https://github.com/Chris911/iStats) Juice - 让电池显示更有趣 (https://github.com/brianmichel/Juice) NitroShare - 跨平台网络文件传输应用程序。 (https://github.com/nitroshare/nitroshare-desktop) InsomniaX - 合上盖子不眠不休，继续听歌下载。 NoSleep - 合上盖子不休眠，可根据是否连接电源单独设置。 Coolant - 这是能让你知道什么应用程序造成你CPU100%让Mac电脑过热电池耗尽的菜单应用程序。 HandShaker - Mac 电脑上也可以方便自如地管理您在 Android 手机中的内容。 Magnet - 一个窗口管理器，可以保持工作空间的组织。 (https://itunes.apple.com/app/id441258766) Qbserve - 观察你如何度过你的时间。 Vanilla - 隐藏系统菜单栏。 HTTrack - 可以下载整个网站和离线浏览。 窗口管理 ShiftIt - 窗口位置和大小管理软件。 (https://github.com/fikovnik/ShiftIt) [推荐] [必备] Moom - 多任务多窗口的软件。 Slate - 窗口管理器，可用JavaScript写配置。(https://github.com/jigish/slate) Amethyst - 窗口管理器（自动保持窗口大小的窗口）。(https://github.com/ianyh/Amethyst) Spectacle - 简单的移动和调整大小的窗口，和可定制的键盘快捷键。 (https://github.com/eczarny/spectacle) 密码管理 RememBear - 治愈系密码管理工具。 1password - 跨平台帐号密码管理软件。 [推荐] [必备] LastPass - 密码管理器和安全的数字笔记。 KeePassX - 一个免费的，开源的，体积小的密码管理器。(https://github.com/keepassx/keepassx) MacPass - 密码管理器。(https://github.com/mstarke/MacPass) Keeweb - 与KeePass兼容的免费跨平台密码管理器。 (https://github.com/keeweb/keeweb) Quicklook-Plugins - Finder快速预览文件插件。 fman - 先进的双窗口文件管理器, 拥有很多特性。 ForkLift - 先进的双窗口文件管理器和文件传输客户端。 Path Finder - 强大的Finder替代者，拥有很多特性。 TotalFinder - 强大的Finder替代者，界面风格像Chrome。 XtraFinder - 给Finder添加有用的新特性。 Hazel - 设计精美的自动文件管理软件。 MacAssistant - Google 助手 (https://github.com/vanshg/MacAssistant) 远程协助 TeamViewer - 远程协助及在线协作和会议功能的软件，商业软件个人使用免费。[推荐] [必备] RealVNC 是一款免费的远程控制跨多平台的程序。 AnyDesk 是一款远程控制跨多平台的程序。 QuickLook插件*使用 Homebrew Cask 将通过命令安装即为简单。 QuicklookStephen - 可以让您查看没有文件扩展名的纯文本文件，如README、INSTALL、Capfile、CHANGELOG…brew cask install qlstephen QLColorCode - 在预览源代码文件，高亮代码。brew cask install qlcolorcode QLMarkdown - Markdown文件转换成静态页面预览。brew cask install qlmarkdown QuickLookJSON - 格式化预览JSON文件。brew cask install quicklook-json QLPrettyPatch - 预览.patch文件。brew cask install qlprettypatch QuickLookCSV - 预览.CSV文件。brew cask install quicklook-csv BetterZipQL - 预览BetterZip软件的压缩格式文件。brew cask install betterzipql qlImageSize - 显示图像大小和分辨率。brew cask install qlimagesize WebP - 预览WebP图像。brew cask install webpquicklook Suspicious Package - 预览Apple安装程序包的标准内容。brew cask install suspicious-package QuickLookASE - 预览使用Photoshop，Illustrator，Prisma等生成的Adobe ASE Color色板等。brew cask install quicklookase QLVideo - 预览大多数类型的视频文件，以及它们的缩略图，封面和元数据。brew cask install qlvideo QuickLookAPK - 预览Android APK文件。brew cask install quicklookapk ProvisionQL - 预览 iOS/macOS 应用和配置信息。brew cask install provisionql quicklook-pat - 预览Adobe Photoshop图案文件。brew cask install quicklook-pat 第三方应用市场APP这里讨论盗版问题或者提供黑名单？，拒绝盗版从我做起，欢迎大家监督。 正版这里只提供正版软件购买下载的应用商店。 HackStore - 一个类似于cydia的第三方Mac应用市场，平台拒绝盗版。 [推荐] MacUpdate Desktop - 管理/更新/下载App，跟踪优惠信息。 Homebrew Cask - 基于Homebrew扩展的，通过命令行安装Mac GUI软件的工具。(https://github.com/caskroom/homebrew-cask) Homebrew - 体验通过命令行安装Mac软件的工具(大部分是命令行工具)。(https://github.com/Homebrew/brew/) MacPorts - 一个软件包管理系统，可用于简化OS X和Darwin操作系统内软件的安装。 (https://github.com/macports/) 应用商店黑名单第三方应用市场APP黑名单，存在盗版软件传播和下载，拒绝盗版从我做起，欢迎大家监督它们。 腾讯电脑管家 - 电脑管家for Mac 带应用市场。 迅雷Thunder Store - 迅雷Thunder for Mac 带应用市场。 Mac软件宝箱 - Macx推出软件宝箱。 MacHunter - Mac应用市场。 Mac软件下载网站这里主要是推荐一些软件下载的网站，还有一些Mac OSX软件分享网站 正版/介绍 MacUpdate：https://www.macupdate.com/ App Shopper：http://appshopper.com/ 类似于iOS上Cydia一样的第三方软件商店：http://hack-store.com 少数派：http://sspai.com/tag/Mac Mac玩儿法：http://www.waerfa.com [推荐] 盗版软件下载网站黑名单上面有大量的开源软件或者免费软件，拒绝盗版从我做起，下面被删除的网站提供大量破解软件下载，欢迎大家监督它们。 玩转苹果：http://www.ifunmac.com Mac软件下载站：http://www.pshezi.com MacPeers：http://www.macpeers.com Mac志：http://www.isofts.org Mac软件分享：http://www.waitsun.com AppKed：http://www.macbed.com 苹果软件园：http://www.maczapp.com Mac精品软件：http://xclient.info/ Macx：https://www.macx.cn/ 腾牛网：http://www.qqtn.com/mac/r_17_1.html 未来软件园：http://www.orsoon.com/mac/ ⬆ 返回顶部","tags":[{"name":"mac","slug":"mac","permalink":"http://kingle.online/tags/mac/"},{"name":"软件","slug":"软件","permalink":"http://kingle.online/tags/软件/"}]},{"title":"三栏布局","date":"2018-01-13T14:32:15.000Z","path":"2018/01/13/三栏布局/","text":"三栏布局问题描述：假设高度已知，请写出三栏布局，其中左栏、右栏宽度各位300px，中间自适应. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;Layout&lt;/title&gt; &lt;style media=\"screen\"&gt; html *&#123; padding: 0; margin: 0; &#125; .layout article div&#123; min-height: 100px; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;!--浮动布局 --&gt; &lt;section class=\"layout float\"&gt; &lt;style media=\"screen\"&gt; .layout.float .left&#123; float:left; width:300px; background: red; &#125; .layout.float .center&#123; background: yellow; &#125; .layout.float .right&#123; float:right; width:300px; background: blue; &#125; &lt;/style&gt; &lt;h1&gt;三栏布局&lt;/h1&gt; &lt;article class=\"left-right-center\"&gt; &lt;div class=\"left\"&gt;&lt;/div&gt; &lt;div class=\"right\"&gt;&lt;/div&gt; &lt;div class=\"center\"&gt; &lt;h2&gt;浮动解决方案&lt;/h2&gt; 1.这是三栏布局的浮动解决方案； 2.这是三栏布局的浮动解决方案； 3.这是三栏布局的浮动解决方案； 4.这是三栏布局的浮动解决方案； 5.这是三栏布局的浮动解决方案； 6.这是三栏布局的浮动解决方案； &lt;/div&gt; &lt;/article&gt; &lt;/section&gt; &lt;!-- 绝对布局 --&gt; &lt;section class=\"layout absolute\"&gt; &lt;style&gt; .layout.absolute .left-center-right&gt;div&#123; position: absolute; &#125; .layout.absolute .left&#123; left:0; width: 300px; background: red; &#125; .layout.absolute .center&#123; left: 300px; right: 300px; background: yellow; &#125; .layout.absolute .right&#123; right:0; width: 300px; background: blue; &#125; &lt;/style&gt; &lt;h1&gt;三栏布局&lt;/h1&gt; &lt;article class=\"left-center-right\"&gt; &lt;div class=\"left\"&gt;&lt;/div&gt; &lt;div class=\"center\"&gt; &lt;h2&gt;绝对定位解决方案&lt;/h2&gt; 1.这是三栏布局的浮动解决方案； 2.这是三栏布局的浮动解决方案； 3.这是三栏布局的浮动解决方案； 4.这是三栏布局的浮动解决方案； 5.这是三栏布局的浮动解决方案； 6.这是三栏布局的浮动解决方案； &lt;/div&gt; &lt;div class=\"right\"&gt;&lt;/div&gt; &lt;/article&gt; &lt;/section&gt; &lt;!-- flexbox布局 --&gt; &lt;section class=\"layout flexbox\"&gt; &lt;style&gt; .layout.flexbox&#123; margin-top: 110px; &#125; .layout.flexbox .left-center-right&#123; display: flex; &#125; .layout.flexbox .left&#123; width: 300px; background: red; &#125; .layout.flexbox .center&#123; flex:1; background: yellow; &#125; .layout.flexbox .right&#123; width: 300px; background: blue; &#125; &lt;/style&gt; &lt;h1&gt;三栏布局&lt;/h1&gt; &lt;article class=\"left-center-right\"&gt; &lt;div class=\"left\"&gt;&lt;/div&gt; &lt;div class=\"center\"&gt; &lt;h2&gt;flexbox解决方案&lt;/h2&gt; 1.这是三栏布局的浮动解决方案； 2.这是三栏布局的浮动解决方案； 3.这是三栏布局的浮动解决方案； 4.这是三栏布局的浮动解决方案； 5.这是三栏布局的浮动解决方案； 6.这是三栏布局的浮动解决方案； &lt;/div&gt; &lt;div class=\"right\"&gt;&lt;/div&gt; &lt;/article&gt; &lt;/section&gt; &lt;!-- 表格布局 --&gt; &lt;section class=\"layout table\"&gt; &lt;style&gt; .layout.table .left-center-right&#123; width:100%; height: 100px; display: table; &#125; .layout.table .left-center-right&gt;div&#123; display: table-cell; &#125; .layout.table .left&#123; width: 300px; background: red; &#125; .layout.table .center&#123; background: yellow; &#125; .layout.table .right&#123; width: 300px; background: blue; &#125; &lt;/style&gt; &lt;h1&gt;三栏布局&lt;/h1&gt; &lt;article class=\"left-center-right\"&gt; &lt;div class=\"left\"&gt;&lt;/div&gt; &lt;div class=\"center\"&gt; &lt;h2&gt;表格布局解决方案&lt;/h2&gt; 1.这是三栏布局的浮动解决方案； 2.这是三栏布局的浮动解决方案； 3.这是三栏布局的浮动解决方案； 4.这是三栏布局的浮动解决方案； 5.这是三栏布局的浮动解决方案； 6.这是三栏布局的浮动解决方案； &lt;/div&gt; &lt;div class=\"right\"&gt;&lt;/div&gt; &lt;/article&gt; &lt;/section&gt; &lt;!-- 网格布局 --&gt; &lt;section class=\"layout grid\"&gt; &lt;style&gt; .layout.grid .left-center-right&#123; width:100%; display: grid; grid-template-rows: 100px; grid-template-columns: 300px auto 300px; &#125; .layout.grid .left-center-right&gt;div&#123; &#125; .layout.grid .left&#123; width: 300px; background: red; &#125; .layout.grid .center&#123; background: yellow; &#125; .layout.grid .right&#123; background: blue; &#125; &lt;/style&gt; &lt;h1&gt;三栏布局&lt;/h1&gt; &lt;article class=\"left-center-right\"&gt; &lt;div class=\"left\"&gt;&lt;/div&gt; &lt;div class=\"center\"&gt; &lt;h2&gt;网格布局解决方案&lt;/h2&gt; 1.这是三栏布局的浮动解决方案； 2.这是三栏布局的浮动解决方案； 3.这是三栏布局的浮动解决方案； 4.这是三栏布局的浮动解决方案； 5.这是三栏布局的浮动解决方案； 6.这是三栏布局的浮动解决方案； &lt;/div&gt; &lt;div class=\"right\"&gt;&lt;/div&gt; &lt;/article&gt; &lt;/section&gt; &lt;/body&gt;&lt;/html&gt; 效果","tags":[{"name":"html","slug":"html","permalink":"http://kingle.online/tags/html/"},{"name":"布局","slug":"布局","permalink":"http://kingle.online/tags/布局/"}]},{"title":"百度云倍速播放解决办法","date":"2018-01-10T15:50:28.000Z","path":"2018/01/10/百度云倍速播放解决办法/","text":"我平时在慕课或者其他视频网站上学习的时候，非常需要将速度加快播放，但是一些在百度云保存的视频用它网络自带的播放器一般都不能倍速播放。于是…. chrome/Firefox插件安装 对于chrome:video-speed-controller 插件 对于Firefoxvideo-speed-controller 插件.png 效果以及使用方法可以看见安装之后播放视频，在左上角就有一个播放按钮，如下图： 加速按钮 特别注意：只有在这种页面下才会显示按钮，如下图（请仔细观察）也就是说，比如我给你分享一个慕课的实战课程：链接: https://pan.baidu.com/s/1thB7rXBD1Poo0Wn8oipEsQ 密码: qfcx点击进去就是下面这个页面，也就能加速播放 能加速播放的页面 但是如果在自己的百度云账号下，是不能显示加速按钮的： 无法看见加速按钮 所以我的解决办法，自己申请两个百度云账号，一个用来分享视频，另外一个在点击分享链接的时候就可以加速播放了。如下图就是两个百度云账号： 账号 另外，自己给自己分享也是不能加速播放的，如下图： 无法加速","tags":[{"name":"百度云","slug":"百度云","permalink":"http://kingle.online/tags/百度云/"}]},{"title":"Debian8-Server安装LEMP-nginx,MySQL/MariaDB,PHP","date":"2017-05-28T22:29:29.000Z","path":"2017/05/29/Debian8-Server安装LEMP-nginx-MySQL-MariaDB-PHP/","text":"转载自linux大神博客 原文链接 LNMP是一组用于搭建网站的开源软件。LNMP代表Linux操作系统、Ngnix HTTP服务器(发音为Engine X)、MySQL/MariaDB数据库和PHP。在这篇教程中，我将介绍如何在Debian 8 服务器上安装LNMP。数据库选择MariaDB, 并安装最新的PHP7. 以下命令在Debian服务器上执行。 安装Nginx相对于Apache，Nginx是一个轻量级的高性能web服务器并在近年来越来越流行。Nginx也可以同时作为一个反向代理。在Debian8上安装Nginx, 输入下面的命令。 1sudo apt-get install nginx -y 安装完成后，Nginx会自动运行。12$ sudo service nginx status[ ok ] nginx is running. 查看Nginx版本12$ nginx -vnginx version: nginx/1.6.2 在浏览器地址栏中输入Debian服务器的IP, 回车。如果你看到下面的文字，说明Nginx正确地安装好了。 你可以使用下面的命令查看服务器的IP。1curl http://icanhazip.com 安装MariaDBMariaDB是MySQL的一个替代品。使用下面的命令安装：1sudo apt-get install -y mariadb-server mariadb-client 在安装过程中会要求你为MariaDB root用户设置一个密码。输入密码后按回车。记住，MariaDB root用户是数据库的管理员，与Linux的root用户是不同的。 再次输入密码并回车。 查看MariaDB版本 12$ mysql --versionmysql Ver 15.1 Distrib 10.0.22-MariaDB, for debian-linux-gnu (x86_64) using readline 5.2 运行安全脚本 1sudo mysql_secure_installation 输入MariaDB root用户密码。当它问你是否要更改root密码时，选择n. 然后你可以一路按回车键来回答其他所有的问题。 MariaDB数据库安装完成。 或者安装mysql1sudo apt-get install mysql-server mysql-client 过程中会提示你设置Mysql的密码，就跟平时的密码设置一样，一 次输入，一次确认。密码确认完毕后基本等一会就安装好了。尝试1mysql -u root -p 如果登录成功，那Mysql就正确安装了. 安装PHP7在/etc/apt/sources.list文件中添加下面两行文字以安装dotdeb.org软件源。12deb http://packages.dotdeb.org jessie alldeb-src http://packages.dotdeb.org jessie all 下载并安装GnuPG key12wget https://www.dotdeb.org/dotdeb.gpgsudo apt-key add dotdeb.gpg 更新本地软件包索引并安装PHP7123sudo apt-get updatesudo apt-get install php7.0-fpm php7.0-mysql php7.0-common php7.0-gd php7.0-json php7.0-cli php7.0-curl 配置PHP7 编辑php.ini文件1sudo vi /etc/php/7.0/fpm/php.ini 找到如下一行1;cgi.fix_pathinfo=1 去掉前面的分号，并将1改为0 1cgi.fix_pathinfo=0 保存文件后重启php7.0-fpm1sudo service php7.0-fpm restart 配置Nginx Virtual Host在/etc/nginx/sites-available目录下创建一个新的virtual host配置文件 1sudo vi /etc/nginx/sites-available/yourdomain.conf 将yourdomain替换成你实际的域名。然后在文件中添加下面的配置。12345678910111213141516171819202122232425server &#123;listen 80;server_name yourdoman.com www.yourdomain.com;root /var/www/html;index index.php index.html index.htm index.nginx-debian.html;location / &#123;try_files $uri $uri/ =404;&#125;error_page 404 /404.html;error_page 500 502 503 504 /50x.html;location = /50x.html &#123;root /var/www/html;&#125;location ~ \\.php$ &#123;try_files $uri =404;fastcgi_pass unix:/run/php/php7.0-fpm.sock;fastcgi_index index.php;fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;include fastcgi_params;&#125;&#125; 注意，上面第4行 root /var/www/html; 中的root是指网站的根目录，而不是指Linux系统的root用户。 保存文件后，创建一个软链接。1sudo ln -s /etc/nginx/sites-available/yourdomain.conf /etc/nginx/sites-enabled/yourdomain.conf 测试Nginx配置1sudo nginx -t 测试成功：12nginx: the configuration file /etc/nginx/nginx.conf syntax is oknginx: configuration file /etc/nginx/nginx.conf test is successful 重新加载Nginx配置1sudo service nginx reload 将/var/www/html目录的所有者更改为Nginx用户www-data1sudo chown www-data:www-data /var/www/* -R 测试PHP 在/var/www/html/目录下新建一个文件info.php1sudo vi /var/www/html/info.php 将下面的内容粘贴到info.php文件中。123&lt;?php phpinfo();?&gt; 保存文件。然后在浏览器的地址栏输入下面的地址。1yourdomain.com/info.php 用你的实际域名替换yourdomain.com. 如果你看见下面的文字，说明PHP运行正常。 请确保你已经为你的域名设置好了一个A记录。 info.php文件只是用于测试的。为了安全起见，你可以删除它。好了！现在你应该成功地在Debian 8 Jessie上搭建好了LNMP. 502 Bad Gateway如果你在测试PHP时网页显示502 Bad Gateway错误。那么很有可能是nginx服务器fastcgi_pass的值与PHP www.conf文件中 listen的值不一致造成的。 打开你的virtual host文件。1sudo vi /etc/nginx/sites-available/yourdomain.conf 查看fastcgi_pass的值。 再打开php的www.conf文件。1sudo vi /etc/php/7.0/fpm/pool.d/www.conf 找到文件中的listen这一行，我们需要让nginx fastcgi_pass的值与php listen的值一致。修改完后重启nginx进程和php-fpm进程，这时502 bad gateway错误应该就解决了，可以正常打开网页了。 另外/run/php/php7.0-dpm.sock文件的所有者要与nginx进程用户www-data一致．123ls /run/php/php7.0-fpm.sock -lhsrw-rw---- 1 www-data www-data 0 Mar 19 03:31 /run/php/php7.0-fpm.sock","tags":[{"name":"Debian","slug":"Debian","permalink":"http://kingle.online/tags/Debian/"},{"name":"nginx","slug":"nginx","permalink":"http://kingle.online/tags/nginx/"},{"name":"mysql","slug":"mysql","permalink":"http://kingle.online/tags/mysql/"},{"name":"php","slug":"php","permalink":"http://kingle.online/tags/php/"}]},{"title":"Debian8-Server安装LEMP-nginx,MySQL/MariaDB,PHP","date":"2017-05-28T22:29:29.000Z","path":"2017/05/29/Debian8-Server安装LEMP-nginx-MySQL-MariaDB-PHP (kingle的MacBook Pro 的冲突副本 2018-04-09)/","text":"转载自linux大神博客 原文链接 LNMP是一组用于搭建网站的开源软件。LNMP代表Linux操作系统、Ngnix HTTP服务器(发音为Engine X)、MySQL/MariaDB数据库和PHP。在这篇教程中，我将介绍如何在Debian 8 服务器上安装LNMP。数据库选择MariaDB, 并安装最新的PHP7. 以下命令在Debian服务器上执行。 安装Nginx相对于Apache，Nginx是一个轻量级的高性能web服务器并在近年来越来越流行。Nginx也可以同时作为一个反向代理。在Debian8上安装Nginx, 输入下面的命令。 1sudo apt-get install nginx -y 安装完成后，Nginx会自动运行。12$ sudo service nginx status[ ok ] nginx is running. 查看Nginx版本12$ nginx -vnginx version: nginx/1.6.2 在浏览器地址栏中输入Debian服务器的IP, 回车。如果你看到下面的文字，说明Nginx正确地安装好了。 你可以使用下面的命令查看服务器的IP。1curl http://icanhazip.com 安装MariaDBMariaDB是MySQL的一个替代品。使用下面的命令安装：1sudo apt-get install -y mariadb-server mariadb-client 在安装过程中会要求你为MariaDB root用户设置一个密码。输入密码后按回车。记住，MariaDB root用户是数据库的管理员，与Linux的root用户是不同的。 再次输入密码并回车。 查看MariaDB版本 12$ mysql --versionmysql Ver 15.1 Distrib 10.0.22-MariaDB, for debian-linux-gnu (x86_64) using readline 5.2 运行安全脚本 1sudo mysql_secure_installation 输入MariaDB root用户密码。当它问你是否要更改root密码时，选择n. 然后你可以一路按回车键来回答其他所有的问题。 MariaDB数据库安装完成。 或者安装mysql1sudo apt-get install mysql-server mysql-client 过程中会提示你设置Mysql的密码，就跟平时的密码设置一样，一 次输入，一次确认。密码确认完毕后基本等一会就安装好了。尝试1mysql -u root -p 如果登录成功，那Mysql就正确安装了. 安装PHP7在/etc/apt/sources.list文件中添加下面两行文字以安装dotdeb.org软件源。12deb http://packages.dotdeb.org jessie alldeb-src http://packages.dotdeb.org jessie all 下载并安装GnuPG key12wget https://www.dotdeb.org/dotdeb.gpgsudo apt-key add dotdeb.gpg 更新本地软件包索引并安装PHP7123sudo apt-get updatesudo apt-get install php7.0-fpm php7.0-mysql php7.0-common php7.0-gd php7.0-json php7.0-cli php7.0-curl 配置PHP7 编辑php.ini文件1sudo vi /etc/php/7.0/fpm/php.ini 找到如下一行1;cgi.fix_pathinfo=1 去掉前面的分号，并将1改为0 1cgi.fix_pathinfo=0 保存文件后重启php7.0-fpm1sudo service php7.0-fpm restart 配置Nginx Virtual Host在/etc/nginx/sites-available目录下创建一个新的virtual host配置文件 1sudo vi /etc/nginx/sites-available/yourdomain.conf 将yourdomain替换成你实际的域名。然后在文件中添加下面的配置。12345678910111213141516171819202122232425server &#123;listen 80;server_name yourdoman.com www.yourdomain.com;root /var/www/html;index index.php index.html index.htm index.nginx-debian.html;location / &#123;try_files $uri $uri/ =404;&#125;error_page 404 /404.html;error_page 500 502 503 504 /50x.html;location = /50x.html &#123;root /var/www/html;&#125;location ~ \\.php$ &#123;try_files $uri =404;fastcgi_pass unix:/run/php/php7.0-fpm.sock;fastcgi_index index.php;fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;include fastcgi_params;&#125;&#125; 注意，上面第4行 root /var/www/html; 中的root是指网站的根目录，而不是指Linux系统的root用户。 保存文件后，创建一个软链接。1sudo ln -s /etc/nginx/sites-available/yourdomain.conf /etc/nginx/sites-enabled/yourdomain.conf 测试Nginx配置1sudo nginx -t 测试成功：12nginx: the configuration file /etc/nginx/nginx.conf syntax is oknginx: configuration file /etc/nginx/nginx.conf test is successful 重新加载Nginx配置1sudo service nginx reload 将/var/www/html目录的所有者更改为Nginx用户www-data1sudo chown www-data:www-data /var/www/* -R 测试PHP 在/var/www/html/目录下新建一个文件info.php1sudo vi /var/www/html/info.php 将下面的内容粘贴到info.php文件中。123&lt;?php phpinfo();?&gt; 保存文件。然后在浏览器的地址栏输入下面的地址。1yourdomain.com/info.php 用你的实际域名替换yourdomain.com. 如果你看见下面的文字，说明PHP运行正常。 请确保你已经为你的域名设置好了一个A记录。 info.php文件只是用于测试的。为了安全起见，你可以删除它。好了！现在你应该成功地在Debian 8 Jessie上搭建好了LNMP. 502 Bad Gateway如果你在测试PHP时网页显示502 Bad Gateway错误。那么很有可能是nginx服务器fastcgi_pass的值与PHP www.conf文件中 listen的值不一致造成的。 打开你的virtual host文件。1sudo vi /etc/nginx/sites-available/yourdomain.conf 查看fastcgi_pass的值。 再打开php的www.conf文件。1sudo vi /etc/php/7.0/fpm/pool.d/www.conf 找到文件中的listen这一行，我们需要让nginx fastcgi_pass的值与php listen的值一致。修改完后重启nginx进程和php-fpm进程，这时502 bad gateway错误应该就解决了，可以正常打开网页了。 另外/run/php/php7.0-dpm.sock文件的所有者要与nginx进程用户www-data一致．123ls /run/php/php7.0-fpm.sock -lhsrw-rw---- 1 www-data www-data 0 Mar 19 03:31 /run/php/php7.0-fpm.sock","tags":[{"name":"Debian","slug":"Debian","permalink":"http://kingle.online/tags/Debian/"},{"name":"nginx","slug":"nginx","permalink":"http://kingle.online/tags/nginx/"},{"name":"mysql","slug":"mysql","permalink":"http://kingle.online/tags/mysql/"},{"name":"php","slug":"php","permalink":"http://kingle.online/tags/php/"}]},{"title":"python-Matplotlib基础绘图函数","date":"2017-05-13T16:48:37.000Z","path":"2017/05/14/python-Matplotlib基础绘图函数/","text":"pyplot的基础图标函数列表一共有16种 pyplot饼图的绘制plt.pie()代码：12345678910import matplotlib.pyplot as pltlabels = 'Frogs', 'Hogs', 'Dogs', 'Logs'sizes = [15, 30, 45, 10]explode = (0, 0.1, 0, 0)plt.pie(sizes, explode=explode, labels=labels, autopct='%1.1f%%', shadow=False, startangle=90)plt.axis('equal')plt.show() 效果： pyplot直方图的绘制plt.hist()代码：1234567891011import numpy as npimport matplotlib.pyplot as pltnp.random.seed(0)mu, sigma = 100, 20 #均值和标准差a = np.random.normal(mu, sigma, size = 100)# 20可以控制区间分级的数量,即直方图的个数plt.hist(a, 20, normed = 1, histtype = 'stepfilled', facecolor='b', alpha=0.75)plt.title('Histogram')plt.show() 效果： pyplot极坐标图的绘制代码：123456789101112131415import numpy as npimport matplotlib.pyplot as pltN = 20theta = np.linspace(0.0, 2 * np.pi, N, endpoint = False)radii = 10 * np.random.rand(N)width = np.pi / 4 * np.random.rand(N)ax = plt.subplot(111, projection='polar')bars = ax.bar(theta, radii, width=width, bottom=0.0) #分别对应left, height, widthfor r, bar in zip(radii, bars): bar.set_facecolor(plt.cm.viridis(r / 10.)) bar.set_alpha(0.5)plt.show() 效果: pyplot散点图的绘制代码：12345678import numpy as npimport matplotlib.pyplot as pltfig, ax = plt.subplots()ax.plot(10 * np.random.randn(100), 10 * np.random.randn(100), 'o')ax.set_title('Simple Scatter')plt.show()","tags":[{"name":"python","slug":"python","permalink":"http://kingle.online/tags/python/"},{"name":"Matplotlib","slug":"Matplotlib","permalink":"http://kingle.online/tags/Matplotlib/"}]},{"title":"python-Matplotlib库入门笔记","date":"2017-05-12T21:33:28.000Z","path":"2017/05/13/python-Matplotlib库入门笔记/","text":"http://matplotlib.org/ Matplotlib库由各种可视化类构成，内部结构复杂，受Matlab启发 matplotlib.pyplot是绘制各类可视化图形的命令子库，相当于快捷方式 12#引入模块的别名import matplotlib.pyplot as plt Matplotlib库小测12345import matplotlib.pyplot as pltplt.plot([3, 1, 4, 5, 2])plt.ylabel(\"Grade\")plt.show() 123456import matplotlib.pyplot as pltplt.plot([3, 1, 4, 5, 2])plt.ylabel(\"Grade\")plt.savefig('test', dpi=600) #PNG文件plt.show() plt.savefig()将输出图形存储为文件，默认PNG格式，可以通过dpi修改输出质量 12345import matplotlib.pyplot as pltplt.plot([0, 2, 4, 6, 8], [3, 1, 4, 5, 2])plt.ylabel(\"Grade\")plt.axis([-1, 10, 0, 6]) #x, y的取值范围plt.show() plt.plot(x,y)当有两个以上参数时，按照X轴和Y轴顺序绘制数据点 pyplot的绘图区域1plt.subplot(nrows, ncols, plot_number) 在全局绘图区域中创建一个 分区体系，并定位到一个子 绘图区域12plt.subplot(3,2,4)#plt.subplot(324) 123456789101112import numpy as npimport matplotlib.pyplot as pltdef f(t): return np.exp(-t) * np.cos(2 * np.pi * t)a = np.arange(0.0, 5.0, 0.02)plt.subplot(211)plt.plot(a, f(a))plt.subplot(2, 1, 2)plt.plot(a, np.cos(2 * np.pi * a), 'g--')plt.show() pyplot的plot()函数1plt.plot(x, y, format_string, **kwargs) x: X轴数据，列表或数组，可选 y: Y轴数据，列表或数组 format_string: 控制曲线的格式字符串，可选 **kwargs: 第二组或更多(x,y,format_string) 当绘制多条曲线时，各条曲线的x不能省略 123456import matplotlib.pyplot as pltimport numpy as npa = np.arange(10)plt.plot(a, a*1.5, a, a*2,5, a, a*3.5, a, a*4.5)plt.show() format_string: 控制曲线的格式字符串，可选 由颜色字符、风格字符和标记字符组成 颜色字符 说明 颜色字符 说明 ‘b’ 蓝色 ‘m’ 洋红色 magenta ‘g’ 绿色 ‘y’ 黄色 ‘r’ 红色 ‘k’ 黑色 ‘c’ 青绿色cyan ‘w’ 白色 ‘#008000’ RGB某颜色 ‘0.8’ 灰度字符串 风格字符 说明 ‘-‘ 实现 ‘–’ 破折线 ‘-.’ 点画线 ‘:’ 虚线 ‘’ ‘’ 无线条 pyplot的中文显示 pyplot并不默认支持中文显示，需要rcParams修改字体实现 12345678import matplotlib.pyplot as pltimport matplotlibmatplotlib.rcParams['font.family'] = 'SimHei'plt.plot([3, 1, 4, 5, 2])plt.ylabel(\"纵轴值\")plt.savefig('test', dpi=600)plt.show() 但是在Mac上依旧有些中文字体不支持，所以可以通过字体册软件，找到对应的字体，然后添加进来，如下：123456789import matplotlib.pyplot as pltimport matplotlibfrom matplotlib.font_manager import FontPropertiesfonts = FontProperties(fname = \"/System/Library/Fonts/STHeiti Light.ttc\", size = 14)plt.plot([3, 1, 4, 5, 2])plt.ylabel(\"纵轴值\", FontProperties = fonts)plt.savefig('test', dpi = 600)plt.show() pyplot的文本显示函数 实例12345678910111213141516import numpy as npimport matplotlib.pyplot as pltfrom matplotlib.font_manager import FontPropertiesfonts = FontProperties(fname = \"/System/Library/Fonts/STHeiti Light.ttc\", size = 14)a = np.arange(0.0, 5.0, 0.02)plt.plot(a, np.cos(2 * np.pi * a), 'r--')plt.xlabel('横轴：时间', fontproperties = fonts, color = 'green')plt.ylabel('纵轴：振幅', fontproperties = fonts)plt.title(r'正玄波实例$y = cos(2\\pi x)$', FontProperties =fonts, fontsize = 25)plt.text(2, 1, r'$\\mu = 100$') #Latex，2，1表示位置plt.axis([-1, 6, -2, 2])plt.grid(True) #显示网格plt.show() pyplot的子绘图区域1plt.subplot2grid(GridSpec, CurSpec, colspan=1, rowspan=1) 理念:设定网格，选中网格，确定选中行列区域数量，编号从0开始 1plt.subplot2grid((3,3), (1,0), colspan=2) # rowspan GridSpec类123456789import matplotlib.gridspec as gridspecgs = gridspec.GridSpec(3, 3)ax1 = plt.subplot(gs[0, :])ax1 = plt.subplot(gs[1, :-1])ax1 = plt.subplot(gs[1:, -1])ax1 = plt.subplot(gs[2, 0])ax1 = plt.subplot(gs[2, 1])","tags":[{"name":"python","slug":"python","permalink":"http://kingle.online/tags/python/"},{"name":"Matplotlib","slug":"Matplotlib","permalink":"http://kingle.online/tags/Matplotlib/"}]},{"title":"atom/sublimeText/vscode插件","date":"2017-05-06T21:57:39.000Z","path":"2017/05/07/atom-sublimeText-vscode/","text":"atom atom-beautify autocomplete-paths busy-signal color-picker csscomb docblockr emmet file-icons git-plus intentions javascript-snippets linter linter-eslint linter-ui-default livestyle-atom minimap pigments platformio-ide-terminal sublime-text A File Icon Alignment All Autocomplete AutoFileName Autoprefixer Bootstrap 3 Snippets BracketHighlighter Color Highlighter Emmet Git HTML-CSS-JS Prettify HTML5 Jquery Markdown Preview One Dark Material - Theme Package Control Sass SideBarEnhancements SublimeLinter SublimeLinter-contrib-eslint Terminal Theme -Soda vscode Auto Rename Tag AutoFileName Beautify c/c++ Color Picker ESLint Git History HTML CSS Support jQuery Code Snippets motss HTML snippets vscode-icons","tags":[{"name":"atom","slug":"atom","permalink":"http://kingle.online/tags/atom/"},{"name":"sublimeText","slug":"sublimeText","permalink":"http://kingle.online/tags/sublimeText/"},{"name":"vscode","slug":"vscode","permalink":"http://kingle.online/tags/vscode/"}]},{"title":"iTerm2快捷键","date":"2017-05-01T14:12:17.000Z","path":"2017/05/01/iTerm2快捷键/","text":"标签新建标签：command + t 关闭标签：command + w 切换标签：command + 数字 command + 左右方向键 切换全屏：command + enter 查找：command + f 分屏垂直分屏：command + d 水平分屏：command + shift + d 切换屏幕：command + option + 方向键command + [ 或 command + ] 查看历史命令：command + ; 查看剪贴板历史：command + shift + h 其他清除当前行：ctrl + u 到行首：ctrl + a 到行尾：ctrl + e 前进后退：ctrl + f/b (相当于左右方向键) 上一条命令：ctrl + p 搜索命令历史：ctrl + r 删除当前光标的字符：ctrl + d 删除光标之前的字符：ctrl + h 删除光标之前的单词：ctrl + w 删除到文本末尾：ctrl + k 交换光标处文本：ctrl + t 清屏1：command + r 清屏2：ctrl + l 自带有哪些很实用的功能/快捷键⌘ + 数字 在各 tab 标签直接来回切换 选择即复制 + 鼠标中键粘贴，这个很实用 ⌘ + f 所查找的内容会被自动复制 ⌘ + d 横着分屏 /⌘ + shift + d 竖着分屏 ⌘ + r = clear，而且只是换到新一屏，不会想 clear 一样创建一个空屏 ctrl + u 清空当前行，无论光标在什么位置 输入开头命令后 按 ⌘ + ; 会自动列出输入过的命令 ⌘ + shift + h 会列出剪切板历史 可以在 Preferences &gt; keys 设置全局快捷键调出 iterm，这个也可以用过 Alfred 实现 常用的一些快捷键⌘ + 1 / 2 左右 tab 之间来回切换，这个在 前面 已经介绍过了 ⌘← / ⌘→ 到一行命令最左边/最右边 ，这个功能同 C+a / C+e ⌥← / ⌥→按单词前移/后移，相当与 C+f / C+b，其实这个功能在Iterm中已经预定义好了，⌥f / ⌥b，看个人习惯了 好像就这几个 设置方法如下 当然除了这些可以自定义的也不能忘了 linux 下那些好用的组合 C+a / C+e 这个几乎在哪都可以使用 C+p / !! 上一条命令 C+k 从光标处删至命令行尾 (本来 C+u 是删至命令行首，但iterm中是删掉整行) C+w A+d 从光标处删至字首/尾 C+h C+d 删掉光标前后的字符 C+y 粘贴至光标后 C+r 搜索命令历史，这个较常用 选中即复制iterm2 有 2 种好用的选中即复制模式。 一种是用鼠标，在 iterm2 中，选中某个路径或者某个词汇，那么，iterm2 就自 动复制了。 另一种是无鼠标模式，command+f,弹出 iterm2 的查找模式，输入要查找并复制的内容的前几个字母，确认找到的是自己的内容之后，输入 tab，查找窗口将自动变化内容，并将其复制。如果输入的是 shift+tab，则自动将查找内容的左边选中并复制。 自动完成输入打头几个字母，然后输入 command+; iterm2 将自动列出之前输入过的类似命令。 剪切历史输入 command+shift+h，iterm2 将自动列出剪切板的历史记录。如果需要将剪切板的历史记录保存到磁盘，在 Preferences &gt; General &gt; Save copy/paste history to disk 中设置。 转载自https://microzz.com/2017/04/22/iterm2/","tags":[{"name":"iTerm2","slug":"iTerm2","permalink":"http://kingle.online/tags/iTerm2/"},{"name":"快捷键","slug":"快捷键","permalink":"http://kingle.online/tags/快捷键/"}]},{"title":"Numpy数据存取与函数","date":"2017-04-29T14:07:43.000Z","path":"2017/04/29/Numpy数据存取与函数/","text":"数据的CSV文件存取CSV (Comma‐Separated Value, 逗号分隔值) CSV是一种常见的文件格式，用来存储批量数据 frame : 文件、字符串或产生器，可以是.gz或.bz2的压缩文件 array : 存入文件的数组 array : 存入文件的数组 array : 存入文件的数组 frame : 文件、字符串或产生器，可以是.gz或.bz2的压缩文件 dtype : 数据类型，可选 delimiter : 分割字符串，默认是任何空格 unpack : 如果True，读入属性将分别写入不同变量 CSV只能有效存储一维和二维数组 np.savetxt() np.loadtxt()只能有效存取一维和二维数组 任意维度如何存取呢？ frame : 文件、字符串 dtype : 读取的数据类型 count : 读入元素个数，‐1表示读入整个文件 sep : 数据分割字符串，如果是空串，写入文件为二进制 该方法需要读取时知道存入文件时数组的维度和元素类型 a.tofile()和np.fromfile()需要配合使用 可以通过元数据文件来存储额外信息 Numpy的便捷文件存取 fname: 文件名，以.npy为扩展名，压缩扩展名为.npz array: 数组变量 fname: 文件名，以.npy为扩展名，压缩扩展名为.npz NumPy的随机函数子库np.random rand(do, d1, …, dn): 根据d0‐dn创建随机数数组，浮点数，[0,1)，均匀分布 randn(do, d1, .., dn): 根据d0‐dn创建随机数数组，标准正态分布 randint(low[, high, shape]): 根据shape创建随机整数或整数数组，范围是[low, high) sdde(s): 随机数种子，s是给定的种子值 shuffle(a): 根据数组a的第1轴进行随排列，改变数组x permutation(a): 根据数组a的第1轴产生一个新的乱序数组，不改变数组x choice(a[, size, replace, p]): 从一维数组a中以概率p抽取元素，形成size形状新数组 replace表示是否可以重用元素，默认为False uniform(low, high, size): 产生具有均匀分布的数组,low起始值,high结束值,size形状 normal(loc, scale, size): 产生具有正态分布的数组,loc均值,scale标准差,size形状 poisson(lam, size): 产生具有泊松分布的数组,lam随机事件发生率,size形状 NumPy的统计函数 sum(a, axis = None): 根据给定轴axis计算数组a相关元素之和， axis整数或元组 mean(a, axis = None): 根据给定轴axis计算数组a相关元素的期望， axis整数或元组 average(a, axis = None, weights=None): 根据给定轴axis计算数组a相关元素的加权平均值 std(a, axis = None): 根据给定轴axis计算数组a相关元素的标准差 var(a, axis = None): 根据给定轴axis计算数组a相关元素的方差 min(a) max(a):计算数组a中元素的最小值、最大值 argmin(a) argmax(a): 计算数组a中元素最小值、最大值的降一维后下标 unravel_index(index, shape): 根据shape将一维下标index转换成多维下标 ptp(a): 计算数组a中元素最大值与最小值的差 median(a): 计算数组a中元素的中位数（中值） np.gradient(f): 计算数组f中元素的梯度，当f为多维时，返回每个维度梯度 梯度：连续值之间的变化率，即斜率XY坐标轴连续三个X坐标对应的Y轴值：a, b, c，其中，b的梯度是： (c‐a)/2","tags":[{"name":"numpy","slug":"numpy","permalink":"http://kingle.online/tags/numpy/"},{"name":"python","slug":"python","permalink":"http://kingle.online/tags/python/"}]},{"title":"Python-numpy库","date":"2017-04-17T13:43:15.000Z","path":"2017/04/17/Python-numpy库/","text":"列表和数组区别: 列表：数据类型可以不同 数组：数据类型相同NumPy简介NumPy是一个开源的Python科学计算基础库，包含：一个强大的N维数组对象 ndarray 广播功能函数 整合C/C++/Fortran代码的工具 线性代数、傅里叶变换、随机数生成等功能 ndarray对象的属性 .ndim: 秩，即轴的数量或纬度的数量 .shape: ndarray对象的尺度，对于矩阵，n行m列 .size : ndarray对象的个数，相当于.shape中n*m的值 dtype: ndarray对象的元素类型 itemsize: ndarray对象中每个元素的大小，以字节为单位 ndarray的元素类型 bool: 布尔类型，True或False intc: 与C语言中的int类型一致，一般是int32或int64 intp:用于索引的整数，与C语言中ssize_t一致，int32或int64 int8, int16, int32, int64 uint8, uint16, uint32, uint64,无符号位 float16, float32, float64 complex64, complex128: 实部和虚部都是32 / 64位浮点数 ndarray数组可以由非同质对象构成非,同质ndarray元素为对象类型,非同质ndarray对象无法有效发挥NumPy优势，尽量避免使用 ndarray数组的创建方法(1)从Python中的列表、元组等类型创建ndarray数组: x = np.array(list/tuple) x = np.array(list/tuple, dtype=np.float32) (2)使用NumPy中函数创建ndarray数组，如:arange, ones, zeros等: np.arange(n):类似range()函数，返回ndarray类型，元素从0到n‐1 np.ones(shape): 根据shape生成一个全1数组，shape是元组类型 np.zeros(shape): 根据shape生成一个全0数组，shape是元组类型 np.full(shape, val): 根据shape生成一个数组，每个元素值都是val np.eye(n): 创建一个正方的n*n单位矩阵，对角线为1，其余为0 np.ones_like(a): 根据数组a的形状生成一个全1数组 np.zeros_like(a): 根据数组a的形状生成一个全0数组 np.full_like(a): 根据数组a的形状生成一个数组，每个元素值都是val (3)使用NumPy中其他函数创建ndarray数组 np.linspace(): 根据起止数据等间距地填充数据，形成数组,有endpoint参数，可以设置成False np.concatenate(): 将两个或多个数组合并成一个新的数组 ndarray数组的维度变换 .reshape(shape): 不改变数组元素，返回一个shape形状的数组，原数组不变 .resize(shape): 与.reshape()功能一样，但是修改原数组 .swapaxes(ax1, ax2): 将数组n个维度中两个维度进行调换 .flatten(): 对数组进行降维，返回折叠后的一维数组，原数组不变 ndarray数组的类型变换new_a = a.astype(new_type)1b = a.astype(np.float) ndarray数组向列表的转换: ls = a.tolist() 数组的索引和切片索引:获取数组中特定位置元素的过程,一般以逗号分隔切片:获取数组元素子集的过程，一般以分号分隔 数组与标量之间的运算数组与标量之间的运算作用于数组的每一个元素NumPy一元函数 np.abs(x) np.fab(x):计算数组各元素的绝对值 np.sqrt(x): 计算数组各元素的平方根 np.square(x): 计算数组各元素的平方 np.log(x) np.log10(x) np.log2(x): 计算数组各元素的自然对数、10底对数和2底对数 np.ceil(x) np.floor(x): 计算数组各元素的ceiling值 或 floor值 np.rint(x): 计算数组各元素的四舍五入值 np.modf(x): 将数组各元素的小数和整数部分以两个独立数组形式返回 np.cos(x) np.cosh(x) np.sin(x) np.sinh(x) np.tan(x) np.tanh(x): 计算数组各元素的普通型和双曲型三角函数 np.exp(x): 计算数组各元素的指数值 np.sign(x): 计算数组各元素的符号值，1(+), 0, ‐1(‐) 注意数组是否被真实改变 NumPy二元函数: np.maximum(x,y) np.fmax() np.minimum(x,y) np.fmin(): 元素级的最大值/最小值计算 np.mod(x, y): 元素级的模运算 np.copysign(x,y): 将数组y中各元素值的符号赋值给数组x对应元素","tags":[{"name":"numpy","slug":"numpy","permalink":"http://kingle.online/tags/numpy/"},{"name":"python","slug":"python","permalink":"http://kingle.online/tags/python/"}]},{"title":"算法笔记-c/c++快速入门","date":"2017-03-31T13:39:53.000Z","path":"2017/03/31/算法笔记-c-c++快速入门/","text":"c/c++快速入门 在C++标准中，stdio.h更为推荐的等价方法是：cstdio 绝对值在10^9范围内的整数都可以定义成int型，否则用long long，在初值后需要加上LL 尽量使用double来存储浮点型数据 0-9：48-57，A-Z: 65-90，a-z: 97-122 #define pi 3.14,末尾不加分号，但更推荐const double pi = 3.14， = acos(-1) 位运算符没有算术运算符高 除了%c外，scanf对其他格式符的输入是以空白符（空格，换行等）为结束标志 printf,%0md,不足位前面补充0 typedef long long LL; //给long long起一个别名LL fabs(), pow(), floor(), ceil(),sqrt(),round()四舍五入 数组的大小必须是整数常亮，不能是变量 如果数组大小较大（大概10^6），则需要将其定义在主函数外面 对于scanf，%c格式能够识别空格跟换行并将其输入，而%s通过空格或换行来识别一个字符串的结束 gets识别\\n作为结束 string.h: strlen(), strcmp(), strcpy(), strcat() sscanf(str, “%d”, &amp;n);从左读到右，sprintf(str, “%d”, n);从右读到左 数组第二维度必须定义 两个int型的指针相减，等价于在求两个指针之间相差了几个int 指针是一个unsigned的整数，引用是产生变量的别名，因此常量不可使用引用 如果自己定义了构造函数，则不能不经过初始化就定义结构体变量 123456struct studentInfo &#123; int id; char gender; //结构体的构造函数初始化 studnetInfo(int _id, char _gender): id(_id), gender(_gender) &#123;&#125;&#125;; 浮点数的比较，引入极小的数进行修正，eps取1e-8基本上可以满足要求。 一般的OJ系统，一秒钟的运算次数大概是10^7 ~ 10^8左右，因此O(n^2)的算法，n的规模为10000时是可以承受的。","tags":[{"name":"算法笔记","slug":"算法笔记","permalink":"http://kingle.online/tags/算法笔记/"},{"name":"c/c++","slug":"c-c","permalink":"http://kingle.online/tags/c-c/"}]},{"title":"vim配置","date":"2017-03-29T13:38:35.000Z","path":"2017/03/29/vim配置/","text":"所需即所获：像 IDE 一样使用 vim, 参考https://github.com/yangyangwithgnu/use_vim_as_ide#01-vimrc-文件 0 vim 必知在正式开始前先介绍几个 vim 的必知会，这不是关于如何使用而是如何配置 vim 的要点，这对理解后续相关配置非常有帮助。 0.1 .vimrc 文件.vimrc 是控制 vim 行为的配置文件，位于 ~/.vimrc，不论 vim 窗口外观、显示字体，还是操作方式、快捷键、插件属性均可通过编辑该配置文件将 vim 调教成最适合你的编辑器。很多人之所以觉得 vim 难用，是因为 vim 缺少默认设置，甚至安装完后你连配置文件自身都找不到，不进行任何配置的 vim 的确难看、难用。不论用于代码还是普通文本编辑，有必要将如下基本配置加入 .vimrc 中。前缀键。各类 vim 插件帮助文档中经常出现 ，即，前缀键。vim 自带有很多快捷键，再加上各类插件的快捷键，大量快捷键出现在单层空间中难免引起冲突，为缓解该问题，引入了前缀键 ，这样，键 r 可以配置成 r、r、r 等等多个快捷键。前缀键是 vim 使用率较高的一个键（最高的当属 Esc），选一个最方便输入的键作为前缀键，将有助于提高编辑效率。找个无须眼睛查找、无须移动手指的键 —— 分号键，挺方便的，就在你右手小指处：12\" 定义快捷键的前缀，即&lt;Leader&gt;let mapleader=\";\" 既然前缀键是为快捷键服务的，那随便说下快捷键设定原则：不同快捷键尽量不要有同序的相同字符。比如，e 执行操作 0 和 eb 执行操作 1，在你键入 e 后，vim 不会立即执行操作 0，而是继续等待用户键入 b，即便你只想键入 e，vim 也不得不花时间等待输入以确认是哪个快捷键，显然，这让 e 响应速度变慢。ea 和 eb 就没问题。文件类型侦测。允许基于不同语言加载不同插件（如，C++ 的语法高亮插件与 python 的不同）：1234\" 开启文件类型侦测filetype on\" 根据侦测到的不同类型加载对应的插件filetype plugin on 快捷键。把 vim（非插件）常用操作设定成快捷键，提升效率：123456789101112131415161718192021222324252627\" 定义快捷键到行首和行尾nmap LB 0nmap LE $\" 设置快捷键将选中文本块复制至系统剪贴板vnoremap &lt;Leader&gt;y \"+y\" 设置快捷键将系统剪贴板内容粘贴至 vimnmap &lt;Leader&gt;p \"+p\" 定义快捷键关闭当前分割窗口nmap &lt;Leader&gt;q :q&lt;CR&gt;\" 定义快捷键保存当前窗口内容nmap &lt;Leader&gt;w :w&lt;CR&gt;\" 定义快捷键保存所有窗口内容并退出 vimnmap &lt;Leader&gt;WQ :wa&lt;CR&gt;:q&lt;CR&gt;\" 不做任何保存，直接退出 vimnmap &lt;Leader&gt;Q :qa!&lt;CR&gt;\" 依次遍历子窗口nnoremap nw &lt;C-W&gt;&lt;C-W&gt;\" 跳转至右方的窗口nnoremap &lt;Leader&gt;lw &lt;C-W&gt;l\" 跳转至左方的窗口nnoremap &lt;Leader&gt;hw &lt;C-W&gt;h\" 跳转至上方的子窗口nnoremap &lt;Leader&gt;kw &lt;C-W&gt;k\" 跳转至下方的子窗口nnoremap &lt;Leader&gt;jw &lt;C-W&gt;j\" 定义快捷键在结对符之间跳转nmap &lt;Leader&gt;M % 立即生效。全文频繁变更 .vimrc，要让变更内容生效，一般的做法是先保存 .vimrc 再重启 vim，太繁琐了，增加如下设置，可以实现保存 .vimrc 时自动重启加载它：12\" 让配置变更立即生效autocmd BufWritePost $MYVIMRC source $MYVIMRC 其他。搜索、vim 命令补全等设置：12345678\" 开启实时搜索功能set incsearch\" 搜索时大小写不敏感set ignorecase\" 关闭兼容模式set nocompatible\" vim 自身命令行模式智能补全set wildmenu 快捷键还是得注意一些，快捷键的前缀的使用还需要多试几次，需要比较快的手速，多试几次就可以适应了。 以上的四类配置不仅影响 vim，而且影响插件是否能正常运行。很多插件不仅要在 .vimrc 中添加各自特有的配置信息，还要增加 vim 自身的配置信息，在后文的各类插件介绍中，我只介绍对应插件特有配置信息，当你发现按文中介绍操作后插件未生效，很可能是 vim 自身配置信息未添加，所以一定要把上述配置拷贝至到你的 .vimrc 中，再对照本文介绍一步步操作。.vimrc 完整配置信息参见附录，每个配置项都有对应注释。另外，由于有些插件还未来得及安装，在你实验前面的插件是否生效时，vim 可能有报错信息提示，先别理会，安装完所有插件后自然对了。 1 源码安装编辑器 vim 对于MAC，一般自带的vim是7.4版本，这个和源码安装并不会冲突，会自动替换到8.0.之后的版本，可以用vim –version查看。 发行套件的软件源中预编译的 vim 要么不是最新版本，要么功能有阉割，有必要升级成全功能的最新版，当然，源码安装必须滴：12345git clone git@github.com:vim/vim.gitcd vim/./configure --with-features=huge --enable-pythoninterp --enable-rubyinterp --enable-luainterp --enable-perlinterp --with-python-config-dir=/usr/lib/python2.7/config/ --enable-gui=gtk2 --enable-cscope --enable-multibyte --enable-python3interp --with-python-config-dir=/Library/Frameworks/Python.framework/Versions/3.6/lib/python3.6/config-3.6m-darwin --prefix=/usrmakemake install 其中，已经打开了Python3的使用，但是config的路径还是得根据自己的需求进行配置。而 –enable-pythoninterp、–enable-rubyinterp、–enable-perlinterp、–enable-luainterp 等分别表示支持 ruby、python、perl、lua 编写的插件，–enable-gui=gtk2 表示生成采用 GNOME2 风格的 gvim，–enable-cscope 支持 cscope，–with-python-config-dir=/usr/lib/python2.7/config/ 指定 python 路径（先自行安装 python 的头文件 python-devel），这几个特性非常重要，影响后面各类插件的使用。注意，你得预先安装相关依赖库的头文件，python-devel、python3-devel、ruby-devel、lua-devel、libX11-devel、gtk-devel、gtk2-devel、gtk3-devel、ncurses-devel，如果缺失，源码构建过程虽不会报错，但最终生成的 vim 很可能缺失某些功能。构建完成后在 vim 中执行：1:echo has('python') 若输出 1 则表示构建出的 vim 已支持 python，反之，0 则不支持。 2 插件管理vim 自身希望通过在 .vim/ 目录中预定义子目录管理所有插件（比如，子目录 doc/ 存放插件帮助文档、plugin/ 存放通用插件脚本），vim 的各插件打包文档中通常也包含上述两个（甚至更多）子目录，用户将插件打包文档中的对应子目录拷贝至 .vim/ 目录即可完成插件的安装。一般情况下这种方式没问题，但我等重度插件用户，.vim/ 将变得混乱不堪，至少存在如下几个问题：插件名字冲突。所有插件的帮助文档都在 doc/ 子目录、插件脚本都在 plugin/ 子目录，同个名字空间下必然引发名字冲突；插件卸载易误。你需要先知道 doc/ 和 plugin/ 子目录下哪些文件是属于该插件的，再逐一删除，容易多删/漏删。我希望每个插件在 .vim/ 下都有各自独立子目录，这样需要升级、卸载插件时，直接找到对应插件目录变更即可；另外，我希望所有插件清单能在某个配置文件中集中罗列，通过某种机制实现批量自动安装/更新/升级所有插件。vundle（https://github.com/VundleVim/Vundle.vim ）为此而生，它让管理插件变得更清晰、智能。vundle 会接管 .vim/ 下的所有原生目录，所以先清空该目录，再通过如下命令安装 vundle：1git clone https://github.com/VundleVim/Vundle.vim.git ~/.vim/bundle/Vundle.vim 接下来在 .vimrc 增加相关配置信息(具体可以去看GitHub https://github.com/yangyangwithgnu/use_vim_as_ide#01-vimrc-文件)：123456789101112131415161718192021222324252627282930313233343536\" vundle 环境设置filetype offset rtp+=~/.vim/bundle/Vundle.vim\" vundle 管理的插件列表必须位于 vundle#begin() 和 vundle#end() 之间call vundle#begin()Plugin 'VundleVim/Vundle.vim'Plugin 'altercation/vim-colors-solarized'Plugin 'tomasr/molokai'Plugin 'vim-scripts/phd'Plugin 'Lokaltog/vim-powerline'Plugin 'octol/vim-cpp-enhanced-highlight'Plugin 'nathanaelkane/vim-indent-guides'Plugin 'derekwyatt/vim-fswitch'Plugin 'kshenoy/vim-signature'Plugin 'vim-scripts/BOOKMARKS--Mark-and-Highlight-Full-Lines'Plugin 'majutsushi/tagbar'Plugin 'vim-scripts/indexer.tar.gz'Plugin 'vim-scripts/DfrankUtil'Plugin 'vim-scripts/vimprj'Plugin 'dyng/ctrlsf.vim'Plugin 'terryma/vim-multiple-cursors'Plugin 'scrooloose/nerdcommenter'Plugin 'vim-scripts/DrawIt'Plugin 'SirVer/ultisnips'Plugin 'Valloric/YouCompleteMe'Plugin 'derekwyatt/vim-protodef'Plugin 'scrooloose/nerdtree'Plugin 'fholgado/minibufexpl.vim'Plugin 'gcmt/wildfire.vim'Plugin 'sjl/gundo.vim'Plugin 'Lokaltog/vim-easymotion'Plugin 'suan/vim-instant-markdown'Plugin 'lilydjwg/fcitx.vim'\" 插件列表结束call vundle#end()filetype plugin indent on 其中，每项1Plugin 'dyng/ctrlsf.vim' 对应一个插件（这与 go 语言管理不同代码库的机制类似），后续若有新增插件，只需追加至该列表中即可。vundle 支持源码托管在 https://github.com/ 的插件，同时 vim 官网 http://www.vim.org/ 上的所有插件均在 https://github.com/vim-scripts/ 有镜像，所以，基本上主流插件都可以纳入 vundle 管理。具体而言，仍以 ctrlsf.vim 为例，它在 .vimrc 中配置信息为 dyng/ctrlsf.vim，vundle 很容易构造出其真实下载地址 https://github.com/dyng/ctrlsf.vim.git ，然后借助 git 工具进行下载及安装。此后，需要安装插件，先找到其在 github.com 的地址，再将配置信息其加入 .vimrc 中的call vundle#begin() 和 call vundle#end() 之间，最后进入 vim 执行:1:PluginInstall 要卸载插件，先在 .vimrc 中注释或者删除对应插件配置信息，然后在 vim 中执行:1:PluginClean 即可删除对应插件。插件更新频率较高，差不多每隔一个月你应该看看哪些插件有推出新版本，批量更新，只需执行1:PluginUpdate 即可。你得注意插件的下载源。同名插件在 github.com 上可能有多个，比如，indexer 插件，至少就有 https://github.com/vim-scripts/indexer.tar.gz 、https://github.com/everzet/vim-indexer 、https://github.com/shemerey/vim-indexer 等三个，到底应该选哪个呢？以我的经验来看，对于钟意的插件，我会先找其作者的个人网站，上面通常会罗列出托管在 github.com 的具体地址；若没有，我会找该插件在 vim.org 的页面，上面也会有 github.com 托管地址；若还是没有，再以 github 和插件名作为关键字搜索，点赞数多的，通常是你想找的。为节约你找插件地址的时间，本文中出现的每个插件我都会附上其地址。非特殊情况，后文介绍到的插件不再累述如何安装。通过 vundle 管理插件后，切勿通过发行套件自带的软件管理工具安装任何插件，不然 .vim/ 又要混乱了。 3 界面美化玉不琢不成器，vim 不配不算美。刚安装好的 vim 朴素得吓人，这是与我同时代的软件么？ 3.1 主题风格一套好的配色方案绝对会影响你的编码效率，vim 内置了 10 多种配色方案供你选择，GUI 下，可以通过菜单（Edit -&gt; Color Scheme）试用不同方案，字符模式下，需要你手工调整配置信息，再重启 vim 查看效果（csExplorer 插件，可在字符模式下不用重启即可查看效果）。不满意，可以去 http://vimcolorschemetest.googlecode.com/svn/html/index-c.html 慢慢选。我自认为“阅美无数”，目前最夯三甲： 素雅 solarized（https://github.com/altercation/vim-colors-solarized ） 多彩 molokai（https://github.com/tomasr/molokai ） 复古 phd（http://www.vim.org/scripts/script.php?script_id=3139 ）但是我自己还是比较喜欢： lucius https://github.com/jonathanfilip/vim-lucius“ 配色方案set background=darkcolorscheme solarized“colorscheme molokai“colorscheme phd“colorscheme lucius 3.2 营造专注氛围如今的 UX 设计讲究的是内容至上，从 GNOME3 的变化就能看出。编辑器界面展示的应全是代码，不应该有工具条、菜单、滚动条浪费空间的元素，另外，编程是种精神高度集中的脑力劳动，不应出现闪烁光标、花哨鼠标这些分散注意力的东东。配置如下：12345678910\" 禁止光标闪烁set gcr=a:block-blinkon0\" 禁止显示滚动条set guioptions-=lset guioptions-=Lset guioptions-=rset guioptions-=R\" 禁止显示菜单和工具条set guioptions-=mset guioptions-=T 我们把 vim 弄成全屏模式。vim 自身无法实现全屏，必须借助第三方工具 wmctrl，一个控制窗口 XYZ 坐标、窗口尺寸的命令行工具。先自行安装 wmctrl，再在 .vimrc 中增加如下信息：12345678\" 将外部命令 wmctrl 控制窗口最大化的命令行参数封装成一个 vim 的函数fun! ToggleFullscreen() call system(\"wmctrl -ir \" . v:windowid . \" -b toggle,fullscreen\")endf\" 全屏开/关快捷键map &lt;silent&gt; &lt;F11&gt; :call ToggleFullscreen()&lt;CR&gt;\" 启动 vim 时自动全屏autocmd VimEnter * call ToggleFullscreen() 3.3 添加辅助信息去除了冗余元素让 vim 界面清爽多了，为那些实用辅助信息腾出了空间。光标当前位置、显示行号、高亮当前行/列等等都很有用：1234567891011\" 总是显示状态栏set laststatus=2\" 显示光标当前位置set ruler\" 开启行号显示set number\" 高亮显示当前行/列set cursorlineset cursorcolumn\" 高亮显示搜索结果set hlsearch 3.4 其他美化默认字体不好看，挑个自己喜欢的，前提是你得先安装好该字体。中文字体，我喜欢饱满方正的（微软雅黑），英文字体喜欢圆润的（Consolas），vim 无法同时使用两种字体，怎么办？有人制作发布了一款中文字体用微软雅黑、英文字体用 Consolas 的混合字体 —— yahei consolas hybrid 字体，号称最适合中国程序员使用的字体，效果非常不错（本文全文采用该字体）。在 .vimrc 中设置下：12\" 设置 gvim 显示字体set guifont=YaHei\\ Consolas\\ Hybrid\\ 11.5 其中，由于字体名存在空格，需要用转义符“\\”进行转义；最后的 11.5 用于指定字体大小。代码折行也不太美观，禁止掉：12\" 禁止折行set nowrap 前面介绍的主题风格对状态栏不起作用，需要借助插件 Powerline（https://github.com/Lokaltog/vim-powerline ）美化状态栏，在 .vimrc 中设定状态栏主题风格：12\" 设置状态栏主题风格let g:Powerline_colorscheme='solarized256' 效果见上图。 4 代码分析阅读优秀开源项目源码是提高能力的重要手段，营造舒适、便利的阅读环境至关重要。 4.1 语法高亮代码只有一种颜色的编辑器，就好像红绿灯只有一种颜色的路口，全然无指引。现在已是千禧年后的十年了，早已告别上世纪六、七十年代黑底白字的时代，即使在字符模式下编程（感谢伟大的 fbterm），我也需要语法高亮。所幸 vim 自身支持语法高亮，只需显式打开即可：1234\" 开启语法高亮功能syntax enable\" 允许用指定语法高亮配色方案替换默认方案syntax on vim 对 C++ 语法高亮支持不够好（特别是 C++11/14 新增元素），必须借由插件 vim-cpp-enhanced-highlight（https://github.com/octol/vim-cpp-enhanced-highlight ）进行增强。 vim-cpp-enhanced-highlight 主要通过 .vim/bundle/vim-cpp-enhanced-highlight/after/syntax/cpp.vim 控制高亮关键字及规则，所以，当你发现某个 STL 容器类型未高亮，那么将该类型追加进 cpp.vim 即可。如，initializer_list 默认并不会高亮，需要添加:1syntax keyword cppSTLtype initializer_list 4.2 代码缩进C/C++ 中的代码执行流由复合语句控制，如 if(){} 判断复合语句、for(){} 循环符号语句等等，这势必出现大量缩进。缩进虽然不影响语法正确性，但对提升代码清晰度有不可替代的功效。在 vim 中有两类缩进表示法，一类是用 1 个制表符（’\\t’），一类是用多个空格（’ ‘）。两者并无本质区别，只是源码文件存储的字符不同而已，但，缩进可视化插件对两类缩进显示方式不同，前者只能显示为粗块，后者可显示为细条，就我的审美观而言，选后者。增加如下配置信息：12345678910\" 自适应不同语言的智能缩进filetype indent on\" 将制表符扩展为空格set expandtab\" 设置编辑时制表符占用空格数set tabstop=4\" 设置格式化时制表符占用空格数set shiftwidth=4\" 让 vim 把连续数量的空格视为一个制表符set softtabstop=4 其中，注意下 expandtab、tabstop 与 shiftwidth、softtabstop、retab： expandtab，把制表符转换为多个空格，具体空格数量参考 tabstop 和 shiftwidth 变量； tabstop 与 shiftwidth 是有区别的。tabstop 指定我们在插入模式下输入一个制表符占据的空格数量，linux 内核编码规范建议是 8，看个人需要；shiftwidth 指定在进行缩进格式化源码时制表符占据的空格数。所谓缩进格式化，指的是通过 vim 命令由 vim 自动对源码进行缩进处理，比如其他人的代码不满足你的缩进要求，你就可以对其进行缩进格式化。缩进格式化，需要先选中指定行，要么键入 = 让 vim 对该行进行智能缩进格式化，要么按需键入多次 &lt; 或 &gt; 手工缩进格式化； softtabstop，如何处理连续多个空格。因为 expandtab 已经把制表符转换为空格，当你要删除制表符时你得连续删除多个空格，该设置就是告诉 vim 把连续数量的空格视为一个制表符，即，只删一个字符即可。通常应将这tabstop、shiftwidth、softtabstop 三个变量设置为相同值；另外，你总会阅读其他人的代码吧，他们对制表符定义规则与你不同，这时你可以手工执行 vim 的 retab 命令，让 vim 按上述规则重新处理制表符与空格关系。很多编码规范建议缩进（代码嵌套类似）最多不能超过 4 层，但难免有更多层的情况，缩进一多，我那个晕啊：我希望有种可视化的方式能将相同缩进的代码关联起来，Indent Guides（https://github.com/nathanaelkane/vim-indent-guides ）来了。安装好该插件后，增加如下配置信息：12345678\" 随 vim 自启动let g:indent_guides_enable_on_vim_startup=1\" 从第二层开始可视化显示缩进let g:indent_guides_start_level=2\" 色块宽度let g:indent_guides_guide_size=1\" 快捷键 i 开/关缩进可视化:nmap &lt;silent&gt; &lt;Leader&gt;i &lt;Plug&gt;IndentGuidesToggle 断节？Indent Guides 通过识别制表符来绘制缩进连接线，断节处是空行，没有制表符，自然绘制不出来，算是个小 bug，但瑕不掩瑜，有个小技巧可以解决，换行-空格-退格： 4.3 代码折叠有时为了去除干扰，集中精力在某部分代码片段上，我会把不关注部分代码折叠起来。vim 自身支持多种折叠：手动建立折叠（manual）、基于缩进进行折叠（indent）、基于语法进行折叠（syntax）、未更改文本构成折叠（diff）等等，其中，indent、syntax 比较适合编程，按需选用。增加如下配置信息：12345\" 基于缩进或语法进行代码折叠\"set foldmethod=indentset foldmethod=syntax\" 启动 vim 时关闭折叠代码set nofoldenable 操作：za，打开或关闭当前折叠；zM，关闭所有折叠；zR，打开所有折叠。 4.4 接口与实现快速切换我习惯把类的接口和实现分在不同文件中，常有在接口文件（MyClass.h）和实现文件（MyClass.cpp）中来回切换的操作。你当然可以先分别打开接口文件和实现文件，再手动切换，但效率不高。我希望，假如在接口文件中，vim 自动帮我找到对应的实现文件，当键入快捷键，在新 buffer 中打开对应实现文件。vim-fswitch（https://github.com/derekwyatt/vim-fswitch ）来了。安装后增加配置信息：12\" *.cpp 和 *.h 间切换nmap &lt;silent&gt; &lt;Leader&gt;sw :FSHere&lt;cr&gt; 这样，键入 ;sw 就能在实现文件和接口文件间切换。 上图中，初始状态先打开了接口文件 MyClass.h，键入 ;sw 后，vim 在新 buffer 中打开实现文件 MyClass.cpp，并在当前窗口中显示；再次键入 ;sw 后，当前窗口切回接口文件。 4.5 代码收藏源码分析过程中，常常需要在不同代码间来回跳转，我需要“收藏”分散在不同处的代码行，以便需要查看时能快速跳转过去，这时，vim 的书签（mark）功能派上大用途了。vim 书签的使用很简单，在你需要收藏的代码行键入 mm，这样就收藏好了，你试试，没反应？不会吧，难道你 linux 内核编译参数有问题，或者，vim 的编译参数没给全，让我想想，别急，喔，对了，你是指看不到书签？好吧，我承认这是 vim 最大的坑，书签所在行与普通行外观上没任何差别，肉眼，你是找不到他滴。这可不行，得来个让书签可视化的插件，vim-signature（https://github.com/kshenoy/vim-signature ）。vim-signature 通过在书签所在行的前面添加字符的形式，以此可视化书签，这就要求你源码安装的 vim 具备 signs 特性，具体可在 vim 命令模式下键入:1:echo has('signs') 若显示 1 则具备该特性，反之 0 则不具备该特性，需参考“1 源码安装编辑器 vim ”重新编译 vim。vim 的书签分为两类，独立书签和分类书签。独立书签，书签名只能由字母（a-zA-Z）组成，长度最多不超过 2 个字母，并且，同个文件中，不同独立书签名中不能含有相同字母，比如，a 和 bD 可以同时出现在同个文件在，而 Fc 和 c 则不行。分类书签，书签名只能由可打印特殊字符（!@#$%^&amp;*()）组成，长度只能有 1 个字符，同个文件中，你可以把不同行设置成同名书签，这样，这些行在逻辑上就归类成相同类型的书签了。下图定义了名为 a 和 dF 两个独立书签（分别 259 行和 261 行）、名为 # 的一类分类书签（含 256 行和 264 行）、名为 @ 的一类分类书签（257 行）.两种形式的书签完全分布在各自不同的空间中，所以，它俩的任何操作都是互不相同的，比如，你无法遍历所有书签，要么只能在各个独立书签间遍历，要么只能在分类书签间遍历。显然，两种形式的书签都有各自的使用场景，就我而言，只使用独立书签，原因有二：一是独立书签可保存，当我设置好独立书签后关闭文档，下次重新打开该文档时，先前的独立书签仍然有效，而分类书签没有该特性（其他文档环境恢复参见“6.3 环境恢复”）；一是减少记忆快捷键，光是独立书签就有 8 种遍历方式，每种遍历对应一种快捷键，太难记了。vim-signature 快捷键如下：1234567891011121314151617181920212223let g:SignatureMap = &#123; \\ 'Leader' : \"m\", \\ 'PlaceNextMark' : \"m,\", \\ 'ToggleMarkAtLine' : \"m.\", \\ 'PurgeMarksAtLine' : \"m-\", \\ 'DeleteMark' : \"dm\", \\ 'PurgeMarks' : \"mda\", \\ 'PurgeMarkers' : \"m&lt;BS&gt;\", \\ 'GotoNextLineAlpha' : \"']\", \\ 'GotoPrevLineAlpha' : \"'[\", \\ 'GotoNextSpotAlpha' : \"`]\", \\ 'GotoPrevSpotAlpha' : \"`[\", \\ 'GotoNextLineByPos' : \"]'\", \\ 'GotoPrevLineByPos' : \"['\", \\ 'GotoNextSpotByPos' : \"mn\", \\ 'GotoPrevSpotByPos' : \"mp\", \\ 'GotoNextMarker' : \"[+\", \\ 'GotoPrevMarker' : \"[-\", \\ 'GotoNextMarkerAny' : \"]=\", \\ 'GotoPrevMarkerAny' : \"[=\", \\ 'ListLocalMarks' : \"ms\", \\ 'ListLocalMarkers' : \"m?\" \\ &#125; 够多了吧，粗体部分是按个人习惯重新定义的快捷键，请添加进 .vimrc 中。常用的操作也就如下几类：书签设定。mx，设定/取消当前行名为 x 的标签；m,，自动设定下一个可用书签名，前面提说，独立书签名是不能重复的，在你已经有了多个独立书签，当想再设置书签时，需要记住已经设定的所有书签名，否则很可能会将已有的书签冲掉，这可不好，所以，vim-signature 为你提供了 m, 快捷键，自动帮你选定下一个可用独立书签名；mda，删除当前文件中所有独立书签。书签罗列。m?，罗列出当前文件中所有书签，选中后回车可直接跳转；书签跳转。mn，按行号前后顺序，跳转至下个独立书签；mp，按行号前后顺序，跳转至前个独立书签。书签跳转方式很多，除了这里说的行号前后顺序，还可以基于书签名字母顺序跳转、分类书签同类跳转、分类书签不同类间跳转等等。我虽然选用了 vim-signature，但不代表它完美了，对我而言，无法在不同文件的书签间跳转绝对算是硬伤。另外，如果觉得收藏的代码行只有行首符号来表示不够醒目，你可以考虑 BOOKMARKS–Mark-and-Highlight-Full-Lines 这个插件（https://github.com/vim-scripts/BOOKMARKS--Mark-and-Highlight-Full-Lines ），它可以让书签行高亮，如下是它的快捷键：，高亮所有书签行；，关闭所有书签行高亮；，清除 [a-z] 的所有书签；，收藏当前行；，取消收藏当前行。 4.6 标识符列表本节之前的内容，虽说与代码开发有些关系，但最多也只能算作用户体验层面的，真正提升生产效率的内容将从此开始。本文主题是探讨如何将 vim 打造成高效的 C/C++ 开发环境，希望实现标识符列表、定义跳转、声明提示、实时诊断、代码补全等等系列功能，这些都需要 vim 能够很好地理解我们的代码（不论是 vim 自身还是借助插件甚至第三方工具），如何帮助 vim 理解代码？基本上，有两种主流方式：标签系统和语义系统。至于优劣，简单来说，标签系统配置简单，而语义系统效果精准，后者是趋势。目前对于高阶 IDE 功能，部分已经有对应基于语义的插件支撑，而部分仍只能通过基于标签的方式实现，若同个功能既有语义插件又有标签插件，优选语义。标签系统代码中的类、结构、类成员、函数、对象、宏等等这些统称为标识符，每个标识符的定义、所在文件中的行位置、所在文件的路径等等信息就是标签（tag）。Exuberant Ctags（http://ctags.sourceforge.net/ ，后简称 ctags）就是一款经典的用于生成代码标签信息的工具 。ctags 最初只支持生成 C/C++ 语言，目前已支持 41 种语言，具体列表运行如下命令获取：1ctags --list-languages 学习知识最好方式就是动手实践。我们以 main.cpp、my_class.h、my_class.cpp 三个文件为例：第一步，准备代码文件。创建演示目录 /data/workplace/example/、库子目录 /data/workplace/example/lib/，创建如下内容的 main.cpp：123456789101112131415161718192021222324#include &lt;iostring&gt;#include &lt;string&gt;#include \"lib/my_class.h\"using namespace std;int g_num = 128;// 重载函数static voidprintMsg (char ch)&#123; std::cout &lt;&lt; ch &lt;&lt; std::endl;&#125;intmain (void)&#123; // 局部对象 const string name = \"yangyang.gnu\"; // 类 MyClass one; // 成员函数 one.printMsg(); // 使用局部对象 cout &lt;&lt; g_num &lt;&lt; name &lt;&lt; endl; return (EXIT_SUCCESS);&#125; 创建如下内容的 my_class.h：12345678#pragma onceclass MyClass&#123; public: void printMsg(void); private: ;&#125;; 创建如下内容的 my_class.cpp：123456789101112#include \"my_class.h\"// 重载函数static voidprintMsg (int i)&#123; std::cout &lt;&lt; i &lt;&lt; std::endl;&#125;voidMyClass::printMsg (void)&#123; std::cout &lt;&lt; \"I'M MyClass!\" &lt;&lt; std::endl;&#125; 第二步，生成标签文件。现在运行 ctags 生成标签文件：12cd /data/workplace/example/ctags -R --c++-kinds=+p+l+x+c+d+e+f+g+m+n+s+t+u+v --fields=+liaS --extra=+q --language-force=c++ 注意：如果在mac上不能运行上述代码可以参考https://gist.github.com/nazgob/1570678 命令行参数较多，主要关注 –c++-kinds，ctags 默认并不会提取所有标签，运行：1ctags --list-kinds=c++ 可看到 ctags 支持生成标签类型的全量列表：1234567891011121314c classesd macro definitionse enumerators (values inside an enumeration)f function definitionsg enumeration namesl local variables [off]m class, struct, and union membersn namespacesp function prototypes [off]s structure namest typedefsu union namesv variable definitionsx external and forward variable declarations [off] 其中，标为 off 的局部对象、函数声明、外部对象等类型默认不会生成标签，所以我显式加上所有类型。运行完后，example/ 下多了个文件 tags.里面的内容，! 开头的几行是 ctags 生成的软件信息忽略之，下面的就是我们需要的标签，每个标签项至少有如下字段（命令行参数不同标签项的字段数不同）：标识符名、标识符所在的文件名（也是该文件的相对路径）、标识符所在行的内容、标识符类型（如，l 表示局部对象），另外，若是函数，则有函数签名字段，若是成员函数，则有访问属型字段等等。语义系统通过 ctags 这类标签系统在一定程度上助力 vim 理解我们的代码，对于 C 语言这类简单语言来说，差不多也够了。近几年，随着 C++11/14 的推出，诸如类型推导、lamda 表达式、模版等等新特性，标签系统显得有心无力，这个星球最了解代码的工具非编译器莫属，如果编译器能在语义这个高度帮助 vim 理解代码，那么我们需要的各项 IDE 功能肯定能达到另一个高度。语义系统，编译器必不可少。GCC 和 clang 两大主流 C/C++ 编译器，作为语义系统的支撑工具，我选择后者，除了 clang 对新标准支持及时、错误诊断信息清晰这些优点之外，更重要的是，它在高内聚、低耦合方面做得非常好，各类插件可以调用 libclang 获取非常完整的代码分析结果，从而轻松且优雅地实现高阶 IDE 功能。你对语义系统肯定还是比较懵懂，紧接着的“基于语义的声明/定义跳转”会让你有更为直观的了解，现在，请跳转至“7.1 编译器/构建工具集成”，一是了解 clang 相较 GCC 的优势，二是安装好最新版 clang 及其标准库，之后再回来。 基于标签的标识符列表在阅读代码时，经常分析指定函数实现细节，我希望有个插件能把从当前代码文件中提取出的所有标识符放在一个侧边子窗口中，并且能能按语法规则将标识符进行归类，tagbar （https://github.com/majutsushi/tagbar ）是一款基于标签的标识符列表插件，它自动周期性调用 ctags 获取标签信息（仅保留在内存，不落地成文件）。安装完 tagbar 后，在 .vimrc 中增加如下信息：123456789101112131415161718192021222324252627282930313233343536373839404142\" 设置 tagbar 子窗口的位置出现在主编辑区的左边let tagbar_left=1\" 设置显示／隐藏标签列表子窗口的快捷键。速记：identifier list by tagnnoremap &lt;Leader&gt;ilt :TagbarToggle&lt;CR&gt;\" 设置标签子窗口的宽度let tagbar_width=32\" tagbar 子窗口中不显示冗余帮助信息let g:tagbar_compact=1\" 设置 ctags 对哪些代码标识符生成标签let g:tagbar_type_cpp = &#123; \\ 'kinds' : [ \\ 'c:classes:0:1', \\ 'd:macros:0:1', \\ 'e:enumerators:0:0', \\ 'f:functions:0:1', \\ 'g:enumeration:0:1', \\ 'l:local:0:1', \\ 'm:members:0:1', \\ 'n:namespaces:0:1', \\ 'p:functions_prototypes:0:1', \\ 's:structs:0:1', \\ 't:typedefs:0:1', \\ 'u:unions:0:1', \\ 'v:global:0:1', \\ 'x:external:0:1' \\ ], \\ 'sro' : '::', \\ 'kind2scope' : &#123; \\ 'g' : 'enum', \\ 'n' : 'namespace', \\ 'c' : 'class', \\ 's' : 'struct', \\ 'u' : 'union' \\ &#125;, \\ 'scope2kind' : &#123; \\ 'enum' : 'g', \\ 'namespace' : 'n', \\ 'class' : 'c', \\ 'struct' : 's', \\ 'union' : 'u' \\ &#125;\\ &#125; 前面提过，ctags 默认并不会提取局部对象、函数声明、外部对象等类型的标签，我必须让 tagbar 告诉 ctags 改变默认参数，这是 tagbar_type_cpp 变量存在的主要目的，所以前面的配置信息中将局部对象、函数声明、外部对象等显式将其加进该变量的 kinds 域中。具体格式为:1&#123;short&#125;:&#123;long&#125;[:&#123;fold&#125;[:&#123;stl&#125;]] 用于描述函数、变量、结构体等等不同类型的标识符，每种类型对应一行。其中，short 将作为 ctags 的 –c++-kinds 命令行选项的参数，类似：1--c++-kinds=+p+l+x+c+d+e+f+g+m+n+s+t+u+v long 将作为 short 的简要描述展示在 vim 的 tagbar 子窗口中；fold 表示这种类型的标识符是否折叠显示；stl 指定是否在 vim 状态栏中显示附加信息。重启 vim 后，打开一个 C/C++ 源码文件，键入 ilt，将在左侧的 tagbar 窗口中将可看到标签列表： tagbar 的几个特点： 按作用域归类不同标签。按名字空间 n_foo、类 Foo 进行归类，在内部有声明、有定义； 显示标签类型。名字空间、类、函数等等； 显示完整函数原型； 图形化显示共有成员（+）、私有成员（-）、保护成员（#）；在标识符列表中选中对应标识符后回车即可跳至源码中对应位置；在源码中停顿几秒，tagbar 将高亮对应标识符；每次保存文件时或者切换到不同代码文件时 tagbar 自动调用 ctags 更是标签数据库；tagbar 有两种排序方式，一是按标签名字母先后顺序、一是按标签在源码中出现的先后顺序，在 .vimrc 中我配置选用后者，键入 s 切换不同不同排序方式。 4.7 声明/定义跳转假设你正在分析某个开源项目源码，在 main.cpp 中遇到调用函数 func()，想要查看它如何实现，一种方式：在 main.cpp 中查找 -&gt; 若没有在工程内查找 -&gt; 找到后打开对应文件 -&gt; 文件内查找其所在行 -&gt; 移动光标到该行 -&gt; 分析完后切换会先前文件，不仅效率太低更要命的是影响我的思维连续性。我需要另外高效的方式，就像真正函数调用一样：光标选中调用处的 func() -&gt; 键入某个快捷键自动转换到 func() 实现处 -&gt; 键入某个键又回到 func() 调用处，这就是所谓的定义跳转。基本上，vim 世界存在两类导航：基于标签的跳转和基于语义的跳转。基于标签的声明/定义跳转继续延用前面接收标签系统的例子文件 main.cpp、my_class.h、my_class.cpp，第二步已经生成好了标签文件，那么要实现声明/定义跳转，需要第三步，引入标签文件。这让 vim 知晓标签文件的路径。在 /data/workplace/example/ 目录下用 vim 打开 main.cpp，在 vim 中执行如下目录引入标签文件 tags：1:set tags+=/data/workplace/example/tags 既然 vim 有个专门的命令来引入标签，说明 vim 能识别标签。虽然标签文件中并无行号，但已经有标签所在文件，以及标签所在行的完整内容，vim 只需切换至对应文件，再在文件内作内容查找即可找到对应行。换言之，只要有对应的标签文件，vim 就能根据标签跳转至标签定义处。这时，你可以体验下初级的声明/定义跳转功能。把光标移到 main.cpp 的 one.printMsg() 那行的 printMsg 上，键入快捷键 g]，vim 将罗列出名为 printMsg 的所有标签候选列表，按需选择键入编号即可跳转进入。 目前为止，离我预期还有差距。第一，选择候选列表影响思维连续性。首先得明白为何会出现待选列表。前面说过，vim 做的事情很简单，就是把光标所在单词放到标签文件中查找，如果只有一个，当然你可以直接跳转过去，大部分时候会找到多项匹配标签，比如，函数声明、函数定义、函数调用、函数重载等等都会导致同个函数名出现在多个标签中，vim 无法知道你要查看哪项，只能让你自己选择。其实，因为标签文件中已经包含了函数签名属性，vim 的查找机制如果不是基于关键字，而是基于语义的话，那也可以直接命中，期待后续 vim 有此功能吧。既然无法直接解决，换个思路，我不想选择列表，但可以接受遍历匹配标签。就是说，我不想输入数字选择第几项，但可以接受键入正向快捷键后遍历第一个匹配标签，再次键入快捷键遍历第二个，直到最后一个，键入反向快捷键逆序遍历。这下事情简单了，命令 :tnext 和 :tprevious 分别先后和向前遍历匹配标签，定义两个快捷键搞定：1234\" 正向遍历同名标签nmap &lt;Leader&gt;tn :tnext&lt;CR&gt;\" 反向遍历同名标签nmap &lt;Leader&gt;tp :tprevious&lt;CR&gt; 等等，这还不行，vim 中有个叫标签栈（tags stack）的机制，:tnext、:tprevious 只能遍历已经压入标签栈内的标签，所以，你在遍历前需要通过快捷键 ctrl-] 将光标所在单词匹配的所有标签压入标签栈中，然后才能遍历。不说复杂了，以后你只需先键入 ctrl-]，若没跳转至需要的标签，再键入 tn 往后或者 tp 往前遍历即可。第二，如何返回先前位置。当分析完函数实现后，我需要返回先前调用处，可以键入 vim 快捷键 ctrl-t 返回，如果想再次进入，可以用前面介绍的方式，或者键入 ctrl-i。另外，注意，ctrl-o 以是一种返回快捷键，但与 ctrl-t 的返回不同，前者是返回上次光标停留行、后者返回上个标签。第三，如何自动生成标签并引入。开发时代码不停在变更，每次还要手动执行 ctags 命令生成新的标签文件，太麻烦了，得想个法周期性针对这个工程自动生成标签文件，并通知 vim 引人该标签文件，嘿，还真有这样的插件 —— indexer（https://github.com/vim-scripts/indexer.tar.gz ）。indexer 依赖 DfrankUtil（https://github.com/vim-scripts/DfrankUtil ）、vimprj（https://github.com/vim-scripts/vimprj ）两个插件，请一并安装。请在 .vimrc 中增加：1234\" 设置插件 indexer 调用 ctags 的参数\" 默认 --c++-kinds=+p+l，重新设置为 --c++-kinds=+p+l+x+c+d+e+f+g+m+n+s+t+u+v\" 默认 --fields=+iaS 不满足 YCM 要求，需改为 --fields=+iaSllet g:indexer_ctagsCommandLineOptions=\"--c++-kinds=+p+l+x+c+d+e+f+g+m+n+s+t+u+v --fields=+iaSl --extra=+q\" 另外，indexer 还有个自己的配置文件，用于设定各个工程的根目录路径，配置文件位于 ~/.indexer_files，内容可以设定为：12345--------------- ~/.indexer_files --------------- [foo]/data/workplace/foo/src/[bar]/data/workplace/bar/src/ 上例设定了两个工程的根目录，方括号内是对应工程名，路径为工程的代码目录，不要包含构建目录、文档目录，以避免将产生非代码文件的标签信息。这样，从以上目录打开任何代码文件时，indexer 便对整个目录创建标签文件，若代码文件有更新，那么在文件保存时，indexer 将自动调用 ctags 更新标签文件，indexer 生成的标签文件以工程名命名，位于 ~/.indexer_files_tags/，并自动引入进 vim 中，那么1:set tags+=/data/workplace/example/tags 一步也省了。好了，解决了这三个问题后，vim 的代码导航基本已经达到我的预期。 下面依旧有很多内容，但比较深，不太适合初学者，所以不再继续写了，有兴趣可参考前面的GitHub链接，最后推荐一本vim相关的书籍，《vim实用技巧》","tags":[{"name":"vim","slug":"vim","permalink":"http://kingle.online/tags/vim/"}]},{"title":"python进阶与强化note2","date":"2017-03-22T15:19:37.000Z","path":"2017/03/22/python进阶与强化note2/","text":"note2如何实现可迭代对象和迭代器对象应用场景: 延时访问(用时访问) 封装成一个对象 for 循环逐条显示123456789101112131415161718192021222324252627282930import requestsfrom collections import Iterable, Iterator# 继承迭代器对象，并重写__next__方法(next，对于pyton2) class WeatherIterator(Iterator): def __init__(self, cities): self.cities = cities self.index = 0 def getWeather(self, city): r = requests.get(u'http://wthrcdn.etouch.cn/weather_mini?city=' + city) data = r.json()['data']['forecast'][0] return '%s: %s, %s' % (city, data['low'], data['high']) def __next__(self): if self.index == len(self.cities): raise StopIteration city = self.cities[self.index] self.index += 1 return self.getWeather(city)# 继承可迭代对象, 并重写__iter__class WeatherIterable(Iterable): def __init__(self, cities): self.cities = cities def __iter__(self): return WeatherIterator(self.cities)for x in WeatherIterable([u'北京', u'上海', u'广州', u'长春']): print(x) 使用生成器函数实现可迭代对象 应用场景:实现一个可迭代对象的类，它能迭代出给定范围内所有素数： 代码：1234567891011121314151617181920class PrimeNumbers: def __init__(self, start, end): self.start = start self.end = end def isPrimeNum(self, k): if k &lt; 2: return False for i in range(2, k): if k % i == 0: return False return True def __iter__(self) : for k in range(self.start, self.end + 1): if self.isPrimeNum(k): yield kfor x in PrimeNumbers(1, 100): print(x) 反向迭代可以使用：123456l = [1, 2, 3, 4, 5]l.reverse() # 缺点，改变了原来的值l[::-1] # 浪费了空间reversed(l) # 得到一个可迭代的对象 实例123456789101112131415161718192021222324class FloatRange: def __init__(self, start, end, step = 0.1): self.start = start self.end = end self.step = step def __iter__(self): t = self.start while t &lt;= self.end: yield t t += self.step def __reversed__(self): t = self.end while t &gt;= self.start: yield t t -= self.step# 正向迭代for x in FloatRange(1.0, 4.0, 0.5): print(x)# 反向迭代 for x in reversed(FloatRange(1.0, 4.0, 0.5)): print(x) 如何对迭代器做切片操作针对日志文件，可以使用1234567# 缺点，如果文件过大，容易导致内存不足f = open('/var/log/system.log')l = l.readlines()l[100:300]for line in f: print(line) 可迭代对象islice会消耗之前申请的迭代器对象123456from itertools import islice## 初始到500 for x in islice(f, 500)## 100到末尾 for x in islice(f, 100, None) for x in islice(f, 100, 300): print(x) 如何在一个for语句中迭代迭代多个可迭代对象123456789101112131415161718# 并行from random import randintchinese = [randint(60, 100) for _ in range(40)]english = [randint(60, 100) for _ in range(40)]math = [randint(60, 100) for _ in range(40)]for i in range(len(math)): print(chinese[i] + math[i] + english[i])# 使用内置函数zipfor c, m, e in zip(chinese, math, english): print(c + m + e)# 串行# 使用chain函数from itertools import chainfor s in chain(chinese, english, math): if s &gt; 90: count += 1","tags":[]},{"title":"python进阶与强化note1","date":"2017-03-18T15:19:30.000Z","path":"2017/03/18/python进阶与强化note1/","text":"note1过滤list过滤12345678#生成-10到10范围内的十个数data = [randint(-10, 10) for _ in range(10)]#过滤filter(lambda x: x &gt;= 0, data)# 列表解析过滤 更快[x for x in data if x &gt;= 0] dict过滤12345# 生成一个1-20号，分数为60-100的成绩student = &#123;x: randint(60, 100) for x in range(1, 21)&#125;#迭代键和值并过滤&#123;k:v for k, v in d.items() if v &gt; 90&#125; 命名tuple增加可读性1234567891011NAME, AGE, SEX, EMAIL = range(4)student = ('Jim', 16, 'male', 'jim@qq.com')#nameprint(student[NAME])#ageif student[AGE] &gt;= 18: pass#sexif student[SEX] == 'male': pass 使用namedtuple1234from collections import namedtupleStudent = namedtuple('Student', ['name', 'age', 'sex', 'email'])s = Student(name='Jim', age=16, sex='male', email='jim@qq.com')s.age 统计统计数字出现的次数123456from random import randintdata = [randint(0, 20) for _ in range(30)]# 生成起始值为0的字典c = dict.fromkeys(data, 0)for x in data: c[x] += 1 使用内置函数12345from collections import Counter# 统计数组出现次数，并生产字典c2c2 = Counter(data)#选出出现频率最高的三个元组c2.most_common(3) 统计单词出现频率12345678import refrom collections import Countertxt = open('CodingStyle').read()# 按照非字母进行分割data = re.split('\\W+', txt)# 统计单词出现频次c3 = Counter(data)c3.most_common(3) 字典按值排序1234567from random import randint# 字典解析生成data = &#123;x: randint(60, 100) for x in 'xyzabc'&#125;# 通过zip函数连接生成一个列表，列表由一系列的元组构成data2 = zip(data.values(), data.keys())# 排序sort = sorted(data2) 或者1sorted(d.items(), key = lambda x: x[1]) 公共键123456789from random import randint, sample# 先取样，后生成字典s1 = &#123;x: randint(1, 4) for x in sample('abcefg', randint(3, 6))&#125;s2 = &#123;x: randint(1, 4) for x in sample('abcefg', randint(3, 6))&#125;s3 = &#123;x: randint(1, 4) for x in sample('abcefg', randint(3, 6))&#125;res = []for k in s1: if k in s2 and k in s3: res.append(k) 或者12# 通过集合的方式(交集)res = s1.keys() &amp; s2.keys() &amp; s3.keys() 使用map, reduce进行N轮操作1reduce(lambda a, b: a &amp; b, map(dict.keys, [s1, s2, s3])) 让字典保持有序默认的字典是没有顺序的,但可以使用OrderedDict12345from collections import OrderedDictd = OrderedDict()d['jim'] = (1, 35)d['leo'] = (2, 36)d['bob'] = (3, 39) 实例1234567891011121314151617from time import timefrom random import randintfrom collections import OrderedDictd = OrderedDict()players = list(\"ABCDEFGH\")start = time()for i in range(8): input() p = players.pop(randint(0, 7 - i)) end = time() print(i+1, p, end - start) d[p] = (i + 1, end - start)print('*' * 20)for i in d: print(i, d[i]) 历史记录12345678910111213141516171819202122232425262728293031import osfrom collections import dequefrom random import randintimport pickleN = randint(0, 100)# 构造一个队列history = deque([], 5)# 判断当前路径中是否有history文件if os.path.isfile('history'): history = pickle.load(open('history', 'rb'))def guess(k): if k == N: print('right') return True if k &lt; N: print('%s is less than N' % k) else: print('%s is greater than N' % k) return Falsewhile True: line = input('please input a number: ') if line.isdigit(): k = int(line) history.append(k) if guess(k): break elif line == 'history' or line == 'h?': print(list(history))# 将history存储到本地文件中，方便下次打开历史记录仍然存在pickle.dump(history, open('history', 'wb'))","tags":[{"name":"python","slug":"python","permalink":"http://kingle.online/tags/python/"}]},{"title":"Python笔记-BeautifulSoup库入门","date":"2017-03-14T13:36:40.000Z","path":"2017/03/14/Python笔记-BeautifulSoup库入门/","text":"Beautiful Soup库的安装Win平台: “以管理员身份运行”cmd 执行1pip install beautifulsoup4 最简单的测试：123456import requestsfrom bs4 import BeautifulSoupr = requests.get(\"http://www.baidu.com\")demo = r.textsoup = BeautifulSoup(demo, 'html.parser')print(soup.prettify()) Beautiful Soup库解析器：BeautifulSoup类的基本元素 Tag标签：任何存在于HTML语法中的标签都可以用soup.访问获得 当HTML文档中存在多个相同对应内容时，soup.返回第一个 Tag的name(名字)：每个都有自己的名字，通过.name获取，字符串类型 Tag的attrs(属性)：一个可以有0或多个属性，字典类型 Tag的NavigableString：NavigableString可以跨越多个层次 Tag的Comment：Comment是一种特殊类型，可以读取代码中的注释 标签树的下行遍历1234567#遍历儿子节点for child in soup.body.children: print(child)## 遍历子孙节点for child in soup.body.descendants: print(child) 标签树的上行遍历 .parent:节点的父亲标签 .parents:节点先辈标签的迭代类型，用于循环遍历先辈节点 标签树的平行遍历bs4库的prettify()方法prettify()为HTML文本&lt;&gt;及其内容增加更加&apos;\\n&apos; .prettify()可用于标签，方法:&lt;tag&gt;.prettify()","tags":[{"name":"python","slug":"python","permalink":"http://kingle.online/tags/python/"},{"name":"BeautifulSoup","slug":"BeautifulSoup","permalink":"http://kingle.online/tags/BeautifulSoup/"}]},{"title":"Python笔记-Requests库网络爬取实战","date":"2017-03-07T13:34:48.000Z","path":"2017/03/07/Python笔记-Requests库网络爬取实战/","text":"实例1:京东商品页面的爬取代码：123456789import requestsurl = \"https://item.jd.com/2967929.html\"try: r = requests.get(url) r.raise_for_status() r.encoding = r.apparent_encoding print(r.text[:1000]except:print(\"爬取失败\") 实例2:亚马逊商品页面的爬取因为亚马逊自带防爬虫技术，故而我们可以将爬虫假装成一个浏览器去访问，代码如下：12345678910import requestsurl = \"https://www.amazon.cn/gp/product/B01M8L5Z3Y\"try: kv = &#123;\"user-agent\":\"Mozilla/5.0\"&#125; r = requests.get(url, headers=kv) r.raise_for_status() r.encoding = r.apparent_encoding print(r.text[1000:2000])except: print(\"爬取失败\") 实例3:百度/360搜索关键字提交百度的关键词接口: http://www.baidu.com/s?wd=keyword360的关键词接口: http://www.so.com/s?q=keyword代码如下：12345678910import requestskeyword = \"Python\"try: kv = &#123;'wd': keyword&#125; r = requests.get(\"http://www.baidu.com/s\", params = kv) print(r.requests.url) r.raise_for_status() print(len(r.text))except: print(\"爬取失败\") 实例4:网络图片的爬取和存储网络图片链接的格式: http://www.example.com/picture.jpg国家地理:http://www.nationalgeographic.com.cn/选择一个图片Web页面: http://www.nationalgeographic.com.cn/photography/photo_of_the_ day/3921.html图片地址:http://image.nationalgeographic.com.cn/2017/ 0211/20170211061910157.jpg123456789101112131415161718import requestsimport osurl = \"http://image.nationalgeographic.com.cn/2017/ 0211/20170211061910157.jpg\"root = \"D://pics//\"path = root + url.split('/')[-1]try: if not os.path.exists(root): os.mkdir(root) if not os.path.exists(path): r = requests.get(url) with open(path, 'wb') as f: f.write(r.content) f.close() print(\"文件保存成功\") else: print(\"文件已经存在\")except: print(\"爬取失败\")","tags":[{"name":"python","slug":"python","permalink":"http://kingle.online/tags/python/"},{"name":"Requests","slug":"Requests","permalink":"http://kingle.online/tags/Requests/"}]},{"title":"Emacs配置","date":"2017-02-23T13:31:20.000Z","path":"2017/02/23/Emacs配置/","text":"Contents Overview Emacs Installation Emacs Basics SML/NJ Installation SML Mode for Emacs Installation Manual SML Mode Installation for Older Emacs Versions – Probably Skip This! Using the SML/NJ REPL (Read-Eval-Print Loop) in Emacs 1. OverviewFor Programming Languages, Part A, we will work with the Standard ML programming language (ML), using the Standard ML of New Jersey compiler (SML/NJ). You will need SML/NJ and a text editor on your computer to do the programming assignments. Any editor that can handle plain text will work, but you will want an editor that specifically supports ML with features like automatic indentation, syntax highlighting, etc. For such an editor, we recommend Emacs because we know it works and we have detailed installation instructions in this document. You are welcome to use an editor other than Emacs. If you do, the course staff is unlikely to be able to help with any issues that arise, but you may find help on the discussion forums. While Emacs does not have the look-and-feel or tool-integration of many modern integrated development environments (IDEs), it is a versatile tool well-known by many computer scientists and software developers. If you have not used it before, you will find the menus and key bindings unusual, but learning unusual tools is commonplace in computing. Many students have used Emacs for the first time when completing this course without it being a hindrance – we do not need any complicated features and we are writing small enough programs that you do not need to be a “power-user” with any of the tools we are using. All that said, there are plenty of people who despise Emacs for various reasons unrelated to the material in this class, so use whatever you like. This document describes how to install, configure, and use Emacs, SML/NJ, and SML-Mode-for-emacs (henceforth SML Mode) on your computer. These instructions should work for recent versions of Windows, Mac OS X, and Linux. These instructions were last updated in June 2016. Details and version numbers may change in the future. Programming Languages Part B will use Racket and Programming Languages Part C will use Ruby. So there will be more software-installation in your future with instructions provided when we get there, but the instructions in this document are everything you need for Part A. 2. Emacs InstallationWe strongly recommend Emacs version 24.X (for any X) so that you can use the most recent version of SML Mode. Earlier versions of SML Mode are fine, but they are more difficult to install. You can check the version of an Emacs installation in several ways, including the About Emacs option under the Help menu. Installing version 24 is easy, so we recommend doing so even if you already have an older version. Directions depend on your operating system: Windows: Download a zip archive of the most recent full version, currently Version 24.5, available at http://ftp.gnu.org/gnu/emacs/windows/emacs-24.5-bin-i686-mingw32.zip. (More information and other versions of Emacs are available at the GNU Emacs website, http://www.gnu.org/software/emacs/.) Unpack the downloaded zip archive file 𝚎𝚖𝚊𝚌𝚜-𝟸𝟺.𝟻-𝚋𝚒𝚗-𝚒𝟼𝟾𝟼-𝚖𝚒𝚗𝚐𝚠𝟹𝟸.𝚣𝚒𝚙 by right-clicking it and choosing Extract All. This should produce a folder called 𝚎𝚖𝚊𝚌𝚜-𝟸𝟺.𝟻-𝚋𝚒𝚗-𝚒𝟼𝟾𝟼-𝚖𝚒𝚗𝚐𝚠𝟹𝟸. Move this folder wherever you want, but pick a permanent place (i.e., do not move it again after the next step). Once you have moved the folder to where you want, look inside to find 𝚋𝚒𝚗\\𝚊𝚍𝚍𝚙𝚖.𝚎𝚡𝚎 (the .𝚎𝚡𝚎 extension might not be visible in the folder window depending on how you have Windows configured). Double click on this file to run it one time and it should add a Gnu Emacs folder to your Start menu and do some other setup operations. Open the Start menu and select Gnu Emacs then Emacs (or just type emacs in the search box) to launch Emacs. Mac OS: Download Emacs as a Mac OS X application from http://emacsformacosx.com/. Open the disk image file (.dmg) and drag the Emacs application to your Applications folder. If you prefer another version of Emacs, such as the more primitive one on the command line or Aquamacs (http://aquamacs.org/), you can use it, but make sure it is based on a version of Emacs 24.X or higher. Linux: A suitable version of Emacs is probably already installed. If not, use your package manager to install it. On Ubuntu and other Debian derivatives, try 𝚜𝚞𝚍𝚘 𝚊𝚙𝚝-𝚐𝚎𝚝 𝚒𝚗𝚜𝚝𝚊𝚕𝚕 𝚎𝚖𝚊𝚌𝚜. On Fedora, try 𝚜𝚞𝚍𝚘 𝚢𝚞𝚖 𝚒𝚗𝚜𝚝𝚊𝚕𝚕 𝚎𝚖𝚊𝚌𝚜. 3. Emacs BasicsUsing Emacs feels a little different than using other editors; it can take some getting used to, especially the keyboard shortcuts. Fortunately, Emacs has buttons and menus to help you adjust if that is your style. The following is a short primer on Emacs terminology and keyboard commands. Beyond the basics described here, which should be all you need, there are countless free resources available. An introductory “tour” is at http://www.gnu.org/software/emacs/tour/. For more information, see the Emacs Reference Manual at \\http://www.gnu.org/software/emacs/manual/html_node/emacs/index.html (also available within Emacs from the Help Menu), the Emacs Wiki at http://www.emacswiki.org/, or the Emacs Tutorial (within Emacs from the Help Menu). The cursor is a rectangular block and is referred to as the point. The mode line displays information about the buffer displayed in the current window. A buffer is a logical “thing” that you are working on. When you open a file, it will be loaded into a buffer, typically with the same name as the file. Every buffer is edited in a mode. The most basic mode is Fundamental, which provides only the most basic Emacs editing features. There are modes for many different programming languages.There are many “special” buffers that do not correspond to loaded files. The one above is called scratch. This buffer runs in Lisp Interaction mode, which means that you can interactively type and evaluate expressions in the Lisp programming language. But we won’t do that. Emacs uses many key combinations involving the Control and Meta keys. Such key combinations are denoted C-x (Control-x (lowercase)) or M-x (Meta-x). On keyboards that don’t have Meta (just about all keyboards today), Alt should work on all systems, but on some Mac systems you might use the funny-symbol-with-four-circles or Option keys instead. (Emacs might complain about “Super” if you get the wrong one. If you or Emacs gets confused about what you are trying to type, use C-g to cancel your current command and start fresh.) If none of these work, use Esc, but when trying to type M-x, for example, you might need to type Esc then type x. (This is only if using Esc as Meta. The other Meta “substitutes” work as usual: hold while pressing the second key.) The most important commands in Emacs: C-x C-c: Quit Emacs C-g: Cancel the current action C-x C-f: Open a file (whether or not it already exists) C-x C-s: Save a file C-x C-w: Write a file (probably more familiar to you as Save as…) Cut, copy, paste: Highlight text with the mouse or by hitting C-Space to set a mark and then moving the cursor to highlight a region. C-w: Cut a highlighted region M-w: Copy a highlighted region C-k: Cut (kill) from the cursor to the end of the line C-y: Paste (yank) Some other useful commands: C-x 2: Split the window into 2 buffers, one above the other (Use the mouse or C-x o to switch between them) C-x 0: Undo window-splitting so there is only 1 buffer C-x b: Switch to another buffer by entering its name C-x C-b: See a list of all current buffers Getting help within Emacs: In addition to the help button/menu on the right… C-h: Hitting this will display a short message in the minibuffer: 𝙲-𝚑 (𝚃𝚢𝚙𝚎 ? 𝚏𝚘𝚛 𝚏𝚞𝚛𝚝𝚑𝚎𝚛 𝚘𝚙𝚝𝚒𝚘𝚗𝚜). C-h b: Key bindings. This lists all key bindings that are valid for the current mode. Note that key bindings change from mode to mode. C-h a: Command apropos. After typing 𝙲-𝚑 a you can type a symbol and a buffer will appear that lists all symbols and functions that match that phrase. More advanced Emacs hacks (optional): If you are curious, try some of these once you have finished the rest of the setup instructions. They are unnecessary for any of the work we will do, but may be convenient. Change the colors of your syntax highlighting. In version 24 of Emacs, 𝙼-𝚡 𝚌𝚞𝚜𝚝𝚘𝚖𝚒𝚣𝚎-𝚝𝚑𝚎𝚖𝚎𝚜 is a good place to start. General customization interface: Open the Options menu and choose the first item under Customize Emacs. This will let you customize Emacs through a sort-of-graphical interface. It saves all your settings in a file in your “home” directory, ~/.𝚎𝚖𝚊𝚌𝚜. Much, much, much more: Emacs calls itself an extensible editor for a reason. 4. SML/NJ InstallationDirections first vary by operating system, but then see “All Systems: Check your SML Installation” below. Note: The latest version of SML/NJ is 110.80 and that is the version used in these installation instructions. The course videos use SML/NJ 110.75. There are no language differences between the two versions (and 110.74 and earlier are fine too), so if you already have SML/NJ 110.75 or earlier installed, that is fine. The installation instructions for Mac OS X 10.6 or later changed slightly between versions, affecting the directories where files are installed. Windows: Download and run the 𝚜𝚖𝚕𝚗𝚓.𝚖𝚜𝚒 installer available at http://www.smlnj.org/dist/working/110.80/. This will add an item for SML of New Jersey to your Start menu and add a command 𝚜𝚖𝚕 that you can use at the command line. Mac OS: The instructions here assume your operating system is Mac OS X 10.6 (which released in August 2009) or higher. See below if you have an older operating system. Download and run the 𝚜𝚖𝚕𝚗𝚓-𝚡𝟾𝟼-𝟷𝟷𝟶.𝟾𝟶.𝚙𝚔𝚐 installer available at http://www.smlnj.org/dist/working/110.80/. Do not use the .𝚍𝚖𝚐 file available; that is for older computers. We recommend you not choose a “custom install location” though you can if you adjust the instructions that follow appropriately. If you have Mac OS Sierra, you likely need 110.80 and not an older version. Once the installation is complete, use Emacs or another text editor to edit the file .𝚋𝚊𝚜𝚑𝚙𝚛𝚘𝚏𝚒𝚕𝚎 in your home folder. (In Emacs you can do this via: 𝙲-𝚡 𝙲-𝚏 ~/.𝚋𝚊𝚜𝚑𝚙𝚛𝚘𝚏𝚒𝚕𝚎, notice the three characters “tilde, slash, dot.”) If the file does not already exist, create it. Add this line to the file: [Math Processing Error]export PATH=&quot;$PATH:/usr/local/smlnj/bin&quot; [Math Processing Error] This tells your shell (the program that you interact with in the terminal) to add the SML/NJ directory to the paths it searches to find programs. (If you are not using the bash shell, which Mac OS X has used by default since 10.3, the syntax will be different.) Finally, you will need to run your .𝚋𝚊𝚜𝚑_𝚙𝚛𝚘𝚏𝚒𝚕𝚎 to deploy the changes you have made into your environment for the present session. To do this, run: [Math Processing Error]source.bashprofi≤ You need to do this only once. Afterwards, each new terminal that you open will automatically run .𝚋𝚊𝚜𝚑_𝚙𝚛𝚘𝚏𝚒𝚕𝚎 for you. Now skip to “All Systems: Check your SML Installation” – the rest of this section is for Mac users with an operating system older than OS X 10.6. If your operating system is Mac OS X 10.5: If you have an Intel chip (which is the case if your computer was new in 2007 or later, or possibly in 2006), then you will need to follow the Unix instructions at http://www.smlnj.org/dist/working/110.80/. If you have a PowerPC chip (which is the case if your computer was new in 2005 or earlier, or possibly in 2006), then you can use the 𝚜𝚖𝚕𝚗𝚓-𝚙𝚙𝚌-𝟷𝟷𝟶.𝟾𝟶.𝚍𝚖𝚐 installer at http://www.smlnj.org/dist/working/110.80/. Follow the instructions above for Mac OS 10.6 or higher except (a) using the different installer and (b) making the contents of your .𝚋𝚊𝚜𝚑_𝚙𝚛𝚘𝚏𝚒𝚕𝚎 file include the line: [Math Processing Error]export PATH=&quot;$PATH:/usr/local/smlnj-110.80/bin&quot; [Math Processing Error] If your operating system is Mac OS X 10.4 or earlier: You will need to follow the Unix instructions at http://www.smlnj.org/dist/working/110.80/. Linux: If your package manager has a package for SML/NJ, install it. If it installs an older version such as SML/NJ 110.72, that should be fine. Otherwise, follow the Unix instructions at http://www.smlnj.org/dist/working/110.80/. All Systems: Check your SML Installation Open a terminal window and type 𝚜𝚖𝚕 followed by Enter/Return. To open a terminal window: Windows: Start then All Programs then Accessories then Command Prompt, or Windows 7/8/10 just use the Start Menu to search for the 𝚌𝚖𝚍.𝚎𝚡𝚎 program and run it. Mac OS: Open Applications/Utilities/Terminal.app. Linux: Various ways: any shell should be fine. You should see a prompt that looks like this: [Math Processing Error]Standard ML of New Jersey v110.80 [built: ...] [Math Processing Error] If you do not, then see below. Make sure everything is working by typing a very simple SML program at the prompt (notice the semicolon): [Math Processing Error]1 + 1; [Math Processing Error] Hit Enter/Return. In response, the SML interpreter should print: [Math Processing Error]val it = 2 : int [Math Processing Error] To exit the interpreter, type Control-Z and then Return on Windows and Control-D on Mac or Linux. If everything worked, skip to the next section. Else if the 𝚜𝚖𝚕 command caused an error, then most likely SML/NJ is installed but is not being found in your “PATH”. For Windows, the PATH should have been set by the installer, but if it was not for some reason, you can set it manually as follows: Go to Start Menu, then Control Panel, then System, then Advanced System Settings, then Advanced (the tab that should be selected by default), then Environment Variables. Now change the user variable 𝚙𝚊𝚝𝚑 to be everything already there followed by: [Math Processing Error]C:\\Program Files (x86)\\SMLNJ\\bin [Math Processing Error] For Mac OS X (or Linux), double-check that you edited your .𝚋𝚊𝚜𝚑𝚙𝚛𝚘𝚏𝚒𝚕𝚎 file correctly. Depending on your user settings, you may need to make the same additions to a file that is in the same directory as .𝚋𝚊𝚜𝚑𝚙𝚛𝚘𝚏𝚒𝚕𝚎 but is called .𝚋𝚊𝚜𝚑𝚛𝚌 or .𝚙𝚛𝚘𝚏𝚒𝚕𝚎 instead. (This is particularly likely if you have MacPorts installed.) 5. SML Mode for Emacs InstallationSML Mode is an extension to Emacs that is not Emacs itself or SML/NJ itself. It displays SML code nicely with syntax coloring and clean indentation, and provides a way to run SML from within Emacs. (Thanks to Stefan Monnier for maintaining SML Mode. The website is \\http://www.iro.umontreal.ca/~monnier/elisp/, but you do not need to go there to install SML Mode.) To install the current version of SML Mode (currently 6.7), follow these instructions from within Emacs: Run the command 𝙼-𝚡 𝚕𝚒𝚜𝚝-𝚙𝚊𝚌𝚔𝚊𝚐𝚎𝚜 (and then Return/Enter). If the 𝚕𝚒𝚜𝚝-𝚙𝚊𝚌𝚔𝚊𝚐𝚎𝚜 command does not exist, your Emacs version is too old. You can upgrade Emacs or follow more difficult SML Mode installation instructions below. Find 𝚜𝚖𝚕-𝚖𝚘𝚍𝚎 and click on it with your mouse. If that worked, then click on 𝚒𝚗𝚜𝚝𝚊𝚕𝚕 with your mouse then move to the next step. If you could not find 𝚜𝚖𝚕-𝚖𝚘𝚍𝚎, first note that while package names are mostly alphabetized, they may be in more than one group, making it seem like 𝚜𝚖𝚕-𝚖𝚘𝚍𝚎 is not present. Check the entire buffer. You can most easily search using 𝙲-𝚜 in Emacs. If you still do not see 𝚜𝚖𝚕-𝚖𝚘𝚍𝚎, try killing the buffer (𝙲-𝚡 𝚔) and trying the previous step again (some users have reported having to try several times, frustratingly). If you still do not see SML Mode, then you can follow these more manual steps instead: Visit http://elpa.gnu.org/packages/sml-mode.html . Locate, and download the latest version (currently sml-mode-6.7.el) from that page. In Emacs type 𝙼-𝚡 𝚙𝚊𝚌𝚔𝚊𝚐𝚎-𝚒𝚗𝚜𝚝𝚊𝚕𝚕-𝚏𝚒𝚕𝚎 𝙴𝙽𝚃𝙴𝚁. At the prompt 𝙿𝚊𝚌𝚔𝚊𝚐𝚎 𝚏𝚒𝚕𝚎 𝚗𝚊𝚖𝚎: give the path to the just downloaded 𝚜𝚖𝚕-𝚖𝚘𝚍𝚎-𝟼.𝟽.𝚎𝚕, and type 𝙴𝙽𝚃𝙴𝚁. This will split the window, and show the 𝙲𝚘𝚖𝚙𝚒𝚕𝚎-𝚕𝚘𝚐 with some lines about 𝙲𝚘𝚖𝚙𝚒𝚕𝚒𝚗𝚐 𝚏𝚒𝚕𝚎, and perhaps a warning. If there are no errors, 𝚜𝚖𝚕-𝚖𝚘𝚍𝚎 should now be installed. Exit and restart Emacs. Read below to see if you need to follow a couple more steps (more likely under Mac and Linux). To verify that SML Mode is properly installed, let us check that it does indentation/coloring for SML files and that you can create the SML read-eval-print-loop (REPL) from within Emacs. First, edit an existing or new SML file (try 𝙲-𝚡 𝙲-𝚏 𝚝𝚎𝚜𝚝.𝚜𝚖𝚕 to create a new file if nothing else is handy). You should see the mode display at the bottom of the Emacs window change from Fundamental (or whatever it was) to SML. If you enter a line of code like 𝚟𝚊𝚕 𝚗 = 𝟷; you should see colors highlighting the keywords and variable names. When you are editing code, whenever you hit the Tab key, Emacs will try to reindent the current line appropriately. Second, while the cursor is in an SML buffer (i.e., you are editing an SML file), run 𝙲-𝚌 𝙲-𝚜 and press Enter/Return. This should split the window and create an SML prompt in a new buffer. In that buffer, you should be able to type 𝟷+𝟷; and then Enter/Return at the prompt and see 2 as the result. If you are seeing syntax highlighting, but the 𝙲-𝚌 𝙲-𝚜 command fails with an error message, Emacs is probably having trouble finding the SML program. You can hopefully fix this as follows: Mac OS: In Emacs, edit your .𝚎𝚖𝚊𝚌𝚜 file by 𝙲-𝚡 𝙲-𝚏 ~/.𝚎𝚖𝚊𝚌𝚜 (that is tilde, slash, dot, emacs) to open the file. Paste in these lines if you have Mac OS X 10.6 or later: [Math Processing Error](setenv &quot;PATH&quot; (concat &quot;/usr/local/smlnj/bin:&quot; (getenv &quot;PATH&quot;))) (setq exec-path (cons &quot;/usr/local/smlnj/bin&quot; exec-path)) [Math Processing Error] and these lines if you have Mac OS X 10.5: [Math Processing Error](setenv &quot;PATH&quot; (concat &quot;/usr/local/smlnj-110.80/bin:&quot; (getenv &quot;PATH&quot;))) (setq exec-path (cons &quot;/usr/local/smlnj-110.80/bin&quot; exec-path)) [Math Processing Error] (Adjust the lines above accordingly if you installed SML/NJ in a different directory.) Save the file (𝙲-𝚡 𝙲-𝚜). Exit and restart Emacs. Linux: Find where 𝚜𝚖𝚕𝚗𝚓-𝟷𝟷𝟶.𝟾𝟶 was installed. Then follow the Mac OS instructions above, but replacing /𝚞𝚜𝚛/𝚕𝚘𝚌𝚊𝚕 with the appropriate path. 6. Manual SML Mode Installation for Older Emacs Versions – Probably Skip This!If you are using Emacs 24.X, you should be able to skip this section. These instructions are only for people who want to use an older version of Emacs, which requires using an older version of SML Mode and following different installation instructions. If you are on Linux, your package manager may include an 𝚜𝚖𝚕-𝚖𝚘𝚍𝚎 package. For example, on Ubuntu, the command 𝚜𝚞𝚍𝚘 𝚊𝚙𝚝-𝚐𝚎𝚝 𝚒𝚗𝚜𝚝𝚊𝚕𝚕 𝚜𝚖𝚕-𝚖𝚘𝚍𝚎 may be all you need and you might be able to skip the rest of this section. Otherwise… Go to http://www.iro.umontreal.ca/~monnier/elisp/ and download version 5.0 (see link “Download 5.0” or just download directly (http://www.iro.umontreal.ca/~monnier/elisp/sml-mode-5.0.tar.gz). Unpack it: Windows: You need some program that can handle a .𝚝𝚊𝚛.𝚐𝚣 file. The Cygwin tools (http://www.cygwin.com) suffice, or an easier-to-use program is 7-Zip (http://www.7-zip.org/). For 7-zip, install it. Then right-click the .𝚝𝚊𝚛.𝚐𝚣 file and choose 7-Zip then Extract Here. If this creates a .𝚝𝚊𝚛 file instead of a folder, do 7-Zip then Extract Here on that file as well. Mac OS: double-click the .𝚝𝚊𝚛.𝚐𝚣 file. Linux: Either: When downloading, choose Open with [Archive Manager] if given the option. Otherwise, save the file and double-click it, which should open it in Archive Manager. Drag the 𝚜𝚖𝚕-𝚖𝚘𝚍𝚎-𝟻.𝟶 folder to the Desktop or wherever you want to store it.Save the file. In a terminal, 𝚌𝚍 into the directory where you saved it and run 𝚝𝚊𝚛 -𝚡𝚏𝚣 𝚜𝚖𝚕-𝚖𝚘𝚍𝚎.𝚝𝚊𝚛.𝚐𝚣.You should get a folder named 𝚜𝚖𝚕-𝚖𝚘𝚍𝚎-𝟻.𝟶. You can place this folder anywhere you like. To get SML Mode to work with Emacs, you need to create/edit a .𝚎𝚖𝚊𝚌𝚜 file in your “home” directory/folder that Emacs searches when it starts up. Open this file in Emacs via the command 𝙲-𝚡 𝙲-𝚏 ~/.𝚎𝚖𝚊𝚌𝚜. Add the following line to the .𝚎𝚖𝚊𝚌𝚜 file: [Math Processing Error](load &quot;/path/to/where/you/stored/sml-mode-5.0/sml-mode-startup&quot;) [Math Processing Error] but replacing path/to/where/you/stored with the appropriate path: Windows: Hold down the Shift key as you right-click the sml-mode-5.0 folder and choose Copy As Path. Paste this into Emacs. Then replace each \\ with / because \\ is a special character in Emacs settings files. And add /sml-mode-startup at the end. So you might end up with something like Z:/look/here/sml-mode-startup. Mac OS: Select the folder in the Finder and choose File then Get Info. Copy the Where: field and add /sml-mode-startup. Now also add the following to your .emacs file in addition to the line above: [Math Processing Error]`(setenv “PATH” (concat “/usr/local/smlnj/bin:” (getenv “PATH”))) (setq exec-path (cons “/usr/local/smlnj/bin” exec-path))[Math Processing Error]` (But if you have Mac OS X 10.5, use smlnj-110.77 in place of smlnj in the two lines above. Or, more generally, adjust the lines above appropriately if you installed SML/NJ in a different directory.) Linux: If SML Mode seems to work, but you cannot get the SML REPL to run in Emacs, then find where smlnj-110.77 was installed and add the two lines under the Mac OS instructions above, but replacing /usr/local with the appropriate path. (There are much more elaborate installation instructions in the documentation included in the sml-mode-5.0 folder, but these are aimed at system administrators who might want to install SML Mode for an entire site instead of a single user. You do not need these.) Now verify that SML Mode is properly installed, following the instructions in the previous section. Finally, if you are in SML Mode but your SML code does not have syntax coloring, add this line to your ~/.emacs file and then restart Emacs: [Math Processing Error](global-font-lock-mode t) [Math Processing Error] This should be necessary only if your Emacs version is older than 23.X. 7. Using the SML/NJ REPL (Read-Eval-Print Loop) in EmacsAt this point, we are done installing! This section shows you how to run SML programs from within Emacs. It assumes you already have an SML file or can write your own SML program in a new one. Edit a file with extension .𝚜𝚖𝚕. You should be in SML-mode, using Tab to indent your code well. To create the 𝚜𝚖𝚕 buffer (which holds the REPL), type 𝙲-𝚌 𝙲-𝚜 (and then Return/Enter) in the buffer with the .sml file. (Note: This will not work in the 𝚜𝚌𝚛𝚊𝚝𝚌𝚑 buffer that Emacs starts in because this buffer is not in SML Mode.) Keep the .sml file(s) you are working with for a particular assignment in the same folder. When you type 𝙲-𝚌 𝙲-𝚜 to start the REPL from a buffer for foo.sml, the REPL will look in the right folder for 𝚏𝚘𝚘.𝚜𝚖𝚕 when you type 𝚞𝚜𝚎 “𝚏𝚘𝚘.𝚜𝚖𝚕”; and will look in the same folder for any other file you use such as 𝚏𝚘𝚘_𝚝𝚎𝚜𝚝𝚜.𝚜𝚖𝚕. This is less confusing than trying to keep track of different folders and paths while using the REPL although that is possible. To end and restart a REPL session, type 𝙲-𝚍 (to end it) and 𝙲-𝚌 𝙲-𝚜 (and then Return/Enter) (to restart it). You must type 𝙲-𝚍 while in the 𝚜𝚖𝚕 buffer; you can type 𝙲-𝚌 𝙲-𝚜 from the 𝚜𝚖𝚕 buffer or a buffer with a .sml file. By ending and restarting a session, the new session has an empty environment. Your earlier interactions are still in the 𝚜𝚖𝚕 buffer, so you can save them, cut-paste them, etc., but they have no effect on the evaluation in the restarted REPL session. Evaluation can go into an infinite loop. This has likely occurred if you are not getting the “-“ prompt back and nothing appears to be happening. 𝙲-𝚌 𝙲-𝚌 will interrupt evaluation and get you your prompt back. If you forget to end your binding with a “;” character, the REPL will print an “=” character on the next line, which is just its way of saying, “you are not done – continue your binding,” so type a “;” and hit Return/Enter. This is not an infinite loop (nothing is being evaluated; the REPL is waiting for you) so 𝙲-𝚌 𝙲-𝚌 does not do anything. If the printed result looks “pretty good,” but part of what you expected to see has been replaced by a “#” or “ …” this is normal. The REPL has a limit on how many characters it prints, which is good since you might make a large value, such as a list with tens of thousands of elements. You can adjust the limit if you want. Two keyboard commands are particularly useful in the REPL: 𝙼-𝚙 will print the previous line you used in the REPL, which you can then run again or edit before running. Repeating 𝙼-𝚙 will cycle through previous REPL lines, allowing you to bring back up any of your previous REPL expressions. The p stands for previous. 𝙼-𝚗 (repeatedly) does the same thing in the opposite direction, with the n standing for next. Advice You Will Wish You Followed! In each REPL session, follow this pattern: First type 𝚞𝚜𝚎 “𝚏𝚘𝚘.𝚜𝚖𝚕”; for any SML files you want to use. Then use the REPL manually as long as you wish. After using the REPL to test something, do not use use to load (or reload) any more files. When tempted to violate the previous point, end and restart your REPL session before continuing. Why: 𝚞𝚜𝚎 “𝚏𝚘𝚘.𝚜𝚖𝚕”; has a very simple semantics: it adds the ML bindings in the file to the environment in order. These may or may not shadow ML bindings from the last time you typed 𝚞𝚜𝚎 “𝚏𝚘𝚘.𝚜𝚖𝚕”;, depending on how foo.sml changed. This confuses even expert programmers until they train themselves to follow the pattern above. If you find yourself typing the same non-trivial things repeatedly in the REPL, stop wasting your time. Move the repeated parts to a second file, e.g., 𝚝𝚎𝚜𝚝.𝚜𝚖𝚕.Then, when you restart your session, begin with 𝚞𝚜𝚎 “𝚏𝚘𝚘.𝚜𝚖𝚕”; 𝚞𝚜𝚎 “𝚝𝚎𝚜𝚝.𝚜𝚖𝚕”;.In fact, there is an even faster way: Begin test.sml with the expression 𝚞𝚜𝚎 “𝚏𝚘𝚘.𝚜𝚖𝚕”; Then begin your session with 𝚞𝚜𝚎 “𝚝𝚎𝚜𝚝.𝚜𝚖𝚕”; Note: Do not put 𝚞𝚜𝚎 “𝚏𝚘𝚘.𝚜𝚖𝚕”; in 𝚝𝚎𝚜𝚝.𝚜𝚖𝚕 and begin your session with 𝚞𝚜𝚎 “𝚏𝚘𝚘.𝚜𝚖𝚕”; 𝚞𝚜𝚎 “𝚝𝚎𝚜𝚝.𝚜𝚖𝚕”;. That will evaluate the ML bindings in 𝚏𝚘𝚘.𝚜𝚖𝚕 twice, which is confusing. If you develop some emotional attachment to the transcript of your 𝚜𝚖𝚕 buffer, you can save it to a file just like any other buffer. But after you do, it is not an 𝚜𝚖𝚕 buffer anymore, so you will have to create a new 𝚜𝚖𝚕 buffer from a buffer in SML Mode via 𝙲-𝚌 𝙲-𝚜. Acknowledgments: These instructions were prepared starting with material created by Ben Wood, adapted from prior materials by Dan Grossman and Hal Perkins. Stefan Monnier provided fantastic feedback on this document and even created SML Mode version 6 to simplify SML Mode installation substantially. John Reppy provided excellent improvements to the SML/NJ installation instructions. -from coursera","tags":[{"name":"Emacs","slug":"Emacs","permalink":"http://kingle.online/tags/Emacs/"}]},{"title":"预览应用扩展增强工具","date":"2017-02-03T12:57:45.000Z","path":"2017/02/03/预览应用扩展增强工具/","text":"针对mac系统的预览工具，快捷键是空格键Mac上的预览工具，本身就非常好用，大多数文件，比如图片、Office文档、MP3等文件在文件夹上，选中后，按一下空格就可以快速预览到内容。 但是，你还可以拓展它的功能，让它更加好用 。下面是简介和安装方法： 1、预览查看图片分辨率&amp;大小 2、代码语法高亮 3、快速预览zip压缩包内容 4、快速预览markdown格式内容 还有很多有意思的插件，比如查看安卓的apk信息、MD文件等，具体可以看sindresorhus/quick-look-plugins的介绍。 那么如何安装这些插件呢？简单2步： 打开Mac的 “终端” 工具（可右上角 放大镜 搜 终端）： 需要先安装HomeBrew工具。 安装好上面的工具后，再安装插件。如果需要更多其他插件，就在后面加插件名： brew cask install qlcolorcode betterzipql qlimagesize qlmarkdown 安装过程中，可能需要多次输入系统密码，请留意。","tags":[{"name":"mac","slug":"mac","permalink":"http://kingle.online/tags/mac/"},{"name":"tool","slug":"tool","permalink":"http://kingle.online/tags/tool/"}]},{"title":"windows软件推荐","date":"2017-01-26T13:53:33.000Z","path":"2017/01/26/windows软件推荐/","text":"一、软件推荐1.1 Listary Listry 快捷键： 启动搜索框及界面 双击 Ctrl 桌面双击左键 在打开文件的时候搜索文件 自动或手动 Google或者Baidu搜索 gg bd 备选：evertthing Listry CapsLock+ 使用教程 官方文档 1.2 PDF-Viewer{% image http://ojlmcfp94.bkt.clouddn.com/pdfview.jpg 'Listry' '' %} 备选：SumatraPDF(http://www.sumatrapdfreader.org/free-pdf-reader.html) Sumatra PDF is a PDF, ePub, MOBI, CHM, XPS, DjVu, CBZ, CBR reader for Windows 福昕阅读器adobe reader 1.3 Bandizip{% image http://ojlmcfp94.bkt.clouddn.com/Bandizip.png 'Listry' '' %} Bandizip : 轻巧、快速、免费的压缩软件Bandizip 是一款可靠和快速的压缩软件，它支WinZip、7-Zip 和 WinRAR 以及其它压缩格式。它拥有非常快速的压缩和解压缩的算法，适用于多核心压缩、快速拖放、高速压缩等功能。 备选：‎WinRAR Listry WinRAR is a powerful archive manager. It can backup your data and reduce the size of email attachments, decompress RAR, ZIP and other files downloaded from Internet and create new archives in RAR and ZIP file format. 7-zip 跨平台{% image http://ojlmcfp94.bkt.clouddn.com/7z_rm01.jpg 'Listry' '' %} 1.4 potplayer{% image http://ojlmcfp94.bkt.clouddn.com/Listary.png 'Listry' '' %} 由于PotPlayer与KMPlayer同属一个开发者的产品，所以PotPlayer拥有KMPlayer的硬件加速、支持高清视频播放、界面整洁、操作简单、使用轻松、皮肤丰富多彩等特点，能够满足不同用户的使用需求。Daum PotPlayer也可以在64位Windows系统上运行。 potplayer皮肤 备选：KMPlayer Listry http://www.kmplayer.com/ 1.5 Snipaste Listry 官方文档 备选：qq截图微信截图 1.6 科学上网收费：shadowsocks + VPS(https://github.com/shadowsocks){% image http://ojlmcfp94.bkt.clouddn.com/shadowsocks.png 'Listry' '' %} vultr(https://www.vultr.com/) Listry 免费：XX-Net {% image http://ojlmcfp94.bkt.clouddn.com/xx-net.png 'Listry' '' %} 中文文档 XX-Net is a free desktop application that delivers fast, reliable and secure access to the open Internet for users in censored regions. It uses google app engine (GAE) as a proxy server through the firewall. 蓝灯 二、chrome插件推荐2.1 马克飞象 Listry Markdown 是一种简单的、轻量级的标记语法。用户可以使用诸如 * # 等简单的标记符号以最小的输入代价生成极富表现力的文档。 备选：Cmd Markdown Listry 作业部落出品，也是一款不错的工具和博客平台兼顾的产品。全平台且提供web版 FarBox Listry 一个支持Markdown写作语法的博客平台，让用户通过Dropbox（现在默认是自己的同步服务器）直接建立个人网站。FarBox编辑器免费，支持多平台（无web版，Linux版停止维护）,Farbox服务可以免费试用，在本地编辑器内写作自动同步发布在个人博客，对像笔者这样希望有个人博客但却不愿折腾的小白来说，是个不错的选择。 小书匠编辑器 有道云笔记 好用的Markdown编辑器一览http://www.williamlong.info/archives/4319.html 2.2 lastpass用户手册 Listry Lastpass是一个优秀的在线密码管理器和页面过滤器，采用了强大的加密算法，自动登录/云同步/跨平台/支持多款浏览器。 Listry 2.3 印象笔记* 剪藏{% image http://ojlmcfp94.bkt.clouddn.com/caijian.png 'Listry' '' %} 印象笔记全家桶，值得推荐。 2.4 adblock plus Listry 2.5 净网大师{% image http://ojlmcfp94.bkt.clouddn.com/%E5%87%80%E7%BD%91%E5%A4%A7%E5%B8%88.png 'Listry' '' %} 2.6 Vimium Listry 2.7 扩展管理 Listry 三、微信公众号3.1 ZEALER订阅号 Listry 首页(http://www.zealer.com/) 科技相对论 ZEALER | TIPS 一系列的手机测评 3.2 科技美学官网：（http://www.kejimeixue.com/） Listry Listry 3.3 笔吧测评室 Listry 微信二维码： Listry 3.4 卓老板聊科技 Listry 以科学故事、理工科思维、生活科技为主要内容。通过普及科学思想更新人们陈旧的观念。 Listry 四、几个网站4.1 廖雪峰的官方网站http://www.liaoxuefeng.com/ 4.2 阮一峰的网络日志http://www.ruanyifeng.com/blog/ 4.3 张鑫旭-鑫空间-鑫生活http://www.zhangxinxu.com/ 4.4 实验楼实验楼","tags":[{"name":"windows","slug":"windows","permalink":"http://kingle.online/tags/windows/"},{"name":"软件","slug":"软件","permalink":"http://kingle.online/tags/软件/"}]},{"title":"技术分享","date":"2017-01-11T13:54:32.000Z","path":"2017/01/11/techshare1/","text":"一、软件推荐1.1 Listary 快捷键： 启动搜索框及界面 双击 Ctrl 桌面双击左键 在打开文件的时候搜索文件 自动或手动 Google或者Baidu搜索 gg bd 备选：evertthing CapsLock+ 使用教程 官方文档 1.2 PDF-Viewer 备选：SumatraPDF(http://www.sumatrapdfreader.org/free-pdf-reader.html) Sumatra PDF is a PDF, ePub, MOBI, CHM, XPS, DjVu, CBZ, CBR reader for Windows 福昕阅读器adobe reader 1.3 Bandizip Bandizip : 轻巧、快速、免费的压缩软件Bandizip 是一款可靠和快速的压缩软件，它支WinZip、7-Zip 和 WinRAR 以及其它压缩格式。它拥有非常快速的压缩和解压缩的算法，适用于多核心压缩、快速拖放、高速压缩等功能。 备选：‎WinRAR WinRAR is a powerful archive manager. It can backup your data and reduce the size of email attachments, decompress RAR, ZIP and other files downloaded from Internet and create new archives in RAR and ZIP file format. 7-zip 跨平台 1.4 potplayer 由于PotPlayer与KMPlayer同属一个开发者的产品，所以PotPlayer拥有KMPlayer的硬件加速、支持高清视频播放、界面整洁、操作简单、使用轻松、皮肤丰富多彩等特点，能够满足不同用户的使用需求。Daum PotPlayer也可以在64位Windows系统上运行。 potplayer皮肤 备选：KMPlayer http://www.kmplayer.com/ 1.5 Snipaste 官方文档 备选：qq截图微信截图 1.6 科学上网收费：shadowsocks + VPS(https://github.com/shadowsocks) vultr(https://www.vultr.com/) 免费：XX-Net 中文文档 XX-Net is a free desktop application that delivers fast, reliable and secure access to the open Internet for users in censored regions. It uses google app engine (GAE) as a proxy server through the firewall. 蓝灯 二、chrome插件推荐2.1 马克飞象 Markdown 是一种简单的、轻量级的标记语法。用户可以使用诸如 * # 等简单的标记符号以最小的输入代价生成极富表现力的文档。 备选：Cmd Markdown 作业部落出品，也是一款不错的工具和博客平台兼顾的产品。全平台且提供web版 FarBox 一个支持Markdown写作语法的博客平台，让用户通过Dropbox（现在默认是自己的同步服务器）直接建立个人网站。FarBox编辑器免费，支持多平台（无web版，Linux版停止维护）,Farbox服务可以免费试用，在本地编辑器内写作自动同步发布在个人博客，对像笔者这样希望有个人博客但却不愿折腾的小白来说，是个不错的选择。 小书匠编辑器 有道云笔记 好用的Markdown编辑器一览http://www.williamlong.info/archives/4319.html 2.2 lastpass用户手册 Lastpass是一个优秀的在线密码管理器和页面过滤器，采用了强大的加密算法，自动登录/云同步/跨平台/支持多款浏览器。 2.3 印象笔记* 剪藏 印象笔记全家桶，值得推荐。 {% image ./1480583030487.png 'Alt text|' '' %} 2.4 adblock plus 2.5 净网大师 2.6 Vimium 2.7 扩展管理 三、微信公众号3.1 ZEALER订阅号 首页(http://www.zealer.com/) 科技相对论 ZEALER | TIPS 一系列的手机测评 3.2 科技美学官网：（http://www.kejimeixue.com/） 3.3 笔吧测评室 微信二维码： 3.4 卓老板聊科技 以科学故事、理工科思维、生活科技为主要内容。通过普及科学思想更新人们陈旧的观念。 四、几个网站4.1 廖雪峰的官方网站http://www.liaoxuefeng.com/ 4.2 阮一峰的网络日志http://www.ruanyifeng.com/blog/ 4.3 张鑫旭-鑫空间-鑫生活http://www.zhangxinxu.com/ 4.4 实验楼","tags":[{"name":"软件推荐","slug":"软件推荐","permalink":"http://kingle.online/tags/软件推荐/"},{"name":"网站推荐","slug":"网站推荐","permalink":"http://kingle.online/tags/网站推荐/"}]}]